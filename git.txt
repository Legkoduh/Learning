Система контроля версий (VCS)
Хранит всю историю изменений, которые вносились в проект
Позволяет вернуться к предыдущим версиям приложения/проекта
Branch (ветка) среда разработки кода
Master branch - главная ветка, в которой храниться эталонная/прод. версия кода
Другие ветки (dev1, dev2, test) - позволяют вести в них разработку, тестирование
Репозиторий - место хранения веток
Репозиториев бывает несколько: 1 для хранения веб версии, 2 для мобильной версии и тд
git - распределенная система контроля версий - позволяет скопировать репозиторий на свой компьютер и работать с ним локально
В случае возникновения проблем с главным репозиторием - можно скопировать локальный со стабильной версией кода

После установки git, для проверки успешности инсталяции - вызвать cmd и напечатать в ней git
Затем необходимо создать Конфиг файл, для этого в cmd - copy NUL .gitconfig
Проверяем, что по указаному пути создан файл gitconfig
Добавляем в этот файл информацию про ник и имейл и сохраняем ее:
[user]
    email=legkoduh.dp@gmail.com
    user=Kiril
Или так
git config --global user.name "Name" --- укажите ваше имя
git config --global user.email name@example.com --- укажите вашу почту
Эти данные будут передаваться в репозиторий, когда в него будут вноситься изменения
Благодаря этому, можно увидеть, кто и когда вносил в него изменения
Проверить добавление параметров пользователя можно прописал в cmd: git config --list --global

git - построен по принцыпу клиент-серверной архитектуры
Клиент - это git установленный на локальном ПК, а сервер - внутренний репозиторий компании или github, gitlab

После создания репозитория, для удаленной работы с ним, необходима ссылка на него, она находится в дроп-даун "Code" (HTTPS/SSH or GitHub CLI)
Для копирования репозитория на локальный ПК, в cmd пишем - git clone https://github.com/Legkoduh/masterRepo.git (ссылка на нужный репозиторий)
Далее добавляем файл в папку с локальным репозиторием и проверяем статус - git status
Показывается список файлов, которые еще не отслеживаются git-ом
Для отслеживания файла системой контроля версий, в сmd, используется команда - git add File1.txt (название нужного файла)
Для проверки успешности добавления файла в VCS - git status. Показывается список добавленных для отслеживания файлов
Статус файла изменился с untracked в new file
После добавления изменений в файл и проверки статуса - у файла 2 статуса: new file и modified
Мы можем откатиться к предыдущей версии файла, до изменений - git restore js.txt
Или добавим эти изменений - git add js.txt
git status - у файла 1 статус - New file
Для сохранения всех изменений - git commit -m 'Message about changes in this commit'
git status - nothing to commit
Для добавления файла в удаленный репозиторий - git push
Открывается страница авторизации github, после успешного логина - все изменений (новые файлы, изменений в файлах) добавлены в удаленный репозиторий

Один и тот же файл может быть
Changes to be committed:
        modified:   cases
Changes not staged for commit:
        modified:   cases
Changes to be committed — это staged изменения, то есть уже добавленные в индекс (с помощью git add) и готовые к коммиту
Changes not staged for commit — это новые изменения, которые появились после того, как файл был добавлен в индекс (git add)
То есть файл cases в индексе есть одна версия, а в рабочем каталоге — ещё одна изменённая версия. Git показывает обе


bash commands:
cat js.txt (file name) - вывести содержимое файла в bash console

git на локальном ПК не знает об изменениях в удаленном репозитории, что бы их обнаружить используется команда - git fetch
Показывает на сколько коммитов локальная ветка отстает от удаленного
master -> origin/master
master - ветка в локальном репозитории
origin master - ветка на удаленном репозитории
origin/master - локальная, но нерабочая версия ветки master
Это промежуточная ветка, информация в которой, соответствует origin репозиторию на момент последнего запуска команды git fetch
При запуске команды git fetch ветка не изменяется
Что бы пришли изменения с удаленного репозитория на локальный необходимо использовать команду git pull
Updating 6629828..cabf76a
6629828..cabf76a - хэш коммита - уникальный идентификатор/номер, который присваиваеться каждому коммиту
git log - выводит список всех коммитов, который включает: хэш коммита, автора, дату, имя файла и комментарий к коммиту
q - закрыть git log и продолжить работу с bash console
Список изменений конкретного автора - git log --author Kiril
Просмотреть конкретный коммит - git show b2553d263a45296812a364151f3ae8af41340313 (хэш коммита)
Просмотреть последний коммит - git show
Узнать автора строки в файле - git blame js.txt (file name)
Узнать кто добавил конкретную строку в файл - git blame File1.txt | grep 789 (нужная строка)
Узнать вносил ли изменения конкретный автор - git blame File1.txt | grep Kiril
touch - добавить новый файл
Добавить новую строку в файл - echo "Add new line" >> File1.txt (file name)
Добавить новый файл и строку в него - echo "First line in the new file" >> NewFile1.txt (name of the file)
Если файла с таким названием и расширением не существует - он будет создан и в него будет добавлена строка "First line in the new file"
Просмотреть различие локального и удаленного файлов - git diff
git diff (document_name) git diff js.txt
Команды git на локальном ПК выводят последнюю информацию именно с локальной машины, актуальные данные будут выводится после успешного git pull
Файлы в статусе modified могут быть добавлены в коммит без команды git add, а для файлов со статусом Untracked - это обязательно

git add - добавить изменения (новый файл, изменения в файлах) в коммит
git commit -a -m "Message" - применить все изменения (-a - add ???, -m - message). Параметры a и m можно обьединять (-am)
git fetch - сравнить локальную и удаленную ветки на наличие расхождений/изменений/несоответствий, проверить отличия локального репозитория от удаленного
git pull - обновление локальной ветки до актуальной/последней версии, синхронизация локальной и удаленной веток
git reset HEAD~1 - вернуть состояние на 1 коммит назад (параметр hard - безвозвратно удаляет изменения в коммите)
В случае возникновения конфликта, который пока нельзя решить (изменения в одном и том же файле в удаленном и локальном репозиториях),
можно отменить последний мерж - git merge --abort
git указывает в файле (локальном и все ?), который является причиной конфликта, конкретное место возникновения конфликта
<<<<<<< HEAD
Lines of code
==========
Lines of enother code
>>>>>>> d56b6818beb413d0571a7c681924d40c10855678 (hash of the commit)
После решения конфликта на локальной машине: git add (file name), git commit -am "Message", git push
git checkout (file name) - отменить изменения в файле (like git restore ?)
git checkout . - отменить изменения во всех файлах
Он не затрагивает уже закоммиченные изменения (git commit), но работает для файлов добавленных в индекс (git add)
git stash pop - вернуть изменения из временного хранилища
git stash clear - удалить временное хранилище
git stash list — показывает все сохранённые “стэши” в твоём репозитории
Каждый stash получает имя вроде:
stash@{0}: WIP on main: 1234567 Комментарий
stash@{1}: WIP on main: 89abcd0 Другое сохранение
stash@{0} — самый последний stash
stash@{1}, stash@{2} … — более старые stash’и
Комментарий после WIP on <branch> обычно содержит последний коммит в ветке на момент stash
Чтобы вернуть изменения из стэша:
git stash apply stash@{0} - применяет последний stash, оставляя его в списке
git stash pop - применяет последний stash и удаляет его из списка


------------------------- Работа с ветками -------------------------
master branch - история изменений проекта
commit - изменения проекта
git branch - просмотр списка веток в локальном репозитории
git branch -r - просмотр списка веток в удаленном репозитории
git branch -a - просмотр списка всех веток в локальном и удаленном репозиториях
git branch first_branch (name of the branch) - создать новую ветку
git branch -b first_branch (name of the branch) - создать новую ветку и сразу же переключится на нее
Новая ветка соответствует master ветке в репозитории (содержит все файлы и их наполнение), на момент последнего коммита
Звездочкой (*) отмечена текущая ветка, в которой, в данный момент идет работа (*main)
git checkout first_branch (branch name) - переключится в ветку first_branch
git checkout - - перейти в предыдущую ветку (на 1 шаг назад)
Если пушить изменения в репозиторий, в котором еще нет новой, созданной на локальной машине ветки - возникает ошибка
git push -u origin first_branch (name of the local branch) - создать новую локальную ветку в удаленном репозитории и связать их

git remote add origin https://github.com/твой_ник/имя_репозитория.git - связать локальный репозиторий с удалённым
origin — это имя удалённого репозитория (может быть любое, но по умолчанию обычно origin)
URL — адрес репозитория на GitHub
git push -u origin main
-u — устанавливает ветку main как upstream (будет пушить/тянуть по умолчанию)
origin — имя удалённого репозитория
main — имя ветки (раньше часто была master, сейчас чаще main)

Для мерджа необходимо переключится в ту ветку, в которую нужно сделать мердж
git merge new_branch (name of the branch) - мердж new_branch ветки в актуальную, где сейчас находитесь, ветку
Мерж new_branch ветки в best_branch ветку:
git checkout best_branch
git merge new_branch
git push
Мерж был произведен в локальном репозитории, а для мержа в удаленном - необходимо провести git push
merge - слияние 2-х веток (удаленной master с локальной dev)
Мердж ветки в мастер ветку отображается коммитом
Изменения будут добавлены в ту ветку, из которой делается коммит и пуш
(изменения в branch1, переключение на branch2, коммит и пуш - изменения добавленны в branch2 ветку в удаленном репозитории)
Изменения в 1 ветке будут применены во всех, до того как в нужной ветке будет выполнен коммит*
*можливо я просто не переключився в main гілку, бо гіт не дає це зробити, якщо були зміни у файлах і вони ще не закомічені

Изменение названия пустой ветки:
git branch -m first_name second_name - изменить название ветки first_name на second_name
Изменение названия ветки с файлами:
git branch -m first_name second_name - название не меняется в удаленном репозитории
git push origin :first_name - удаляем старую ветку в удаленном репозитории
// - [deleted]         firstname_changed
git push -u origin second_name - создаем эту ветку с новым названием (second_name)
Названия ветки во время переименования и пуша должны совпадать
Если не указать -u, то не будет создана upstream ветка и при попытке пуша - возникает ошибка
fatal: The current branch Check2 has no upstream branch.
To push the current branch and set the remote as upstream, use git push --set-upstream origin Check2 (or git push -u origin Check2)
Upstream branch - это локальная ветка, ветка слежения, которая на прямую связана с удаленной
При клонировании репозитория, как правило, автоматически создаётся ветка master, которая следит за origin/master
При создании новой локальной ветки, upstream ветка не создается автоматически и ее нужно создавать самому ?
При клонировании репозитория, автоматически создаются локальные upstream ветки для всех веток в репозитории ?
Так же, после переименования локальной ветки (branch1 to branch2), можно ее создать в удаленном репозитории:
fatal: The upstream branch of your current branch does not match the name of your current branch.
To push to the upstream branch on the remote, use git push origin HEAD:branch1 - изменения из ветки branch2 применяются в ветку branch1 в удаленном репозитории
To push to the branch of the same name on the remote, use git push origin HEAD - создается ветка с новым названием в удаленном репозитории

Удаление локальной ветки:
git branch -d second_name
//Deleted branch second_name (was 419422b).
Вернуть удаленную локальную ветку:
git fetch origin second_name (без :)
//[new ref]                    -> second_name
Но ее еще нет в списке git branch
Что бы она там отображалась - нужно перейти в нее - git checkout second_name
//branch 'second_name' set up to track 'origin/second_name'.
Удаление ветки с удаленного репозитория
git push origin :second_name (branch name)
git push -u origin :second_name (branch name) ???
Удалить файл из ветки: (сначала локальной, а затем используя commit и push - удаленной)
1.) При помощи команды git rm
git rm ConflictFile.txt (file name) - данная команда сама запустит git add (файл должен быть в удаленном и локальном репозиториях)
git commit -m "File name deleted"
git push
2.) Используя проводник OS ПК
Удалить нужные файлы через проводник
git add
git commit -m "File name deleted"
git push
https://ru.stackoverflow.com/questions/622709/%D0%9A%D0%B0%D0%BA-%D1%83%D0%B4%D0%B0%D0%BB%D0%B8%D1%82%D1%8C-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B8%D0%B7-master-%D0%B2%D0%B5%D1%82%D0%BA%D0%B8-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F

git fetch origin : (with :) any name - creates a new local branch (copy of master) ?
git push origin (: - optional) branch_name - ?

------------------------- Работа с новым локальным проектом -------------------------
1. git init — создаёт .git и инициализирует локальный репозиторий
2. git add . — добавляешь файлы в индекс
3. git commit -m "Первый коммит" — создаёшь первый коммит
4. git remote add origin <URL> — подключаешь удалённый репозиторий
5. git branch -M main — (опционально) переименовываешь ветку в main, если нужно
6. git push -u origin main — отправляешь проект на GitHub (или другой хостинг)

Конфликт 1 - в удаленный репозиторий добавлены файлы, которых нет в локальном
git pull

Конфликт 2 - строка в файле отличается в удаленном и локальном репозиторииях
git pull
Edit this file manually, leave the code what is necessary and save
git add (name of the file with manual fix)
git commit -am "Message"
git push

------------------------- git GUI -------------------------
git GUI & - launch git GUI
gitk & - the history of all actions with the repository (Visualize master's history)


Use case:
Загрузить репозиторий на локальную машину - git clone (url of the repository)
Добавить все изменения в VCS - git add (name of the file with extension)
Сохранить все измнения - git commit -m 'Message about sense of the commit'
Отправить изменения с локальной машины в удаленный репозиторий - git push (and then - pass the verification with valid data)

echo > main.py - add a new File using the Terminal


Создание локального репозитория в PyCharm
Version Control drop-down at the left top - Create Git Repository
Это идентично git init, которая используется для создания нового, пустого репозитория Git или для повторной инициализации существующего
С помощью этой команды  Git создает скрытый каталог .git, который включает метаданные, такие как подкаталоги для объектов и файлы шаблонов, необходимые для создания нового репозитория Git
В этом каталоге хранятся все объекты и ссылки, которые Git использует и создает как часть истории проекта
Далее можно создать связь между локальным и удаленным репозиториями
git remote - управляет набором удалённых репозиториев, которые вы связали с локальным репозиторием
Основные возможности git remote:
git remote add [repository_name] [repository_url] - связывает локальный репозиторий с удаленным репозиторием
git remote -v - отображает список удаленных репозиториев , связанных с локальным репозиторием
git remote remove [repository_name] - удалить связь с удаленным репозиторием
repository_name - имя удаленного репозитория, по умолчанию - origin, но можно указать любое имя
git remote add custom_repo_name https://github.com/L/test.git
git add . - добавить все неотслеживаемые файлы в index
git commit -m "Commit message" - создать коммит
git push --set-upstream [repository_name] [current_branch_name]
current_branch_name - имя локальной ветки в которой были сделаны изменения, по умолчанию master или main
Если ветки с таким именем нет в удаленном репозитории - она будет там создана
upstream — это связь, которая говорит Git, какую удалённую ветку использовать по умолчанию при git push и git pull
git push --set-upstream custom_repo_name master - означает пуш локальной ветки master в репозиторий custom_repo_name в ветку master
Если 2 разработчика назовут у себя удаленный репозиторий по разному, Git поймет, что им нужен один и тот же репозиторий благодаря ссылке, которую они указывают в git remote add
Git не смотрит на имя удалённого репозитория, которое вы дали локально. Он ориентируется только на URL репозитория, который указан при git remote add
-u -это короткая запись для --set-upstream
git push -u origin my_branch аналогична git push --set-upstream origin my_branch
git branch -vv - проверить, какие ветки уже имеют установленный upstream
Флаг -u (--set-upstream) нужно указывать только один раз — при первом пуше новой ветки
После этого Git запоминает связь между твоей локальной веткой и соответствующей удалённой веткой

Создание удаленного репозитория в PyCharm
Version Control drop-down at the left top - Share Project On - выбрать нужную платформу (GitHub, GitLab и тд)
В окне Share Project On:
Repository name - имя удаленного репозитория, который будет создан на выбранной платформе
Remote - имя локального репозитория
PyCharm создаст репозиторий на GitHub с именем, которое ты указал в поле Repository name
По умолчанию репозиторий может быть приватным, если так настроен GitHub. PyCharm учитывает настройки приватности аккаунта
PyCharm создает и пушит только текущую локальную ветку, на которой ты находишься (например, master или main)
Только для текущей ветки PyCharm автоматически устанавливает upstream на созданный удалённый репозиторий
Остальные локальные ветки нужно пушить и создавать upstream самому


Запись [repository_name]/[branch_name] - это ссылка на удалённую ветку, локальная копия состояния ветки в удаленном репозитории (remote-tracking branch)
origin/my_branch является upstream-веткой для локальной main
Git хранит её в локальном репозитории, для отслеживания удаленной ветки и она только для чтения
Она отражает состояние, что находится в соответствующей ветка на GitHub или другом удалённом репозитории
Нельзя напрямую коммитить в origin/my_branch, это только отражение удалённой ветки
Где используется origin/my_branch:
1. При просмотре веток
git branch -a
* my_branch
  master
  remotes/origin/master
  remotes/origin/my_branch
2. При переключении на удалённую ветку (read-only)
git checkout origin/my_branch
Это переходи в состояние “detached HEAD”, просто чтобы посмотреть, что в удалённой ветке, но коммитить туда нельзя
3. При создании локальной ветки на основе удалённой
git checkout -b my_branch origin/my_branch
Эта команда создаёт новую локальную ветку my_branch, которая будет отслеживать удалённую origin/my_branch
4. При слиянии, сравнении, логах
git diff origin/my_branch
git log origin/my_branch
git merge origin/my_branch
Так Git понимает, что имеется в виду “удалённая версия ветки my_branch”

Они обновляются при git fetch origin
Git:
1. идёт на GitHub (или другой удалённый репозиторий);
2. получает информацию о последних коммитах;
3. обновляет твои локальные origin/master, origin/my_branch и т.д.
Важно: при этом твоих локальных веток (master, my_branch) Git не трогает — он просто обновляет информацию о том, что происходит “на сервере”

Не используется origin/my_branch в командах, где нужно указывать репозиторий и ветку отдельно, например:
git push origin my_branch
git pull origin my_branch


git pull обьединяет 2 команды: git fetch и git merge
Git на самом деле выполняет две операции:
git fetch - забирает новые коммиты из удалённого репозитория (например, origin) и обновляет локальные ссылки вроде origin/main, origin/my_branch
git merge (без дополнительных параметоров) - сливает (merge) обновлённую локальную ветку, для отслеживания удаленной (origin/main) в соответствующую/текущую/активную локальную (main)
git merge (без дополнительных параметоров) - подтянуть изменения из локальной upstream ветки, если она настроена, в текущую локальную ветку (из origin/main в main)
Если upstream ветка уже указано, вместо git merge origin/branch_name можно использовать просто git merge
git merge branch_name - слить 2 ветки: branch_name в активную, в которой выполняется эта команда
Если выполнить: git pull origin main
Git сделает это шаг за шагом:
git fetch origin main         # забирает новые коммиты с сервера (репозиторий origin, ветка main)
git merge origin/main         # сливает их из локальной ветки origin/main в локальную ветку main

После git fetch origin main (или просто git fetch) Git обновляет локальные ссылки на удалённые ветки
Эти ссылки называются origin/main, origin/feature, и так далее
origin/main не является удалённой веткой на сервере — это локальная копия того, что есть в origin main на сервере
Когда ты делаешь git merge origin/main, Git берет коммиты из этой локальной копии и объединяет их с твоей текущей веткой
То есть merge всегда происходит с локальной веткой или коммитом, а не напрямую с сервером
Git обновляет эту локальную копию удалённой ветки при git fetch или git pull
Команда git merge <branch>
Работает только с локальными ветками для отслеживания удаленных (типа origin/main) или коммитами, которые есть в твоём локальном репозитории
Она не обращается к удалённому репозиторию для объединения
То есть merge всегда берёт то, что уже есть у тебя на компьютере, и сливает это в текущую ветку

При помощи git fetch [repository_name] [branch_name] и git merge [repository_name]/[branch_name] - можно слить удаленную ветку не в ее локальную копию, а в другую ветку
git checkout feature - переключится в ветку feature
git fetch origin main - стянуть последние изменения из удаленной ветки main в ее локальную копию для отслеживания удаленной (origin/main)
git merge origin/main - слить ветку main в ветку feature (активную во время выполнения команды)
Или при помощи одной команды git pull (которая сама выполнит fetch origin main и merge origin/main)
git checkout feature
git pull origin main


Разница между git pull и git pull rebase
В ветке есть коммиты
А - B - C - D (коммит другого разработчика)
        | (ветка была создана на коммите C)
        E - F (твои коммиты)
При git pull Git делает
git fetch
git merge origin/main
Git создает новый merge-коммит M, чтобы объединить изменения
История ветвится, но сохраняет все ветви и связи, получается полная история без потерь
При git pull --rebase
git fetch
git rebase origin/main
После этого история выглядит так: A---B---C---D'---E'
Git переписал твои коммиты (D, E) поверх C, как будто ты их сделал уже после обновлений из origin
История стала линейной и чистой — без merge-коммитов
Но технически создаются новые коммиты (D', E'), так что с уже опубликованными ветками нужно быть осторожным
Для личных веток лучше git pull --rebase, для общих веток - чаще используют обычный git pull (сохраняется история всех объединений)


Папка test содержит 2 файла: test1.py и test2.py
git add test - добавит в index папку и оба файла
git add test/test1.py - добавит только файл test1.py
git rm --cached FileName - удалит файл из index
git rm --cached test/test1.py
Если папка test и хотя бы один файл в ней добавлены в index - для их удаления нужен дополнительный параметр -r
git rm -r --cached test - удалит из индекса папку и все файлы добавленные в index
