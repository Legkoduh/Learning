Разница между Java и Javascript
1. В JS переменные обьявляются ключевыми словами let и const
В Java, для обьявления переменной необходимо указать ее тип

2. В JS переменная получает тот тип, которым является ее значение
В Java тип переменоой, указанный во время ее обьявления, должен соответствовать типу значения или быть совместимым (int > double, char > String)

3. В JS обьектам можно добавлять новые свойства, при вызове обьекта, за пределами Класса
В Java свойства обьекта можно добавлять только в его Классе (но это не точно)

4. В JS - динамическая типизации. При обьявлении переменной не нужно указывать тип ее значения, только ключевые слова let или const и можно присваивать значения различных типов (менять их)
В Java - статическая типизация, при обьявлении переменной нужно указать тип ее значения и ей нельзя присвоить значение другого типа

5. В JS методы/функции обьявляются с помощью ключевого слова function и имени с круглыми скобками
В Java методы обьявляются с помощью типа возвращающего значения (или void если метод ничего не возвращает) и имени с круглыми скобками

6. Массив в JS может содержать элементы разных типов (number, String, boolean, undefined)
Длину массива можно изменять после его создания/обьявления, явно или путем добавления нового элемента

7.Java передает все по значению.
Для примитивных типов — вы передаете копию текущего значения, для ссылок на объекты — вы передаете копию ссылки
Можно изменить обьект (свойства) используя копию ссылки в методе, но вы не можете взять и изменить ссылку — переадресовать её на другой объект или null
Передавая в метод копию ссылки на обьект и записывая в нее новый обьект, передання копия ссылки просто начинает смотреть но новый обьект и все изменения происходят с ним
После завершения работы метода, копия ссылки, переданная в него - удаляется, а также новый обьект, на который она смотрела, и все изменения с ним
Изменений с исходным обьектом, копия ссылки на который была передана в метод, не происходило и поэтому он остается прежним
Если в методе производить изменения свойств обьекта, используя переданную копию ссылки на обьект - изменения будут применены к свойствам оригинального обьекта
Потому что оригинальная ссылка и ее копия, как параметр в методе, смотрят на один и тот же обьект

Как в Java передать метод в качестве параметра другому методу ?


if (a==3) {console.log(1)}
else if (a>1) {console.log(2)}
else {console.log(3)}
let a = 3 //1, a = 2 //2, a = 1 //3

Выражения
Обьекты
Функции (Методы)

Практически все сущности - обьекты

Обьект - тип значения, тип переменной (если ее значение - обьект)
Обьект - структура данных, которая позволяет организовывать данные определенным образом
Обьект - набор Свойств
Свойства состоят из Имени (Ключа) и Значения
Вложенный обьект - Значение является Свойством
Свойства Обьекта описываются в фигурных скобках {} и через запятую
Сначала указывается имя/ключ Свойства, затем двоеточие, а потом его Значение
const person = {
name: 'Mark',
gender: 'Male',
age: 30
profession: 'Designer' }

Получить доступ к свойствам обьекта можно через точечную запись и с помощью квадратных скобок
console.log(person.name)
Имена свойств обьекта в квадратных скобках указываются как строка, в кавычках
console.log(person['profession'])
Использование квадратных скобок может пригодится, если имя/ключ свойства записан в переменную
let personPropertyName = 'profession'
console.log(person[personPropertyName])

const boomer = {mark: 'BMW', model: 5, info: {
    cool: 'Yes', maxspeed: 320, first100: 5.5} }

На место переменной, подставляется ее значение - строка
let name = 'mark'
console.log(boomer[name]) = console.log(boomer['mark']) //'BMW'

Добавить новое свойство можно используя точечную запись или квадратные скобки
boomer.model = 5
boomer.info.maxspeed = 310
boomer['year'] = 2022
boomer.info['color'] = 'white'
Удалить свойство обьекта можно с помощью ключевого слова delete и используя точечную запись или квадратные скобки
delete boomer.model
delete boomer.info.maxspeed

Метод - Свойство Обьекта, значением которого является Функция
Метод - функция, которая является значением 1 из Свойств обьекта
() - вызов Метода
. - точечная запись
С ее помощью можно получать доступ к Свойствам Обьекта

Метод в обьекте описысвается с помощью названия, затем двоеточия, потом ключевого слова function и тела функции
const person = {
name: 'Mark'
age: 30
gender: 'Male'
sayHi: function() {console.log('Hi')} }
person.sayHi() //'Hi'

const a = {name: 'Kyiv', age: 330, capital: true,
           show: function() {console.log(this.name)}}
const b = {name: 'Dnipro', age: 330, capital: true,
           show() {console.log(this.name)}}
a.show() //'Kyiv'
b.show() //'Dnipro'

Добавление нового метода в обьекта аналогично добавлению нового свойства
person.sayHello = function() {console.log('Hello')}
person.sayHello() //'Hello'
person.sayWow = () => {console.log('Wow')}

Выражение всегда возвращает значение
Выражение с побочными действиями - не только возвращает значение, но и выполняет какие-то действия (side effects)
a=5
b++
myFunction(c, d) - внутри функции выполняются дрегие, различные действия, кроме возврата значения (обращение к серверу, чтение из файла)

Переменные - дают возможность повторного доступа к значениям
Значения записанные без переменных нигде не сохраняются и к ним невозможно обратиться позже

Имена Типов, Классов - PascalCase
Имена переменных, значения которых известны до запуска приложения и не меняются (констант) - DB_PASSWORD
Все остальные имена - camelCase

Обьявление переменных
let - значения переменных можно изменять
const - константа, ее значение нельзя изменять
var - не нужно использовать
Const - Обьявление переменной и присваивание значения должно быть в 1 выражении

let b
Тут b - undefined
b = false

Обьявление и присваивание значения переменной const должно быть в 1 выражении
const b
Тут b - indefined, и так как эта переменная обьявлена с помощью const, изменить ее значение уже нельзя
b = false

console.log(a) > Error a is not defined - доступ к значению переменной, которой не существует, она не обьявлена
let a
console.log(a) > undefined - значение не определено, отсутствует

Метод log() - всегда возвращает undefined
console.log(10)
10 - действие выполненное внутри функции log
undefined - результат вызова функции

Почему
console.log(console.log(console.log(10))) > 1 раз 10 и 3 раза undefined

Тип переменной определяется типом присвоенного значения
const a = 10 (10 - Number, so a has a Number type)

Типы: примитивные, ссылочный
Примитивные типы: string, symbol (уникальные значения), number, boolean, null (значение отсутствует), undefined (значение не определено/его нет)
let a (a - undefined типа)
let b = null (b не имеет значения)
null - задаем мы сами, что бы явно указать, что сейчас у переменной нет значения, но оно будет/может быть в будущем
undefined - не нужно присваивать, он присваивается сам, если переменная обьявлена, но не инициализирована никаким значением (тип отсутствует)
Для сброса значения переменной можно использовать null, но не undefined
Symbol используется для создания уникального значения идентификатора для имен свойств в обьектах (что б они не совпадали и затем перезаписывались)
Позволяет добавлять уникальное свойство к обьекту, с увереностью, что он не перезапишет нкиакое другое свойство
Имена свойств обьекта созданные с помощью Symbol не учавствуют в переборе в цикле for in
Ссылочный тип - Object

Тип данных BigInt - это обьект, который позволяет работать с очень большими числами, больше Number.MAX_SAFE_INTEGER
Для записи значение типа BigInt, вкноце нужно добавить букву n
const bigNumber = 9999999999999999999999n
Переменная типа BigInt может взаимодействовать только с переменными такого же типа, и не может работать с типом Number

Примитивные типы содержат значение
Ссылочный тип содержит ссылку на область памяти, где находится сам обьект
Обьекты могут быть обьявлены с помощью const, но значения их свойств можно изменять
Обьект определяется с помощью фигурных скобок {}

const objectA = {a: 10, b: true}
Переменная objectA создана в 1 месте памяти, а обьект записан в другом
Переменная objectA хранит ссылку на область памяти, где сохранен обьект
objectA ссылается на обьект в памяти

const objectB = objectA
Переменная objectB инициализиуется ссылкой на обьект в памяти, в памяти остается 1 обьект, а ссылка на него копируется и их - 2

objectB.c = 'Hi' - создание нового свойста c у обьекта, ссылку на который содержат переменные objectA и objectB

2 варианта добавления/удаления нового свойства обьекта
1.) a.c = 2
2.) Скобочная запись - a ['c'] = 2

Если уже существует переменная со значением, которое нужно как имя свойства
const d = 'country'
a [d] = 'USA'
Создасться свойство country со значнием 'USA' (country = 'USA')
a.country = 'USA'

Лучше использовать точечную запись
Скобочную запись лучше использовать, когда в скобках выражение, например название переменной

Вложенные свойства
const city = {name: 'Dnipro', info: {population: 1000000, rank:9, placement: 'center'}}
console.log(city.info.rank) / console.log(city.info['rank'])
delete city.info.rank / delete city.info['rank']

Сокращенный формат записи свойств обьектов, если имена переменных и свойств совпадают
const age = 110
const date = 1900

const city = {name: 'Dnipro', info: {age, date}} vs const city = {name: 'Dnipro', info: {age: age, foundationdate: date}}

Глобальные обьекты
window - в браузере
global - в Node.js
Унифицированное название - globalThis (одно для браузера и  Node.js)
window.console.log() / global.console.log() = globalThis.console.log()
Можно вызывать свойства Глобального обьекта и без упоминания его имени
window.console.log() / global.console.log() = console.log()

Методы
2 способа записи метода, как свойства обьекта
1. const city = {name: 'Dnipro', print: function() { console.log('Dnipro') }}
2. const city = {name: 'Kyiv', print() { console.log('Kyiv') }}

JSON (Javascript Object Notation) - текстовый формат передачи данных между ПК в интернете
JSON.parse() - метод для конвертации (распаршивания) JSON в Javascript обьект
JSON.stringify() - метод для конвертации Javascript обьекта в JSON (строку)

Значения примитивных типов сохраняются в переменных, их копирование происходит по значению
Мутация - изменение свойств обьекта без создания новой переменной и переприсваивания значений (изменение исходной структуры данных)
3 варианта избежать мутации:
const ob1 = {name:'Dnipro', info {date: 1900, large: true}}
1.) const ob2 = Object.assign({}, ob1)
2.) const ob2 = {...ob1}
3.) const ob2 = JSON.parse(JSON.stringify(ob1))
1-ый и 2-ой варианты - не создают новые вложенные обьекты, а копируют ссылку на них, поэтому возможность мутации вложенных обьектов остается
3-ий вариант - создает новый обьект и все вложенные обьекты тоже создаются заново, а ссылки на них присваиваются новой переменной

Object - свойство глобального обьекта window/global/globalThis
Object - тип и класс
Object - прототип всех обьектов

Функция - блок кода, который можно выполнять многократно, в разных частях программы
Фукнция позволяет описать нужное действие 1 раз, а затем вызывать его, где оно понадобится
Функция обьявляется с помощью ключевого слова function, имени, круглых скобок (в которых опционально могут быть указаны параметры) и фигурных скобок (блок кода выполняемый при вызове функции, то что будет делать функция)
function sayHi() { console.log('Hello all') }
console.dir(obj) - отобразить свойства обьекта obj
Что бы кроме выполнения определенных действий, функция возвращала результат, используется ключевое слово return
После инструкции с ключевым словом return, функция прекращает выполнение дальнейших инструкций
Функция возвращает undefined, если она ничего не возвращает, тоесть нет инструкции return
После того, как функция достигла ключевого слова return - она завершает свою работу, и код после него никогда небудет выполнен
Обьявление функции создает переменную, значение которой является функцией
Параметры в теле функции ведут себя как локальные переменные
Внутри функции не рекомендуется мутировать внешние обьекты (переменные)
Для этого внутри функции можно создать копию обьекта-параметра и мутировать его, а результат функции присвоить новой переменной
Функция должны быть чистой (pure function) - работает с переменными, которые обьявлены в самой функции (копиями аргументов) и не меняет внешние переменные
1 функция должна выполнять 1 задачу

Javascript считывает код 2 раза
В 1-ый раз он запоминает какие переменные обьявлены, но не присваивает в них значения (формирует список переменных), а также видит функции обьявленные через Function declaration и их он считывает полностью
Во второй раз - запускает код на выполнение (сверху вниз) и записывает указанные значения в переменные
Благодаря этому, функции обьявленные с помощью function declaration можно вызывать перед их описанием в коде
sayHi() //'Hi'
function sayHi(){ console.log('Hi') }
С Function expression так делать нельзя, и в коде фукнция может быть вызвана только после своего обьявления

Обьявить/описать/создать функцию можно 2 способами:
1. Function declaration (стандартное обьявление фукнции function check() {...})
2. Function expression (анонимное функциональное выражение, стрелочная функция)
Обьявление функции - функция имеет имя (myFn1), круглые скобки, в которых, если нужно, указываются параметры (), и значение/тело (в {})
function myFn1() {console.log('Hi')}
Функциональное выражение - описывает функцию, а затем присваивается переменной
Функциональные выражения всегда анонимные, имя у них отсутствует
function() {console.log('Hi')}
Функцию и функциональное выражение можно присваивать переменной (myFn2)
const myFn2 = function() {console.log('Hi')}
И таким образом у функционального выражения "появится имя", с помощью которого ее можно будет вызывать
Но переменная перестанет быть переменной, а станет функцией и для ее вызова потребуется оператор вызова функции - ()
myFn2()
Анонимное функциональное выражение чаще всего используют как Callback функцию, его сразу описывают на месте параметра функции
setTimeout(function () {console.log('Hi')}, 1000)
function () {console.log('Hi')} - анонимное функциональное выражение
setTimeout - функция, которая в качестве параметров принимает функцию и, опционально, число (время в милисекундах через которое будет выполнен 1-ый параметр/вызвана переданная функция)

Стрелочная функция обьявляется без ключевого слова function и не имеет имени, поэтому она также всегда анонимна
Для обьявления стрелочной функции используются символы => между оператором вызова функции () и телом функции
(a, b) => { return a+b }
Стрелочную функцию также можно использовать как Callback функцию
setTimeout( ()=>{console.log('Hi')}, 3000)
Сокращения в стрелочных функциях
1.) Если стрелочная функция имеет 1 параметр, то круглые скобки можно опустить
a => { a++; return a}
2.) Если тело функции состоит из 1 выражения, фигурные скобки можно опустить
(a, b) => a+b
В этом случает стрелочная функция неявно возвращает результат выражения, записанный в теле (return a+b)
Стрелочная функция не имеет контекста и ссылается на контекст области видимости, в которой она была обьявлена (не имеет своего this)

Callback функция - это функция которая будет вызвана когда-нибудь потом
Callback функция - вызывается внутри другой функции
const cooking = function (i) {
    console.log ('Cooking'), setTimeout(i, 3000)
}

const eating = function() { console.log('Eating') }

const a = function () { console.log('Reading')}

const reading = function (i) { setTimeout(i, 100) }

cooking(eating); reading(a)

Функции можно использовать в качестве аргументов, при вызове других фукнций
Это и назыавается Callback функцией
function sum(a, b) { return a+b }
const result = sum(sum(1,2), sum(3,3)) //sum(1,2)=3 sum(3,3)=6 sum=3+6=9

function sum(a, b) { return a+b }
function powSomeNumber(somefunc, a1, b1) {
const result = somefunc(a1, b1)
return Math.pow(result, 2)
//Тоже самое в 1 строку - return Math.pow(somefunc(a1, b1), 2) }

Функция передаваемая в качестве аргумента - записывается без круглых скобок
const autoBrands = ['Mercedes', 'Audi', 'BMW', 'Porsche', 'Skoda']
function showBrands(brand, index) { console.log(`${brand} has index ${index}`) }
autoBrands.forEach(showBrands) - круглые скобки не используются

Самовызывающаяся (анонимная) функция (IIFE - immediately invoke function extression) - функция которая вызывает сама себя
Круглые скобки () в JS создают выражение
() внутри которых функция - превращают ее в выражение, вторые круглые скобки - запускают это выражение на выполнение
( function hello() { console.log('Hi') } ) ();
( function () { console.log('Hi') } ) (); - анонимная самовызывающаяся функция
(function (a, b) { console.log(a+b) }) (1, 2); //3
const res = (function (a, b) { return a+b }) (1, 2); //res=3
После самовызывающейся функции - точка с запятой являются обязательными

Области видимости - определяет границы действия переменной
1. Глобавльная область видимости
2. Локальная (внутри функций/методов)
Имена локальных переменных могут соответствовать глобальным

ГОВ
const a, b, c

ЛОВ 1
const a, b
Тут есть доступ к глобальной переменной c и нет доступа к переменной c из ЛОВ 2

ЛОВ 2
const c
Тут есть доступ к глобальным переменным a, b и нет доступа к переменным a, b из ЛОВ 1

let a
let b

function change ()
{
a = true
let b = 3
}

change ()
console.log(a) //true
console.log(b) //undefined

Каждый раз при вызове функции создается новая локальная область видимости этой функции
После завершения работы функции, все переменные локальной области видимости этой функции - удаляются/уничтожаются
Переменная в локальной области видимости всегда имеет приоритет перед переменными в глобальной области видимости
Если присваивать значение переменной, не обьявленной ранее, то такая переменная будет автоматически создана в глобальной области видимости
function check()
{ a = 3; console.log(a) }
a - не обьявлена в функции и нигде ранее (нет слов let, const), поэтому будет обьявлена автоматически, в ГОВ
check()
console.log(a) //3 - переменная а доступна за пределами области видимости функции в ГОВ, так как она была там обьявлена автоматически
Типы областей видимости:
1.) Глобальная область видимости
2.) Область видимости функции
3.) Область видимости блока (блок - любой код в фигурных скобках)

/*
let global = 3
undefined
{
    let global2 = 5
    var global3 = 9
    function check(a) {
        console.log(a)
      }
}
check(global) //3
check(global2) //Error: global2 is not defined
check(global3) //9

Функция или блок кода имеет доступ к области видимости, где он обьявлен (если функция/блок кода обьявлены в ГОВ - то они имеют доступ ко всем переменным, функциям ГОВ)
Строгий режим - инструкция компилятору JS более пристально анализировать то, что вы делаете с переменными
Строгий режим запрещает использование не обьявленных переменных
'use strict' активирует Строгий режим
'use strict' строка должна быть первой в ГОВ либо в области видимости функции

Операторы - встроенная функция
При использовании оператора запускается соответсвующая функция
Операторы: арифметические, сравнения, логические, оператор присваивания, запятая, () - вызов функции
Текстовые операторы: new, delete, typeof, instanceof
У унарных операторов 1 операнд/аргумент, у бинарных - 2
=== - строгое сравнение (сравнивает тип и значение операндов, значения приводятся к 1 типу, а затем сравниваются)
== - нестрогое сравнение (сравниваются только значения, приведение и сравнение типов - не происходит)
Вырадение присваивания всегда возвращает true
const number = 3 //true
const a = 3
const b = '3'
a === b //false
a == b //true
Инфиксная запись - оператор между 2 операндами (a+b)
Префиксная запись - оператор стоит перед операндом (+a)
Постфиксная запись - оператор идет после операнда (а++б, myFunction())
! - оператор не, возвращает значение типа boolean (true или false)
&&, || - логичесикие операторы И, ИЛИ, возвращают значение 1 из операндов
&& - возвращает значение первого найденного false, если все операнды правдивы - значение последнего найденного true
'Cat' && 0 && true //0
true && 9 && 'Cat' //'Cat'
|| - возвращает значение первого найденного true, если же все операнды ложны - значение последнего false
9 || '' || 'Cat' //9
0 || false || null || true //true
undefined  || false || '' || null || 0 //0
?? - оператор нулевого слияния
Работает, как логическое ИЛИ ( || ), возвращает значение первого найденного true, если же все операнды ложны - значение последнего false
Но, обрабатывает значения 0 и false как правдивые, а null и undefined - ложные
undefined ?? false ?? '' ?? null ?? 0 //false
false ?? undefined //undefined
Иерархия операторов: 1.) ?? 2.) || 3.) &&
So firstly calculated && then || ???
0 || 9 && null || true && undefined //undefined
9 && null //null
true && undefined //undefined
0 || null || undefined //undefined
------------------------------------------------------------
true || 'str' && undefined || 9 && null || false && 0 //true
true || undefined || null || 0 //true
true || 'str' && undefined || 9 && null || false //true
true || undefined || null || false //true

Ложные значения - значения которые после приведения к логическому типу получают значение false: 0, '', undefined, null
Boolean (undefined) //false
const a = 3 - истинное значение, !a - ложное значение
if (!a) {console.log('true')}
else {console.log('false')}
//false
a - true Boolean(a) //true
!a - false Boolean(!a) //false
if (condition===true) { ... }
else { ... } (condition===false)

!! - отрицание отрицания
!!undefined //false
!!10 //true

Оператор и (&&) и оператор или (||) - операторы короткого замыкания (short circuit) и они всегда возвращают значение одного из операндов
&& - если первый операнд возвращает false, второй уже игнорируется (так как оба должны вернуть true)
Оператор И ищет первое ложное выражение и возвращает его значение
|| - если первый операнд возвращает true, второй уже не оценивается (так как только 1 из операндов может быть истынным/true
Оператор ИЛИ ищет первое истинное выражение и возвращает его результат
5 && 0 //0
5 || 0 //5
С помощью оператора и (&&) можно вызывать те или иные функции в зависимости от значения переменных
a = 3
a && console.log ('a=3')
И заменить конструкцию if
if (a===3)
console.log ('a=3')

... - оператор разделения на свойства
const Dnipro = {age: 330, place:'Top', rank: 3}
const Kyiv = { ... Dnipro}
Тут же можно добавлять новые свойства и перезаписывать уже имеющиеся
const Kyiv = { ... Dnipro, place: 'Center', rank: 1}
//Kyiv age = 330, place = 'Center', rank = 1
Если свойство записано перед оператором разделения на свойства, и такое же свойство есть у разделяемого обьекта, его значение - будет перезаписано
const Lviv = {age: 599, ... Dnipro}
//Lviv age = 330, place = 'Top', rank = 3
const Lviv = {... Dnipro, age = 599}
//Lviv age = 599, place = 'Top', rank = 3
Добавление нового свойства можно указывать до или после оператора разделения обьекта на свойства
const Lviv = { ... Dnipro, border: 'Poland'}
//Lviv age = 330, place = 'Top', rank = 3, border = 'Poland'
const Lviv = {border: 'Poland', ... Dnipro}
//Lviv border = 'Poland', age = 330, place = 'Top', rank = 3

Создание нового обьекта на основе нескольких
Если свойства с одинаковыми именами есть у нескольких обьектов, порядок их разделения влияет на порядок перезаписи их значений
const buttonInfo = {text: 'Buy'}
const buttonStyle = {color: 'green', width: 200, height: 100}
const button = {...buttonInfo, ...buttonStyle}
//button text = 'Buy', color = 'green', width = 200, height = 100
После изменения свойств нового обьекта, мутация обьектов из которых он был создан - не происходит, НО это не касается вложенных обьектов

Конкатенацию строк можно выполнить с помощью оператора +
const a = 'Hello'; const b = 'World'
console.log('Hello' + ' ' + 'World')
console.log(a + ' ' + b)
console.log(a + '\n' + b)

Также с помощью функции Шаблонные строки
Интерполяция - способ соединения строк через вставку значений переменных в строку-шаблон с помощью символа доллара и фигурных скобок. Например, `Hi, ${name}!`
console.log(`${a} ${b}`)
console.log(`${a}\n${b}`)

const name = Kirill, const city = Kyiv
console.log(`Hello. My name is ${name} and I live in ${city}`)
const res = `${name} ${city}`
Неявное приведение типов
undefined + 'abc' //undefinedabc
Тип undefined был неявно приведен к типу строка
10 + 'abc' //10abc
Тип nubmer был неявно приведен к типу строка

Значение параметров функции по умолчанию
function check(a, b=3) { return a*b }
Если функция check будет вызвана с 1 аргументом, то второму будет присвоено значение по умолчанию, установленое во время ее обьявления - 3
check (3, 3) //9
check (1) //3
В качестве значения по умолчанию для параметра, можно задавать выражения, тоесть и функции
function check(a, b = Date())
{ return a+' '+b}
Значения по умолчанию вычисляются в момент вызова функции
Если имя параметра совпадает с именем нужного свойства, запись можно сократить
fucntion check (obj, name) {...obj, name: name}
fucntion check (obj, name) {...obj, name}
В стрелочной функции можно осуществить неявный возврат обьекта из функции путем взятия тела функции в круглые скобки
const newPost = (post, time=Date()) => ( {...post, date:time} )
const somePost = {id: 1, author: 'Kirill', text: 'Hi'}
newPost(somePost) //id=1, author=Kirill, text=Hi, date='Mon Jun 20 2022 16:27:19 GMT+0300 (Восточная Европа, летнее время)'
Во всех функциях, явное возвращение обьекта, осуществляется путем его обьявления внутри функции и возврата, с помощью инструкции return
const newPost = (post, time=Date()) => { newobj={...post, date:time}; return newobj }

После появления ошибки - код дальне не выполняется
В блок try нужно помещать вызов кода/функции, в котором можент возникнуть ошибка, а не его обьявление
Ошибка возникающая в блоке try присваивается как значение параметру/переменной error в блоке catch
В результате использования try, catch блоков ошибку можно поймать и обработать
Если ошибка поймана, она уже не Uncaught error (непойманная), а просто error
Если поймать ошибку, выполнение кода, после ее возникновения, продолжится
function error() { throw new Error ('Message about error') }
try { error() }
catch (Error) { console.log(Error.message)/console.error(Error.message) }
console.log('Hi')
//Message about error
//Hi
Код в блоке finally будет выполнен в любом случае, была ли выброшена ошибка или нет

Инструкции:
1.) выражения (a=3)
2.) инструкции (let a, const b = 3, if/else, for)
3.) выражения-инструкции
Выражение(и функция) всегда возвращает значение
Инструкция выполняет действия
Инструкции следует завершать точкой с запятой (кроме блока кода/инструкции в условных конструкциях if/else и цыклах) и разделять пустыми строками до и после
Точку с запятой можно опускать
Инструкция не может быть трасформирована в выражение
Выражения могут использоватся как аргументы при вызове функции, а инструкции - нет

Массив - это обьект с цифровыми именами свойств
Массив - это структура данных
Массив в JS может содержать элементы разных типов (number, String, boolean, undefined)
Длину массива можно изменять после его создания/обьявления
Если имена свойств у обьекта цифровые (0, 1, 2...) то для доступа к ним использовать точечную запись - нельзя, нужно использовать квадратные скобки
const myObj = {0: 'Hi', 10: undefined, 3: true, 9: 9}
myObj[9] //9, а также myobj['9'] //9
Длину массива, свойство length, Javascript инициализирует и обновляет автоматически

Методы массивов:
1.) push - добавляет элемент в конец массива (myArray.push(9) //[1, 2, 3, 9])
2.) pop - удаляет последний элемент массива и возвращает его (myArray.pop() //[1, 2], const removedElement = myArray.pop() //2 //[1])
3.) unshift - добавляет элемент в начало массива (myArray.unshift(true) //[true, 1, 2, 3])
4.) shift - удаляет первый элемент массива и возвращает его (myArray.shift() //[2, 3], const removedElement = myArray.shift() //2 //[3])
5.) forEach - содержит коллбэк функцию с 1 параметром, в качестве параметра метода, и перебирает каждый элемент массива, значение которого присваивается параметру коллбэк функции
Метод forEach не мутирует оригинальный массив, он производит действия с параметром коллбэк функции, значение которого равно определенному элементу массива
Также, метод forEach ничего не возвращает, так как его задача только перебрать все элементы и выполнить с ними коллбэк функцию. В нем нет return инструкции
6.) map - содержит колбэк функцию с 1 параметром, как параметр метода, и перебирает каждый элемент массива, значение которого присваивается параметру коллбэк функции
В результате возвращает новый массив, который содержит результат выполнения коллбэк функции
7.) reduce
8.) filter
9.) reduce - содержит коллбэк функцию в качестве параметра, которая, в свою очередь, может принимать 2 обязательных параметра и еще 3 необязательных
Обязательными являются:
accumulator - аккумулирует значение возвращаемое коллбэк функцией в конце каждой итерации
element - текущий обрабатываемый элемент массива
Необязательные:
index - индекс текущего обрабатываемого елемента массива
array - обрабатываемый массив, для которого была вызвана функция reduce
startValue - начальное значение accumulator
Если startValue указан, accumulator = startValue, а element = первому элементу массива
Если startValue - нет, accumulator = первому элементу массива, а element = второму
Если в методе reduce используется if без else, то его блок кода должен быть записан без фигурных кавычек {}
Это функции высшего порядка (функции/метода прототипов (в данном случае - Array))
10.) splice - начиная с указанного индекса, удаляет указанное количество элементов массива, заменяет их на указанные значения и возвращает удаленные элементы
array.splice(start, delete count, new elements)
const a = ['Hi', false, 3, true, 9, 'Peace', 'Wow']
a.splice(0, 2, '1st', '2nd') //['Hi', false]
console.log(a) //['1st', '2nd', 3, true, 9, 'Peace', 'Wow']

forEach - не имеет оператора return и соответственно ничего не возвращает, а только производит действия с каждым элементом массива (или теми, кто подходит условию if)
reduce - возвращает accumulator, который взаимодействует со всеми элементами массива (или теми, кто подходит условию if)
map - возвращает новый массив такой же длинны, как и тот с которым вызывался метод.
Содержит значения элементов исходного массива, которые подходят условию, а все остальные - undefined
filter - возвращает новый массив, который содержит только те элементы, которые подходят условию
Здесь указывать else не нужно, так как это приведет к выводу всех элементов в результирующий список, а не только тех, что прошли проверку
Можем вернуть только сами элементы, которые прошли проверку, но не их index

У прототипа (класса) Array описаны эти методы
Каждый созданный массив является экземплятор класса Array и имеет доступ ко всем его методам
Все методы, кроме forEach и map, мутируют/изменяют оригинальный массив/обьект
Пример forEach метода
const array = [1, 2, 3]
array.forEach(el => el)
array.forEach(el => return el) //SyntaxError: Unexpected token 'return'
array.forEach(el => console.log(el)) //1, 2, 3
Пример map метода
const newArray = array.map(el => el*3) //[3, 6, 9] массив который возвращает метод map присваивается в новую переменную
В качестве коллбэк функции методов forEach и map можно использовать анонимное функциональное выражение
array.forEach(function(el) {console.log(el)}) //1, 2, 3
const newArray = array.map(function(el) { return el*3 }) //[3, 6, 9]

Деструктуризация - функция создания новых переменных и присваивания им значений, соответствующих свойств обьекта
Деструктуризация свойств обьекта
Названия новых переменных должны совпадать с именами нужных свойств обьекта
const city = {name:'Kyiv', age:330, capital:true}
const {name, capital} = city
console.log (name) //Kyiv console.log(capital) //true
const {age} = city
console.log(age) //330
Деструктуризация массов
const array = ['Hi', true, 3]
const [elem1, elem2, elem3] = array
console.log(elem1, elem2) //'Hi', true
console.log(elem3) //3
const [thirdelem] = array
console.log(thirdelem) //'Hi'
const [el1, el2, el3, el4] = array
console.log(el1, el2, el3) //'Hi', true, 3
console.log(el4) //undefined
Деструктуризация обьекта в параметрах функции
Можно использовать в стрелочной функции и присвоить ее результат переменной
const Kyiv = {name:'Kyiv', age: 350, capital:true}
const Dnipro = {name:'Dnipro', age:330, capital:false}
let countrycenter
const check = ({capital, name}) => {
if(capital==true) {countrycenter=name} }
check(Dnipro); console.log(countrycenter) //undefined
check(Kyiv); console.log(countrycenter) //'Kyiv'
const check2 = ({name, capital}) => {
if(capital==true) {return `${name} is the capital of Ukraine`}
else {return `${name} is not a capital of Ukraine`}}
Также можно использовать анонимное функциональное выражение и присвоить его результат переменной
И в обычной функции

Условные инструкции:
1.) if
2.) if else
3.) if else if
4.) switch
5.) тернарный оператор (это выражение и, как и все выражения, он возвращает результат
if (Условие) {//Блок кода, который будет выполнен однократно, если Условие правдиво и не будет выполнен ни разу, если Условие ложно}
Задача инструкции if привести условие к булевому значению
const person = {age:29}
if (!person.name) {console.log('Имя не указано')}
const person = {age:29, name:'Geoff'}
if (person.name) {console.log(`Hello ${person.name}`)}
else {console.log('Имя не указано')}
if (Условие) {//Блок кода, который будет выполнен однократно, если Условие правдиво, и не выполниться ни разу, если Условие ложно}
else {//Блок кода, который будет выполнен однократно, если Условие ложно}
if (Условие1) {//Блок кода, который будет выполнен однократно, если Условие правдиво и не выполниться ни разу, если Условие1 ложно
Если Условие1 - правдиво, else if и else - пропускаются}
else if (Условие2) {//Блок кода, который будет выполнен однократно, если Условие - ложно и Условие2 - правдиво
Если Условие2 - правдиво, if и else - игнорируются}
else {//Блок кода, который будет выполнен однократно, если Условие1 - ложно и Условие2 - ложно}

if else if можно заменить на несколько инструкций if
const age = 29
if (age>=18) {console.log('Is adult')}
else if (age>=12) {console.log('Is teenager')}
else {console.log('Is child')}
//'Is adult'

if (age>=18) {console.log('Is adult')}
if (age>=12 && age<18) {console.log('Is teenager')}
if (age<12) {console.log('Is child')}
//'Is adult'
Используя несколько инсрукций if, в каждой последующей нужно учитывать Условие в предыдущем if, что б не получить результат выполнения сразу нескольких if
Потому что, если Условие первого if - правдиво, программа переходит в следующий if и получает результат его Условия
Если Условие второго if - тоже правливо, в будет выведен результат выполнения сразу 2 if (Условия которых правдивы)
Если же Условие последнего if - ложно, будет выведен результат всех предыдущих if (если их Условия - правдивы), а так же результат else
if (age>=18) {console.log('Is adult')}
if (age>=12) {console.log('Is teenager')}
if (age<12) {console.log('Is child')}
//'Is adult'
//'Is teenager'
Так же при использовании сразу нескольких if, лучше не использовать else, так как тоже можно получить сразу 2 результата: if и else
const age = 17
if (age>=12) {console.log('Is teenager')}
if (age>=18) {console.log('Is adult')}
else {console.log('Is child')}
//'Is teenager'
//'Is child' - значение else
Если условие в if ложно, проверяется условие else if, а затем выводится результат в else
const a = 3
if (a<0) {console.log(1)}
else if (a==3) {console.log(3)}
if (a<0){console.log(5)}
else {console.log(9)} //3, 9

Инструкция switch является альтернативой инструкции if, else if, когда есть много вариантов Условий
После каждого case должна присутствовать инсрукция break, что бы в случае выполнения кейс, выйти из switch и не проверять остальные case
Ключевое слово default будет выполнено в случае невыполнения ни одного case и схоже с ключевым словом else
const a=3
switch(a) {
case 1: console.log('a is 1')
break
case 2: console.log('a is 2')
break
case 3: console.log('a is 3')
default: console.log('a is not 1, 2 or 3')}
После слова case должно стоять значение 
В качестве значения для case, можно использовать выражение, которое возвращает результат того же типа, что и переменная в switch, что бы case сработал
Можно использовать также выражение, результат которого имеет тип не соответствующий типу переменной в switch, но в таком случае case не выполнится
const a=3
switch (a) {
case (a>0): console.log('a is positive') //a>0 = true, true !=3
break
case 3: console.log('a is three')
break } //'a is three'

Тернарный оператор - это выражение и он всегда возвращает результат, который, например, можно присвоить переменной
Тернарный оператор - это короткая форма записи условия (if)
Тернарный оператор имеет 3 операнда
Условие ? Выражение 1 : Выражение 2
Если Условие правдиво, будет выполнено Выражени 1 и возвращен его результат, если Условие ложно - результат выполнения Выражения 2
Затем будет возвращен результат Тернарного оператора (выражения), Выражени 1 или Выражение 2, в зависимости от Условия
В блоках кода инструкции if else и подобных, можно использовать инструкции и выражения, в тернарном операторе в качестве операндов 2 и 3 - только выражения
Вызов функции - это выражение (функция это выражение, которое возвращает значение, вызов функции - возвращает это значение)
const value1=3; const value2=9
value1 && value2 ? myFunction1(value1, value2) : myFunction2()
const res = value1>0 ? value1*3 : value2
Переменную, которой присваивается значение, можно обьявлять в тернарном операторе (const res)
Условие value1>0 = true, обработается Выражение 1 (value1*3) и будет возвращен его результат
Потом этот результат будет присвоен результату Выражения с Тернарным оператором, а затем результат Выражения с Тернарным оператором будет присвоен переменной res

Типы цыклов:
1.) for
2.) for in
3.) while
4.) do while
5.) for of

for - зарезервированное слово
for (начальная инструкция, условие, итерационное действие)
{ //Блок кода выполняемый на каждой итерации }
for (let i=0; i<5; i++) { //Блок кода/инструкций выполняемый определенное количество раз (пока условие = true) }
Сначала мы обьявляем переменную (let i)
Затем присваиваем ей начальное значение (i=0)
Далее проверяется, удовлетворяет ли значение этой переменной условие (0<5)
Потом выполняется блок кода/инструкций
Затем управление передается итерационному действию, в котором изменяется значение обьявленной переменной (i++)
Далее новое значение этой переменной сравнивается с условием (1<5)
И если оно подходит (true) - опять выполняется блок кода цикла
Если же значение переменной не удовлетворяет условие (false) - осуществляется выход из цикла и его блок кода не выполняется (5<5)
const array = ['Hi', true, 3]
for (let i=0; i<array.length; i++)
{ console.log(array[i]) }
Цикл for не рекомендуется использовать для работы с массивами, для этого лучше использовать функции высшего порядка массивов: forEach, map, reduce
Используя функцию/метод forEach можно получить доступ непосредственно к элементам массива, а так же к их индексам
array.forEach( element => console.log(element) ) //'Hi', true, 3
array.forEach( (element, index) => {console.log(element, index+1} ) //'Hi' 1, true 2, 3 3
array.forEach( function(el, ind) { console.log(el, ind+1) } ) //'Hi' 1, true 2, 3 3
forEach в качестве параметра содержит коллбэк функцию, которая будет вызвана столько раз, сколько элементов в массиве
1-ый параметр этой функции (element), будет представлять каждый элемент массива
2-ой (index) будет индексом каждого соответствующего элемента массива. Этот параметр в коллбэк функции - опционален

while (Условие) {//Набор инструкций цикла выполняемый на каждой итерации }
while - выполняет блок кода, пока условие правдиво
Если условие - ложно, блок кода не выполнится ни разу, программа даже не зайдет в цикл
Что бы цикл не работал бесконечно, при правдивом условии, условие нужно изменять в блоке самого цикла
let i=3
while (i<5) { console.log(i) } - бесконечный цикл, так как условие (3 < 5) будет правдиво всегда //3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 ...
while (i<5) { console.log(i); i++ } //3 4
Когда переменная i будет равно 5, выполнится проверка условия, оно будет ложным и в цикл программа не зайдет

do {//Блок кода выполняемый на каждой итерации}
while (Условие)
do while выполняет блок кода, пока условие правдиво, но это условие проверяется после 1-го выполнения блока кода в цикле
Тоесть, в цикле do while, блок кода в цикле будет выполнен минимум 1 раз, даже если условие ложно изначально
let i=10
do { console.log(i); i++}
while (i<4) //10
Блок кода выполнился 1 раз, затем переменная i была увеличена на еденицу, и только потом была выполнена проверка условия
Условие оказалось ложным (11<4) и программа вышла из цикла

for in используется для перебора всех свойств обьектов (и массивов, так как массив - это обьект) и получения доступа к именам свойств
Доступ к их значениям можно получить используя скобочную запись
const obj = {name: 'Dnipro', age: 330, capital: false}
for (const i in obj)
{ console.log(i, obj[i]) } //name 'Dnipro', age 330, capital false
i - отвечает за имена свойств обьекта/массива
obj[i] - значение свойств
const array = ['Hi', true, 3]
for (const i in  array)
{ console.log(i, array[i]) } //0 'Hi', 1 true, 2 3
for of нельзя использовать для Обьектов, так как они являются неитерируемыми
for in отличается от for of тем, что может обходить неитерируемые обьекты и возвращает ключи

Методы keys и values возвращают массив имен и значений свойств обьекта, соответственно
Object.keys({//Передаем пустой обьект, а не переменную с обьектом}) //[]
Object.values({}) //[]
Object.keys(obj) //[name, age, capital] - массив имен свойств обьекта
Object.values(obj) //['Dnipro', 330, false] - массив значений свойств обьекта
В паре с этими методами можно использовать цикл/метод forEach
Object.keys(obj).forEach(i => console.log(i)) //name, age, capital
Object.values(obj).forEach(i => console.log(i)) //'Hi', true, 3

for (const element of Iterable) { //Блок инструкций цикла, где можно выполнять действия с определенным элементом, значение которого в переменной element }
Iterable - переменная или значение, элементы которого можно перебирать, по которому можно итерироватся
Например: символы в строке, элементы массива
element в таком случае будет представлять определенный символ строки или элемент массива
const myString = 'Hello'
for (const el of myString) { console.log(el) } //'H', 'e', 'l', 'l', 'o'
const array = ['Hi', true, 3]
for (const el of array) { console.log(el) } //'Hi', true, 3

Цикл for of нельзя использовать для обьектов, так как они в Javascript - не итерируемые
Последовательность свойств обьекта в Javascript - не важен, и цикл for of не знает, в какой последовательности их перебирать
Для работы с массивами рекомендуется использовать их встроенные циклы: forEach, map, index of
Для работы с обьектами лучше использовать цикл for in, или же конвертировать обьект в массив с помощью методов Object.keys, Object.values, а затем использовать встроенные методы массивов

Модули позволяют структурировать код (разбивать весь код программы на отдельные модули, что бы улучшить ее читаемость)
Модули позволяют избегать дублирования блоков кода (код написамый в модуле может быть вызван в другом модуле, вместо его повторой записи)
Каждый файл Javascript в программе является отдельным модулем
Каждый модуль является отдельной зоной видимости, переменная обьявленная в рамках 1 модуля и не экспортируется, является локальной переменной и не доступна в других модулях
С помощью зарезервированных слов export и import модули можно экспортировать из одного файла и импортировать в другой

Экспорт по умолчанию
moduleOne.js
const myName = () => console.log('Kirill')
export default myName

moduleTwo.js
import printMyName from './moduleOne.js'
. - означает, что модули находятся в одной папке
printMyName() //'Kirill'

При использовании экспорта по умолчанию (export default), название переменной при импорте может отличатся от названия переменной при экспорте
В результате, в модуле moduleTwo.js будет создана пемеренная printMyName, которая будет содержать функцию идентичную функции myName, в модуле moduleOne.js
И функцию printMyName можно вызывать в модуле moduleTwo.js

Синтаксис можественного экспорта:
moduleOne.js
const a = 'Hi', const b = true, const c = 3
export { a, b, c }

moduleTwo.js
import { a, b, c } from './moduleOne.js'
console.log(a, b, c) //'Hi', true, 3

При экспорте не по умолчанию, экспортируемые и импортируемые переменные должны быть указаны в фигурных скобках (что указывает на экспорт не по умолчанию)
При множественном экспорте/импорте имена импортируемых переменных должны совпадать с именами экспортируемых
export {a, b, c} import {a, b, c}
Что бы изменить имя импортируемой переменной в модуле (например если переменная с таким именем уже обьявлена) используется ключевое слово as
import {a, b, c as three} from './moduleTwo.js'
console.log(a, b, three) //'Hi', true, 3

Import инструкции записываются на первых строках модулей, а export - на последних
Импорт из внешних установленных пакетов/модулей рекомендуется указывать перед импортом из втурненних модулей
Рекомендуется использовать export default

Возможен ли множественный экспорт по умолчанию ?
npm - NodeJS Package Manager (менеджер пакетов/модулей в NodeJS)
npm позволяет скачивать разные внешние пакеты в приложение
При импорте из внешнего модуля, установленого с помощью npm, путь к модулю указывается без точки и слеша (./)

NodeJS команды:
Переход по папкам осуществляется с помощью команды cd //название папки
Переход на 1 уровень выше - cd..
Создать папку - mkdir //название папки
Открыть папку можно используя команду code .
Выполнить модуль - node //название модуля (node moduleTwo.mjs)
Просмотреть список файлов в папке - ls
Создать новое реакт приожение - npx create-react-app my-app
Команда npx - запускает однократно определеные npm пакеты
Команда npx скачает npm пакет create-react-app и с его помощью создаст реакт приложение в папке my-app, которая будет создана автоматически

Классы позволяют создавать прототипы (шаблон, заготовка) для обьектов
На основании прототипов создаются экземпляры
Экземпляры наследуют свойства и методы прототипов
Экземпляры могут иметь собственные (указываются в функции constructor) и унаследованные свойства и методы
Понятие класс в Javascript - это синтаксическая надстройка над обьектами и функциями, экземпляры создаются при помощи вызова функции
Класс - это шаблон для создания экземпляров класса
class Comment {
constructor (text) {
this.text=text
this.votesQty=0}
upvote() { this.votesQty+=1 }

Метод constructor вызывается только при создании нового эклемпляра класса
Внутри него, конкретному экземпляру класса, добавляется свойство text и инициализируется значением аргумента constructor

Метод upvote не будет присвоен как отдельный метод экземпляра класса, но будет наследоваться им
Имеет значение для какого именно экземпляра класса вызывается метод upvote(), так как он изменяет свойство экземпляра, для которого вызывается
Метод описывается в классе без указания ключевого слова function

Ключевое слово this, в методе обьекта, ссылается на этот обьект
const person = {
    name: 'Mark',
    age: 30,
    gender: 'Male',
    sayHi:function(){console.log(this)} }
person.sayHi() //{name: 'Mark', age: 30, gender: 'Male', sayHi: ƒ} - выводит весь Обьект, в контексте которого используется ключевое слово this

const person = {
    name: 'Mark',
    age: 30,
    gender: 'Male',
    sayHi:function(){console.log(name)} }
person.sayHi() //Пустая строка и undefined как результат выполнения метода log

const person = {
    name: 'Mark',
    age: 30,
    gender: 'Male',
    sayHi:function(){console.log(person.name)} }
person.sayHi() //'Mark'
В результате вызова такого метода sayHi(), он выйдет из Обьекта person, затем снова в него зайдет и найдет Свойство name, которое выведет в консоль

const person = {
    name: 'Mark',
    age: 30,
    gender: 'Male',
    sayHi:function(){console.log(this.name)} }
person.sayHi() //'Mark'
В результате вызова этого метода sayHi(), он не будет выходить из Обьекта person, а будет искать Свойство name внутри него (в контексте), а затем выведет в консоль

Если ключевое слово this используется в функции, которая не является методом обьекта, или которая просто в нем описана - тогда this будет терять контекст и ссылаться наглобальный обьект Window

Переменная this - указывает на конкретный экземпляр класса (с которым вызываются методы)
При создании нового экземпляра класса, переменная this будет автоматически ссылатся на этот новый экземпляр
Ссылаясь на конкретный экземпляр класса, внутри свойств и методов класса, можно изменять собственные свойства и методы экземпляра
При вызове метода upvote, this переменная будет динамически указывать на экземпляр класса, для которого был вызван метод
upvote() { this.commentsQty+=1 }
firstComment.upvote() (this.commentsQty > firstComment.commentsQty)

Создать экземпляр класса можно при помощи оператора new
const firstComment = new Comment('Hi')
Создается новая переменная firstComment (название экземпляра класса)
Затем ей присваивается новый экземпляр класса (оператор =)
Синтаксис new Comment('Hi') - вызывает функцию constructor, класса Comment, которая создает новый экземпляр этого класса
В круглых скобках указывается аргумент для constructor
Функция constructor возвращает новый экземпляр/обьект класса
Comment класс будет прототипом для его экземпляра

Свойства экземпляра (собственные) указываются в функции constructor
Метода upvote у экземпляров класса Comment - нет, он ими наследуется
Метод upvote находится на уровне класса Comment и является унаследованным свойством экземпляров
Нет необходимости добавлять метод upvote каждому экземпляру класса
Но очень важно, с каким экземпляром этот метод вызывается, так как он меняет свойство этого экземпляра
При вызове метода upvote, this переменная будет динамически указывать на экземпляр класса, для которого был вызван метод
upvote() { this.commentsQty+=1 }
firstComment.upvote() (this.commentsQty > firstComment.commentsQty)

Наследование по цепочке (благодаря цепочка прототипов): собственные свойства, унаследованные (на уровне родительского класса), методы/свойства класса Object
Object - глобальный класс, который присутствует в Javascript по умолчанию и является родительским/корневым для всех обьектов/классов
Любой класс наследует все методы класса Object

Цепочка прототипов: firstComment - экземпляр класса Comment, который наследует все методы глобального обьекта Object
(forstComment > Comment > Object)
Если какой-то метод не найдет в экземпляре класса, поиск ведется в родительском прототипе, если его нет и там - то в прототипе на 1 уровень выше и так далее, до корневого класса Object
(myArray > Array > Object)

Проверить принадлежность экземпляра к тому или другому классу, можно при помощи оператора instanceof
firstComment instanceof Comment //true
firstComment instanceof Array //false (firstComment не наследует методы класса Array)
firstComment instanceof Comment //true (любой обьект наследует все методы родительского/корневого класса Object)

Проверить принадлежность, собственного свойства экземпляру класса, можно при помощи оператора hasOwnProperty, которое наследуется всеми классами от корневого класса Object
firstComment.hasOwnProperty('text') //true
firstComment.hasOwnProperty('upvote') //false (это свойство экземпляра firstComment является унаследованным, а не собственным)

Ключевое слово static позволяет создавать методы, которые являются свойствами самого класса
Методы static не являются собственными свойствами экземпляра этого класса и не наследуются ими
Поэтому статические методы нужно вызывать как методы класса, а не экземпляра этого класса
class Comment{ static mergeComments(first, seconds) {return `${first} ${second}`} }
const firstComment = new Comment()
firstComment.mergeComments('Awesome comment!', 'Great comment') //Error: firstComment.mergeComments is not a function
Comment.mergeComments('Awesome comment!', 'Great comment') //'Awesome comment! Great comment'

Для расширения классов используется Наследование
Классы можно расширять, создавая новые классы, которые от них наследуются
В новых классах указываются нужные новые свойства
Наследование реализуется с помощью ключевого слова extends
При создании обьекта класса наследника - сначала будет вызван конструктор суперкласса, а затем конструктор класса наследника, если он существует
Для вызова конструктора суперкласса используется ключевое слово super, которое должно быть указано на первой строке
Если этот конструктор имеет параметры, их нужно указать в круглых скобках ( super(c, d) )
Далее можно обьявлять новые свойства класса наследника
class Parent { constructor(a, b) { this.name=a; this.price=b } }
class Child extends Parent { constructor(c, d, f) { super(c, d); this.maxspeed=f; } }
Если в классе наследнике нет конструктора, для создания его экземпляров будет использоватся конструктор суперкласса

Прототип - это обьект, который содержит методы определенные в соответствующем классе
Prototype - свойство класса, которое показывает его прототип (обьект с методами класса)
Узнать прототип экземпляра класса можно с помощью скрытого свойства __proto__
const a = 3
a.__proto__ //Number
Можно сравнить прототип любого класса с прототипом экземпляра этого класса
Например, прототип класса Number и прототип переменной, со значением примитивного типа число - они будут идентичны
Проверяется наличие и идентичность всех методов в прототипе (обьекте с методами) класса Number и прототипе переменной
Number.prototype === a.__proto__ //true

Строки и числа - примитивные значение и их переменных хранят только значения
Но строки и числа ведут себя как обьекты, потому что им доступны методы их родительских классов String, Number и Object
const myName = 'Kirill'
myName.toUpperCase() //'KIRILL'
const a = 3 - переменная с примитивным типом значения Number
a.toString() //'3'
Переменная проинициализированная примитивным значением String или Number - ведет себя как обьект класса String или Number, соответственно
const b = new Number(9) - обьект класса Number
b.toString() //'9'

Промисы позволяют обрабатывать отложенные во времени события
Промис - это обещание предоставить результат позже (а не сразу же)
Промис может вернуть ошибку, если результат предоставить - невозможно
Промис может вернуть либо результат (определенного действия), либо ошибку
Состояния промиса:
1) Ожидание - как только промис создается, он ожидает результат или ошибку
2) Исполнен - промис вернул результат (обьект с данными, массив документов)
3) Отклонен - промис вернул ошибку

Создание промиса
Промис - это обьект
Промис создается с использованием ключевого слова new, за которым следует название его класса - Promise
Тоесть создается новый обьект класса Promise, который записывается в переменную
В качестве агрумента передается коллбэк функция, у которой обязательно должно быть 2 параметра, которые являются функциями
Внутри этой коллбэк фукнции нужно в результате вызвать одну из функций из ее параметров
Когда вызываем resolve функцию, мы должны передать какой-то результат, данные
Когда вызвана функция resolve, промис считается исполненным, его состояние меняется с pending на resolved
Если возникла ошибка, нужно вызвать функцию reject и передать ей ошибку, которая возникла
В таком случае, промис считается отклоненным - rejected
const myPromise = new Promise((resolve, reject)=>{
//Блок кода, для выполнения асинхронных действий
//Внутри этой функции нужно в результате вызвать одну из фукнций resolve или reject});

Получение результата промиса (как с ним работать и его использовать)
Обьекту/экземпляру класса Promise будут доступны методы then и catch и их можно комбинировать (вызывать 1, а затем и 2-ой)
В качестве аргумента методу then передается функция с 1 параметром
myPromise.then(value=>{
//Действия в случае успешного исполнения промиса
//Значение value - это значение переданное в вызове фукнции resolve (аргумент) внутри промиса})
myPromise.catch(error=>{
//Действия в случае отклонения промиса
//Значение error - это значение, переданное в вызове функции reject (аргумент) внутри промиса})

Async/Await - специальный синтаксис, надстройка для упрощения работы с промисами
Асинхронная функция - это функция, которая вместо значения возвращает промис
В асинхронной функции, как и в других, для возвращения какого либо результата (строка, число, обьект) можно использовать ключевое слово return
Асинхронная функция создается с использованием ключевого слова async
async function asyncFunc () {//Всегда возвращает промис}
const asyncFunc = async () => {//Всегда возвращает промис}
const asyncFunc = async function () => {//Всегда возвращает промис}
const asyncFn = async () => { return 'Success!' }
asyncFn() //Promise with State 'fulfilled' and Result 'Success!'
Сначала функция asyncFn вернет промис, а затем выполнит resolve фукнцию, этого промиса, аргументом которой будет строка 'Success!'
Результатом промиса, который вернет функция asyncFn, будет строка 'Success!'
В данном примере, мы ничего не ожидаем, а промис мгновенно исполняется/резолвится
const asyncFn = async () => { return 'Success!' }
Благодаря ключевому слову async, в обьявлении переменной asyncFc создается промис неявно, без ключевого слова new и указания класса Promise((resolve, reject)=>{})
Промис автоматически возвращается из асинхронной функции, и в итоге, с ним можно работать, как с любым промисом, добавлять вызовы методов then и catch
asyncFn().then(value=>console.log(value)) //'Success!'
Если промис, в асинхронной функции, возвращает ошибку, то он будет отклонен/rejected с этой ошибкой
const asyncFn = () => { throw new Error('There was an error!!') }
asyncFn() //Promise with State 'rejected' and Result 'Error: There was an error!!'
Что бы обработать ошибки, после вызова асинхронной функции, нужно добавить метод catch
asyncFn()
.then(result => console.log(result))
.catch(error => console.log(error.message))
//'There was an error!!'
Ненужно вызывать ни resolve ни reject функции, потому что в asyncFn() функции таких переменных вообще нет
Но неявно, внутри asyncFn() будет вызов функции reject с ошибкой, которую можно обработать в методе catch

В асинхронных фукнциях, и только в них, можно использовать ключевое слово await, с помощью которого можно ожидать результат другого промиса
Асинронная функция ожидает результата инструкции await и не выполняет последующие инструкции/код, после его получения, когда промис resolved/rejected - выполнение кода продолжается
В это время, Javascript может выполнять другие задачи (действия при нажатии пользователя на кнопку во  фронт енд приложении)
Поэтому промисы и инструкция await - не блокируют выполнение других частей приложения (но блокирует дальнейшее выполнение кода в функции, где они указаны)
await может быть не 1, а несколько
const timerPromise = () =>
new Promise((resolve, reject) =>
setTimeout(() => resolve(), 2000))
Через 2 секунды, будет вызвана функция внутри setTimeout, которая в свою учередь, вызовет фукнцию resolve(), соответственно промис будет исполнен
Промис создастся, функция timerPromise его вернет, он будет в статусе pending, пока не пройдет 2 секунды
Через 2 секунды будет вызвана функция resolve() и тем самым промис станет исполненым
const asyncFn = async () => {
const start = performance.now()
console.log('Timer starts ', start)
await timerPromise()
const finish = performance.now()
console.log('Timer ended ', finish)
console.log('Executed time is ', finish - start) }
asyncFn()
В асинхронной фукнции asyncFn(), await ожидает результата другого промиса, в функции timerPromise()
Функция дальше await - не выполняется, пока не получен результат другого/указаного промиса (исполнен или отклонен), ждет его выполнения
const timerPromise = () =>
new Promise((resolve, reject) =>
setTimeout(() => resolve('Hi'), 2000))

const asyncFn = async () => {
const start = performance.now()
console.log('Timer starts ', start)
await timerPromise()
const finish = performance.now()
    //console.log(timerPromise().then(value=>console.log(value)))
console.log('Timer ended ', finish)
console.log('Executed time is ', finish - start) }
asyncFn()
Между выводом в консоль строк 'Timer starts' и 'Timer ended', прошло 2 секунды (execution time)
Промисы и Await инструкции не блокируют выполнение других частей приложения (пока фукнция ожидает возврата результата промиса (инструкция await), пользователь может кликать на кнопки и они будут работать)

Переход с промисов на async/await
1)
const getData = (url) =>
new Promise((res, rej) =>
fetch(url)
.then(res1=>res1.json())
.then(res2=>res(res2))
.catch(err=>rej(err)) )

2)
getData('https://www.motorsport.com/user-info/')
.then(result=>console.log(result))
.catch(error=>console.log(error.message))

1 переписываем на
const getData = async (url) => {
const response = await fetch(url)
const result = await response.json()
return result }

return result - означает, что промис, возвращаемый асинхронной функцией getData, будет исполнен, и в качестве его результата получим значение в переменной result
Пока ожидается результат промисов в фукнциях fetch и json, с помощью ключевого слова await, промис возвращаемый асинхронной функцией getData находится в статусе pending
Если в результате промисов fetch или json будет возвращена ошибка, промис возвращаемый асинхронной функцией getData, будет автоматически отклонен, с возникшей ошибкой

const url = 'https://www.motorsport.com/user-info/'

getData(url)
.then(result=>console.log(result))
.catch(error=>console.log(error))

2 переписываем на
const data = await getData(url)

await в Javascript можно использовать только в асинхронных функциях, но веббраузеры позволяют это делать непосредственно в консоли
В этом примере нет обработки ошибки и в случае ее возвращения промисом - будет непойманная ошибка
Для обработки ошибок в await используется блок кода try/catch

try {
const data = await getData(url)
console.log(data) }
catch(error) {
console.log(error.message) }

Javascript интерпретирует переносы строк как завершение предыдущей команды

var имеет функциональную область видимости, а не блочную
var обьявленная внутри блока кода, кроме функций - создается в ГОВ, let и const - в ЛОВ
function sum() { var userName = 'Yurij' }
console.log(userName) //Error
{ var userName = 'Yurij' }
console.log(userName) //'Yurij'

Если коллбэк функция содержит только 1 выражение (вызов функции), можно использовать неявный возврат значения (опускать фигурные скобки и ключевое слово return)

Свернуть все блоки кода в VSCode можно при помощи комбинации клавиш Ctrl+L Ctrl+0

Регулярные выражения (RegExp) используються для поиска и замены в строке, сопоставления текста с шаблоном
Обьявить регулярное выражение можно 2 способами:
1.) Используя конструктор и ключевое слово new
const regexp = new RegExp('pattern', 'flags');
2.) С помощью слешей, в начале и вконце
const regexp = /pattern/flags;
Обьявление с помощью слешей является статическим и не может включать в себя какую-то динамику, например - зависимость от либо переменной
const regexp = /pattern${name}/gmi - вызовет ошибку
Обьявление с использованием конструктора позволяет это делать, так как, патерн являеться строкой и, через шаблонные строки, можно добавлять переменные
const regexp = new RegExp(`pattern ${name}`, 'gmi')
let str = 'abc'
let reg = new RegExp(`[${str}]`, 'gi')
reg.test('cba') //true

const str = 'Hello all. How are you ?'
const check = new RegExp(' are ')
check.test(str) //true

Основные флаги в регулярных выражениях:
1.) i (ignore case) - означает, что паттерн не чувствителен к регистру
/pattern/i.test('this is a PATTERN') //true
2.) g (global search) - глобальный поиск, выдает все совпадения, а не только лишь первое
'pattern, this is a pattern'.match(/pattern/) //['pattern', index: 0, input: 'pattern, this is a pattern', group: undefined]
'pattern, this is a pattern'.match(/pattern/g) //['pattern', 'pattern']
3.) m (multiline) - мультистрочный поиск
4.) u (unicode) - позволяет искать по символам закодированным в UNICODE (в нем закодирована кириллица)
const str = `1 kot
2 kot
3 kot`
str.match(/^\d/g) //'1'
str.match(/^\d/gm) //['1', '2', '3']
4.) s (singleline)
5.) u (unicode)
6.) y (stiky)

Методы регулярных выражений: match и replace относятся к классу String, а test - к классу RegExp
1.) match
str.match(regexp)
'Hello, how are you ?'.match(/you ?/) //['you ', index: 15, input: 'Hello, how are you ?', groups: undefined]
'Hello, how are you ?'.match(/you all ?/) //null
Что бы null не вызвал ошибку, результат регулярного выражения можно присвоить переменной, а в случае null записать в нее пустой массив
const res = 'Hello, how are you ?'.match(/you all ?/) || [];
console.log(res[0]) //undefined вместо ошибки

2.) replace
str.replace(regexp, 'swap')
'Hello, how are you ?'.replace(/you/, 'we today') //'Hello, how are we today ?'

3.) test
regexp.test
/you/.test('Hello, how are you ?') //true

Символьные классы в регулярных выражениях - набор символов, каждый из которых подходит под условия поиска:
\d (digit) - любая цифра
\w (word) - латинская буква (ABC..), цфира и нижнее подчеркивание _
\s (space) - наличие пробела и любого символ (отсутствие пробела - false)
Проверяет наличие пробела - true
/\s/.test('    d') //true
/\s/.test('d') //false
/\s/.test(' ') //true
/\s/.test('') //false
\D - любой символ кроме \d (цифр)
\W - любой символ, но не символы \w
\S - наличие любого символа, кроме пробела (отсутствие любого символа - false)
Проверяет наличие любого символа - true
/\S/.test('    d') //true
/\S/.test('d') //true
/\S/.test(' ') //false
. - абсолютно любой символ кроме \n
\b (boundary) - границы слова
/\d\d/.test('29 January') //true
\d\d - 2 цифры подряд
/\bJava\b/.test('Javascipt) //false
/\bJava\b/.test('Java!') //true

Якоря - позволяют проверить начало и конец строки на соответствие какому-либо символу
^ - начало строки
$ - конец строки
/^\d\d/.test('29 January') //true
/y$/.test('29 January') //true

Пропуск специальных символов
Специальными символами, в регулярных выражениях, являются: \ / ^ $ . ( ) [ | ? * +
Для работы со специальными сомволами в строке используется обратный слэш \
/\$/.test('The price is 65000 $') //true
При обьявлении регулярного выражения с помощью конструктора, необходими использовать двойной обратный слэш, так как в строках он используется еще и для экранирования
const myRegExp = new RegExp('\\$\\.\\*')
'Hello$.*'.match(myRegExp) //['$.*', index: 5, input: 'Hello$.*', groups: undefined]

Наборы и диапазоны
[sdr] - совпадение с любым символом из скобок
/[io]/i.test('Hi') //true
[0-9] - любая цыфра от 0 до 9 (эквивалент \d)
[A-Z], [a-z] - любая буква, которая входит в этот диапазон
Диапазоны можно комбинировать в регулярном выражении [A-Z0-9a-z]
/[A-Z0-9a-z]/.test('9Am')
[а-яё] - кириллица (букву ё нужно добавлять дополнительно, так как, она не входит в диапазон стандартно)
Исключения в диапазонах устанавливаются с помощью символа ^, все кроме ...
[^a-z] - любой символ кроме букв из диапазона a-z
/[^0-9]/.test('123') //false ( /\D/.test('123') )
/[^0-9]/.test('123!') //true
/[^a-z]/.test('Hi9') //true
/[^a-z]/.test('Hi') //false

/[\s\d]/ - ok
Исключения в диапазонах
Экранируется в квадратных скобках диапазона только то, что имеет значение в них
1. . + ( ) - эти спецсимволы могут указыватся без экранирования
/[.()]/.test('Hi.') //true
2. Тире, воспринимается как символ, а не разделитель диапазона, если он записан как первый или последний символ в диапазоне
/[-*()]/.test('Hi-') //true
/[()*-]/.test('Hi-') //true
/[()-*]/.test('Hi-') //false
3. Символ ^ воспринимается как символ для поиска, а не исключение, только если он находиться в диапазоне не на первом месте
/[^0-9]/.test('9') //false
/[0-9^]/.test('nine^') //true
/[0-9^]/.test('nine') //false
4. Закрывающая квадратная скобка ] е

Квантификаторы - последовательность может повторяться несколько раз (длинна последовательности должна быть)
{n} - точное количество
/[a-z]{3}/.test('He3ll3o') //false
/[a-z]{3}/.test('Wel3co3me3') //true
{n1,n2} - количество символов от n1 до n2 (пробела между значениями быть не должно)
/\d{3,5}/.test('33Hi33') //false
/\d{3,5}/.test('33Hi123') //true
/\d{3,5}/.test('33Hi123456789') //true (верхняя граница превышено, но результат выражения - true, так как количество цифр попадает в диапазон 3-5)
'33Hi123456789'.match(/\d{3-5}/) //'12345' - числа которые выше верхней границы 5 - неучитываются
'Hello everybody, how are you ?'.match(/\w{3,5}/) //Hello
'Hello everybody, how are you ?'.match(/\w{6,7}/) //everybo
{n,} - количество больше или равно n
'Hello everybody, how are you today ?'.match(/\w{3,}/g) //['Hello', 'everybody', 'how', 'are', 'you', 'today']
'Hello everybody, how are you today ?'.match(/\w{3,}/) //'Hello'

Some trash with regular expressions - it's cropped the words to pieces during checking of the string
'Hello everybody, how are you today ?'.match(/\w{2,3}/g) //['Hel', 'lo', 'eve', 'ryb', 'ody', 'how', 'are', 'you', 'tod', 'ay']
'Hello everybody, how are you today ?'.match(/\w{2,2}/) //'He'

Сокращения квантификаторов
Знак + означает {1,} - от 1 до бесконечности
? - {0,1} - позволяет проверить существует ли такая буква, опциональный элемент
* - {0,} - от 0 и выше
'333Hello999'.match(/\d+/g) //['333', '999']

Жадные и ленивые алгоритмы
Жадный - идет от 1-ой двойной кавычки до конца строки, а потом возвращается назад до ближайщей двойной кавычки
'I "love" you all boys and "girls" very match'.match(/".+"/g) //['"love" you all boys and "girls"']
Ленивый - доходит до 2-ой двойной кавычки, а затем ищет следующую первую двойную кавычку
'I "love" you all boys and "girls" very match'.match(/".+?"/g) //['"love"', '"girls"']
'Number1ANumber2BNumber3CNumber'.match(/\d.+/g) //['1ANumber2BNumber3CNumber']
'Number1ANumber2BNumber3CNumber'.match(/\d.+?/g) //['1A', '2B', '3C']

Группы захвата - указываются в круглых скобках
'go1go2go3go4go5gogo'.match(/(go)+/) //['go', 'go', index: 0, input: 'go1go2go3go4go5gogogo', groups: undefined]
'go1go2go3go4go5gogo'.match(/(go)+/g) //['go', 'go', 'go', 'go', 'go', 'gogogo']
'go1go2go3go4go5gogogo'.match(/(go){3,}/) //['gogogo', 'go', index: 15, input: 'go1go2go3go4go5gogogo', groups: undefined]
'go1go2go3go4go5gogogo'.match(/(go){3,}/g) //['gogogo']
'I love you'.match(/(lo)ve/) //['love', 'lo'), index...]
'I love you'.match(/(lo)(ve)/) //['love', 'lo', 've'), index...]
'I love you'.match(/(lo)(ve)/g) //['love']

Использование индексов групп захвата
'Hello my friends'.replace(/(\w+) (\w+) (\w+)/, '$3 $2 $1') //'friends my Hello'
Исключить одну из групп захвата можно поставив ?: первым параметром в круглых скобках
'Hello my friends'.replace(/(?:\w+) (\w+) (\w+)/, '$3 $2 $1')

OR - используется когда нужно проверить строку на один из нескольких паттернов (пробел до и после OR не ставится)
'CSS, HTML, Javascript, Git, SQL, Postman'.match(/html | css | javascript/i) //[' Javascript', index: 10, input: 'CSS, HTML, Javascript, Git, SQL, Postman', groups: undefined]
/html|css|javascript/.test('I love javascript') //true

Удаление пробелов в начале и конце строки
'     email       '.replace(/^\s+|\s+$/g) //'email'
Удаление повторяющегося пробела
'   I love   you   !   '.replace(/\s{2,}/g, ' ') //' I love you ! '
'   I love   you   !   '.replace(/\s+/g, ' ') //' I love you ! '
Проверка налача строки на https://, где s - необязательный символ
/http(s)?:\/\//.test('https://google.com.ua') //true
/http(s)?:\/\//.test('htts://google.com.ua') //false
/http(s)?:\/\/(\w+\.)+\w+$/.test('https://motorsportnetwork.motorsport.motor1-my.sharepoint.com/:x:/g/personal/olga_polikhronova_motorsport_com/EfqYzZ-H0YVMr6qWgmxfZKUBtCpbIOOo0yI3983-glY1IA?e=4dmF90')
//false ?

Регулярные выражения можно использовать в других методах, например split
'12, 34, 56'.split(/,\s*/) //[12, 34, 56]

Сайт для быстрой проверки регулярных выражений - https://regexr.com/

Сравнение значений нескольких обьектов, без вложенных обьектов
const a = {power: 330, torque: 380, speed: 255, '0-100':5.5}
const b = {power: 350, torque: 370, speed: 255, '0-100':5.7}
const c = {power: 310, torque: 430, speed: 240, '0-100':5.8}

...obj - массив не определенной длинны
function check(...obj){
    const len = obj.length;
    for (let i=1; i<obj.length; i++){
        Object.keys(obj[0]).forEach(el=>{
            console.log(obj[0][el]/obj[i][el])})}}
check(a, b, c)
0.9428571428571428
1.027027027027027
1
0.9649122807017544
1.064516129032258
0.8837209302325582
1.0625
0.9482758620689655