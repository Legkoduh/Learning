Установить Playwright с помощью менеджера пакетов pip - pip install playwright
Pytest - pip install pytest
Плагин Pytest - pip install pytest-playwright
Так же, установить Playwright можно с помощью PyCharm:
File -> Settings -> Project: <project name>  -> Python Interpreter
Выбрать нужный пакет и кликнуть на + (Install)
После установки пакета playwright  установите необходимые браузеры с помощью команды в терминале - playwright install
Playwright загружает браузеры Chromium, WebKit и Firefox в папки кеша ОС:
%USERPROFILE%\AppData\Local\ms-playwright\ в Windows
C:\Users\Kirilo\AppData\Local\ms-playwright\
~/Library/Caches/ms-playwright на MacOS
~/.cache/ms-playwright в Linux
Чтобы установить не 3 браузера, а конкретный - передайте его в качестве аргумента во время установки
playwright install chromium ?
playwright install chrome ?

Playwright предоставляет удобный официальный плагин pytest-playwright
Он реализует несколько фикстур
Наиболее широко используемой из которых является фикстура - "page", которая:
автоматически создаёт браузер, контекст и страницу для запуска теста и функции для работы с ней
автоматически закрывает их
даёт дополнительные возможности: --browser, --headed, --tracing, --video, и т.п.
Без использования фикстуры page, нужно создавать свою собственную, которая делает тоже самое
@pytest.fixture
def browser_fixture():
    with sync_playwright() as playwright:
        browser = playwright.chromium.launch(headless=False)
        context = browser.new_context()
        page = context.new_page()
        yield page
        page.close()
        browser.close()

def test_add_todo(my_fixture):
    pass

Используя встроенную в pytest-playwright фикстуру page, этот код можно существенно сократить
def test_add_todo(page): # Фикстура page передается как аргумент в тестовую функцию, создает browser, context, page и методы для работы с ней
    page.goto("https://demo.playwright.dev/todomvc/#/")
    page.get_by_placeholder("What needs to be done?").click()
    page.get_by_placeholder("What needs to be done?").fill("Создать первый сценарий playwright")
    page.get_by_placeholder("What needs to be done?").press("Enter")

По умолчанию pytest-playwright делает браузер headless (безголовым), тоесть выполнение тестов происходит "под капотом"
Что бы выполнить тест в режиме headed - нужно передать параметр --headed при запусте тестов - pytest --headed

Если для выполнения теста требуются особые параметры контекста браузера (геолокация, размер браузера, куки, user-agent и тд) - их можно задавать
В Selenium это делается через Options
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

options = Options()
options.add_argument("--window-size=1280,720")
driver = webdriver.Chrome(options=options)

В playwright, если установлен плагин pytest-playwright, это делается через его встроенную фикстуру browser_context_args, в conftest.py файле, который служит для конфигурирования pytest
Фикстура browser_context_args возвращает словарь со значениями и устанавливает эти значения в класс browser_context
@pytest.fixture
def browser_context_args(browser_context_args):
    return {
        **browser_context_args,
        "viewport": {"width": 1280, "height": 720},
        "user_agent": "my-custom-agent",
        "storage_state": "state.json",  # Можно подгрузить куки и localStorage
    }

@pytest.fixture(scope="session")
def browser_context_args(browser_context_args):
    return {
        **browser_context_args,
        "storage_state": {
            "cookies": [
                {
                    "name": "stepik",
                    "value": "sd4fFfv!x_cfcstepik",
                    "url": "https://example.com"  # Замените на нужный URL
                },
            ]
        }
    }
Примеры доступных параметров контекста можно найти тут https://playwright.dev/python/docs/test-runners

Если этот плагин не установлен, нужные параметры можно передать в Контекст при его создании
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch()
    context = browser.new_context(
        viewport={"width": 1280, "height": 720},
        user_agent="my-custom-agent"
    )
    page = context.new_page()


Playwright Codegen используют в качестве черновика для быстрого создания прототипа/шаблона, который можно доработать
Запускается он в Терминале при помощи команды, синтаксис которой выглядит так - playwright {параметры} {ссылка}, где параметры - не обязательны
playwright codegen demo.playwright.dev/todomvc/#/
Это команда откроет два окна:
браузер Chromium - в котором нужно выполнять действия по сценарию тестирования
Playwright Inspector - в котором каждое действие будет записано в виде соответствующей строки кода
Далее вы можете выполнить необходимое действие по сценарию в браузере, а codegen запишет и сгенерирует код для выполняемого вами действия

Для доступа ко всем методам и классам playwright - его нужно импортировать в модуль
from playwright.sync_api import Playwright, sync_playwright, expect
browser = playwright.chromium.launch(headless=False) - запуск браузера chromium
headless=False - дает команду, чтобы браузер chromium отображался и был видимым при запуске кода
Если установить True, то браузер не будет отображаться, но при этом все записанные в коде действия сценария будут выполнены
context = browser.new_context() - создает новый изолированный сеанс браузера
page = context.new_page() - открывает новую страницу (таб) в браузере
page.goto("ссылка") - открывает сайт, ссылка на который передана как аргумент
page.click() - клик левой кнопкой мыши
page.fill("Hi") - вводит значения, переданные ему в качестве аргумента в веб-элемент
page.press("Enter") - нажатие на кнопку Enter на клавиатуре

Так же, команда playwright codegen может содержать параметры, которые указываются перед ссылкой
Узнать доступные опции и краткое их описание можно, выполнив команду - playwright codegen --help
playwright codegen --viewport-size=800,600 https://www.motorsport.com/ - указать размер открываемого окна браузера
playwright codegen -o codegen_code.py https://www.motorsport.com/ - файл, в который будет записан сгенерированный код (или --output)

Playwright работает с тремя различными слоями, которые строятся друг на друге:  Browser, Context и Page.
Browser - для работы каждой версии playwright требуются определенные версии браузеров
С каждой новым выпуском, Playwright обновляет версии браузеров которые он поддерживает
Это означает, что при каждом обновлении Playwright вам, возможно придется заново запускать команду  playwright install
В отличие от Selenium, Playwright не использует webdriver
Для Google Chrome, Microsoft Edge и других браузеров на базе Chromium по умолчанию Playwright использует сборки Chromium с открытым исходным кодом

BrowserContext - playwright использует контексты браузера для достижения изоляции тестов
Контекстом можно назвать независимую сессию браузера, схожую с режимом инкогнито
Страницы в двух отдельных контекстах не имеют общих cookie, настроек профиля
Для получения чистой среды тест может просто открыть новый контекст. Как правило, каждый тест имеет свой собственный контекст
По сравнению с Selenium, контексты не требуют собственного процесса браузера

Page - содержит содержимое загружаемого сайта. Используется для навигации по URL-адресам и взаимодействия с содержимым страниц
Каждый контекст может иметь несколько страниц

CLI - интерфейс командной строки (англ. Command Line Interface, CLI)
Передавая различные параметры в командной строке, вы можете менять поведение в работе playwright
--headed - по умолчанию Playwright запускает браузеры в безголовом режиме (headless)
--browser - запустить тесты в нужном браузере, можно повторять, если браузеров несколько
pytest --browser webkit --browser firefox
--browser-channel - запустить тесты на браузерах Chrome и Edge установленных на ПК
pytest --browser-channel=msedge
--slowmo - замедлить выполнение тестов на указанное количество времени в милисекундах
--device - имитация поведения браузера для определенного устройства
--device="iPhone 15 Pro Max"
Список всех поддерживаемых устройств - https://github.com/microsoft/playwright/blob/main/packages/playwright-core/src/server/deviceDescriptorsSource.json
--output - каталог для артефактов, создаваемых тестами, название по-умолчанию - test-results
--tracing - записывать ли трассировку для каждого теста: on, off или retain-on-failure (по-умолчанию - off)
pytest --tracing=on
--screenshot - делать ли скриншот после каждого теста: on, off или retain-on-failure (по-умолчанию - off)
--video - записывать ли видео для каждого теста: on, off или retain-on-failure (по-умолчанию - off)
--full-page-screenshot - делать ли скриншот всей страницы при ошибке
По умолчанию снимается только область просмотра. Требуется, чтобы параметр --screenshot был включен (по умолчанию: off)

Кроме CLI, на выполнение теста можно влиять с помощью маркеров pytest
@pytest.mark.skip_browser("firefox") - пропустить тест браузером
def test_visit_example(page):
    page.goto("https://example.com")

@pytest.mark.only_browser("chromium") - запуск теста в определенном браузере
def test_visit_example(page):
    page.goto("https://example.com")


Веб-элемент - представляет собой DOM объекты, находящиеся на веб странице
Селектор - это строка, адресс веб-элемента нужный для того, что б его найти
Сам селектор не умеет искать веб-элементы - это просто строка, адресс
".ms-desktop-menu__item.ws:visible"
"//div[@class='menu-item']"
"text=Login"
Поиск веб-элементов осуществляет локатор
 - объект, который Playwright создаёт на основе селектора
Локатор это "умный указатель", который умеет искать элементы по селектору и взаимодействовать с ними
menu_buttons = page.locator(".ms-desktop-menu__item.ws:visible")
Он имеет методы для интеракции: .click(), .fill(), .nth(), .count(), .all() и т.д
Может указывать на один или несколько элементов, если они имеют одинаковый селектор (адресс)
В основном для поиска используют XPath-локаторы и CSS-селекторы
Для того чтобы использовать селекторы  CSS и XPath в Рlaywright, реализован метод - page.locator(selector, **kwargs)
Чтобы явно указать передаваемый тип локатора, необходимо указать префикс
css= - если используется css селектор
xpath= -  в случае если передается xpath селектор
page.locator("css=button").click() # CSS
page.locator("xpath=//button").click() # Xpath

Селекторы по аттрибуту ID/идентификатору
Этот селектор выбирает элементы, основываясь на названии их атрибута id
Синтаксис для CSS требует использования символа # - #ИмяИдентификатора
page.locator("#new-todo")
Для Xpath - [@id='ИмяИдентификатора']
page.locator("//*[@id="new-todo"]")

Селекторы по аттрибуту class
Этот селектор выбирает элементы, основываясь на значении их атрибута class
Чтобы выбрать элемент с определённым классом с помощью css, нужно добавить точку перед его названием - .main-class
CSS - page.locator(".class-name")
XPath - page.locator("//*[@class='class-name']")
Для поиска веб-элементов можно использовать несколько классов одновременно, обьединяя их точкой
page.locator("css='.parent-class.child-class") # Перечисляя классы через точку
page.locator("xpath=//div[contains(@class, 'parent-class) and contains(@class, 'child-class)]") # Используя метод contains(@аттрибут, его значение) и оператор and

Селекторы по аттрибуту
CSS синтаксис:
[attr] поиск по аттрибуту независимо от его значения
page.locator("[placeholder]")
[attr='attr_value'] - поиск по аттрибуту с указанным значением
page.locator("[placeholder='email']")
XPath:
page.locator("//*[@placeholder]")
page.locator("//*[@placeholder='email']")

page.locator("#id_value")
page.locator(".class_value")
page.locator("[attr]")
page.locator("[attr='attr_value']")
page.locator("//*[@id='id_value']")
page.locator("//*[@class='class_value']")
page.locator("//*[@attr]")
page.locator("//*[@attr='attr_value']")

Значение аттрибута начинается с …

 
[attribute^="val"]
 - атрибут начинается с val
Заканчивается на … [attribute$="val"] - атрибут заканчивается на val
Содержит … (подстрока) [attribute*="val"] - атрибут содержит подстроку val

Для достижения уникальности элемента селекторы лучше комбинировать: тег, класс, id, аттрибуты
page.locator("input[placeholder='Your email address']").click()
page.locator("//input[@placeholder='Your email address']").click()

Комбинатор потомков объединяет два селектора таким образом, что элементы, соответствующие второму селектору, выбираются, если у них есть предки (родитель, родитель родителя, родитель родителя родителя и т.д.), соответствующие первому селектору
Этот комбинатор представлен символом пробела
page.locator(".container p")
Комбинатор детей - выбирает элементы, которые являются прямыми дочерними элементами другого элемента
page.locator(".container > p")
Цепочка локаторов (chaining) представлена 2 символами >> - сначала находит элементы по первому селектору,

 потом среди них выберает что-то ещё
page.locator(".ms-desktop-menu__item.ws >> nth=4").click()
Находит все элементы, которые соответствуют .ms-desktop-menu__item.ws, а среди найденных выбирает пятый элемент (nth=4, индекс с 0)
page.locator('div.wrapper >> text="Continue"') - находит все div.wrapper, а потом внутри ищет элемент с текстом "Continue"

Так же chaining может быть представлен последовательностью локаторов
page.locator(".ms-desktop-header").locator(".ms-desktop-menu__main .ms-desktop-menu__item.ws").nth(2).click()
menu = page.locator(".ms-desktop-header")
menu.locator(".ms-desktop-menu__main .ms-desktop-menu__item.ws").nth(2).click()


В ДевТулс можно использовать XPath и CSS для поиска веб-элементов
div.ms-search-box > button
//div[@class='ms-search-box']/button

Псевдоклассы CSS в Playwright - это ключевое слово, добавленное к селектору, которое определяет его особое состояние
Рlaywright дополняет работу с CSS  селекторами с помощью различных псевдоклассов
Псевдоклассы CSS Playwright — дополнительный синтаксис, которого нет в CSS
Стандартные псевдоклассы CSS (:hover, :nth-child(n)) работают и в Playwright, потому что он умеет использовать настоящие CSS-селекторы
Псевдоклассы CSS в Playwright:
1. :right-of(div > button) - cоответствует элементам, которые находятся справа от любого элемента, соответствующего внутреннему селектору, в любом положении по вертикали
right-of - справа от, любой элемент справа от div > button
page.locator("td:right-of(td p:text('Software engineer'))")
2. :left-of(div > button) - соответствует элементам, которые находятся слева от любого элемента, соответствующего внутреннему селектору, в любой позиции по вертикали
a:left-of(div > button) - любой тег а, который находится слева от div > button
page.locator("td:left-of(td p:text('Software engineer'))")
3. :above(div > button) - соответствует элементам, которые находятся над любым из элементов, соответствующих внутреннему селектору, в любом горизонтальном положении
page.locator("td:above(td p:text('Consultant'))")
4. :below(div > button) - соответствует элементам, которые находятся ниже любого из элементов, соответствующих внутреннему селектору, в любой позиции по горизонтали
page.locator("td:below(td p:text('Consultant'))")
5. :near(div > button) - подбирает элементы, которые находятся рядом (в пределах 50 CSS пикселей) с любым из элементов, соответствующих внутреннему селектору
page.locator("td:near(td p:text('Consultant'))")
Все псевдоклассы макета поддерживают необязательную опцию - максимальное расстояние в пикселях
Например, button:near(:text("Username"), 120) соответствует кнопке, которая находится на расстоянии не более 120 пикселей от элемента с текстом "Username"
page.locator("td:below(td p:text('Software engineer'), 100)")

Локатор N-го элемента
page.locator("button").locator("nth=0").click() # Первый элемент
page.locator("button").locator("nth=-1").click() # Последний элемент
page.locator(".ms-desktop-menu__item.ws >> nth=4").click() # 5-ый элемент (индексация начинается с 0)
page.locator(".ms-desktop-menu__item.ws").nth(4).click() # 5-ый элемент
li:nth-child(2) - выберет только тот li, который является 2-ым li в списке дочерних элементов у своего прямого родителя
Проверяет позицию среди всех детей
li:nth-of-type(2) - выберет 2-ой li, среди всех li прямого родителя
Проверяет позицию только среди элементов такого же типа
У :nth-of-type() и :nth-child() индекс начинается с 1
<ul>
  <li>Первый</li>
  <div>Блок</div>
  <li>Второй</li>
</ul>
li:nth-child(2) не сработает, потому что 2-й ребёнок — это <div>


li:nth-of-type(2) выберет именно второй <li>

Определение местоположения только видимых элементов
:visible - псевдокласс в CSS-селекторах для выбора видимого элемента
page.locator("button:visible").click()

Определение по тексту
:has-text() - псевдокласс  выбора элемента содержащего указанный текст
page.locator('div:has-text("Card")').click()
Обратите внимание, что псевдокласс :has-text() нужно обязательно использовать вместе с  css селектором, иначе Playwright будет искать  указанный текст по всему DOM

Элементы, отвечающие одному из условий
page.locator('button:has-text("Log in"), button:has-text("Sign in")').click() - нажимает на элемент с тегом <button>, которая содержит текст "Log in" или "Sign in"

CSS селекторы
page.locator(".btn")             # класс
page.locator("#submit")          # id
page.locator("input[name='q']")  # по атрибуту
page.locator("[placeholder]")    # элемент с атрибутом

Комбинированные селекторы
page.locator("div.menu >> text='Profile'") # Сначала ищет div.menu, внутри – текст "Profile"

Nth / Индексация
page.locator(".item").nth(2)     # третий элемент (индексация с 0)
page.locator(".item >> nth=2")   # то же самое

CSS :nth-child / :nth-of-type
page.locator("li:nth-child(2)")       # li, который 2-й ребёнок
page.locator("li:nth-of-type(2)")     # 2-й li среди всех li

Псевдоклассы и текст

page.locator("button:has-text('Save')")
page.locator("input:focus")
page.locator("a:visible")

Комбинирование
page.locator("form >> input[name='email']").fill("test@mail.com")
page.locator("ul.menu >> li >> nth=1").click()

XPath (но Playwright рекомендует CSS)
page.locator("//button[@type='submit']")

Выбор внутри родителя

page.locator(".card").locator("button:has-text('Edit')").click()

t_c = page.locator("input:has-text('Default radio')").click()
f_c = page.locator("input").filter(has_text="Default checked radio").check()
Эти локаторы не сработают, потому элемент <input> не содержит текстового содержимого, даже если рядом есть текст (например, <label>)

А :has-text() и has_text= проверяют именно внутренний текст элемента — а у <input> его нет


Playwright умеет работать с такими классическими локаторами как CSS и XPath, через метод locator
page.locator("xpath='//div[@class='main_class']'")
page.locator("css='div.main_class'")
Но начиная с версии Playwright 1.27,  в нем реализованы несколько встроенных локаторов, которые упрощают и организуют процесс локализации веб-элемента
Для обеспечения стабильности своих тестов, создатели Playwright рекомендуют использовать именно локаторы get_by_*
Поиск по:
тексту - page.get_by_text(text, **kwargs) - page.get_by_text("switch checkbox").click()
По умолчанию get_by_text("Name") ищет подстроку — то есть он найдёт любой элемент, где встречается слово "Name", даже если текст элемента длиннее - My Name is Shady
С exact=True поиск становится строгим — локатор выберет только те элементы, текст которых полностью совпадает с "Name", без лишних слов или символов
page.get_by_text("Name", exact=True)
атрибуту title - page.get_by_title(text, **kwargs) - page.get_by_title("username").fill("Kirilo")
плейсхолдеру - page.get_by_placeholder(text, **kwargs) - page.get_by_placeholder("password")
тегу <lable> - page.get_by_label(text, **kwargs) - page.get_by_label("Email address").fill("qa@example.com")
на основе data-testid - page.get_by_test_id(test_id) - page.get_by_test_id('todo-title').click()
Поиск изображение на основе атрибута alt - page.get_by_alt_text(text, **kwargs) - page.get_but_alt_text("logo").click()

Поиск элемента по роли ARIA - page.get_by_role(role, **kwargs)
Локатор page.get_by_role(role, **kwargs) отражает то, как вспомогательные технологии(Скринридер (screen reader)) для людей с ограниченными возможностями, воспринимают страницу
Роли ARIA добавляются в элементы HTML с помощью явного атрибута role="role type", где role type - это имя роли в спецификации ARIA
Даже если атрибут role не указывается у веб-элемента, то все элементы имеют «неявную ARIA-семантику по умолчанию»
Если у тега button нет явного указания его роли, то вы все равно можете использовать поиск веб-элемента по его роли использую следующую запись - page.get_by_role('button')
Аналогичная запись сработает если веб элемент не имеет тег button, но ему явно указана роль кнопки
При поиске по роли ARIA обычно следует также передавать доступное имя, чтобы локатор точно определил нужный элемент
page.get_by_role("button", name="Submit").click()

Локатор or_ - создает локатор, который соответствует любому из двух локаторов
Используется для поиска элемента, который соответствует хотя бы одному из заданных селекторов
selector = page.locator("input").or_(page.locator("textarea"))
Локатор and_ - используется для поиска элемента, который соответствует всем заданным селекторам
selector = page.get_by_role("button", name="Sing up").and_(page.get_by_title("Sing up today"))

Цепочка локаторов
Локаторы могут быть объединены в последовательность(цепь)  с помощью символа  >>
При использовании такой формы записи, следующий селектор запрашивается относительно результата предыдущего
page.locator("#navbarNavDropdown >> li:has-text('Company')").click()
Другим вариантом использования цепочки локаторов является сохранение веб-элемента в переменную и обращение к локаторам с помощью этой переменной
nav_bar = page.locator('div#navbarNavDropdown')
nav_bar.locator("li:has-text('Company')").click()
Фильтрация
Для того чтобы помочь локализовать поиск,  реализован метод filter()
Сузить поиск можно передав аргументом фильтр по тексту, по локатору или можно использовать оба способа фильтрации
Функция filter()  принимает несколько аргументов:
has
has_not
has_text
has_not_text
Для того чтобы отфильтровать элементы по тексту, нужно передать аргумент has_text=  и текст, который присутствует в элементе
page.locator("li").filter(has_text='Company').click()
Для того чтобы отфильтровать элементы по локатору, используйте аргумент has=
page.locator('li').filter(has=page.locator('.dropdown-toggle')).click()
Для поиска элементов, не соответствующих определенному локатору
row_locator = page.locator("tr")
row_locator.filter(has_not=page.get_by_role("button")).count()
Если необходимы элементы которые не содержат определенный текст, в том числе  в дочернем элементе или элементе-потомке используется - has_not_text
Поиск совпадений не чувствителен к регистру и ищет подстроку
row_locator = page.locator("tr")
row_locator.filter(has_not_text="helicopter")
И все это можно комбинировать>>
row_locator = page.locator("tr")
row_locator
    .filter(has_text="text in column 1")
    .filter(has=page.get_by_role("button", name="column 2 button"))
    .click()
has_text и has_not_text - ищут среди всех элементов и их потомкой
has и has_not - ищут только среди потомков предоставленных элементов и не проверяют сами элементы
:not() - псевдокласс CSS, который позволяет исключить из самих элементов те, у которых есть указанный класс
<div class="parent has-child">
  <span class="child"></span>
</div>
<div class="parent"></div>
page.locator(".parent").filter(has=page.locator(".child")) - вернет только первый div, так как только у него есть потомок с классом child
page.locator(".parent").filter(has_not=page.locator(".child")) - вернет только второй div, потому что у него нет потомка с классом child
page.locator(".parent:not(.child)") - вернет div среди классов которого нет child
Если элемент имеет class="parent has-child" - он останется (нет класса child)

Если имеет class="parent child" отфильтруется, потому что есть класс child

menu_buttons = page.locator(".ms-desktop-menu__item.ws:visible") - возвращает Locator, который соответствует всем элементам на странице, подходящим под переданный селектор
print(type(menu_buttons)) # <class 'playwright.sync_api._generated.Locator'>
Даже если таких элементов несколько, locator не превращается в список, а остаётся единым объектом, который «указывает» на все найденные элементы
print(menu_buttons) # <Locator frame=<Frame name= url='https://www.motorsport.com/'> selector='.ms-desktop-menu__item.ws:visible'>
print(menu_buttons[1]) # TypeError: 'Locator' object is not subscriptable - это все еще обьект Locator, а не список локаторов
Если необходимо узнать количество элементов, соответствующих указанному селектору - используйте метод count()
menu_buttons.count() # 12
Для того чтобы взаимодействовать с конкретным элементом из списка, используйте метод nth() с указанием индекса нужного вам элемента
Указывается именно индекс, а не порядковый номер, по этому счет ведется с 0-го индекса. nth(0) - выбирет первый элемент
page.get_by_role("listitem").nth(1) # Второй
Методы locator.first, locator.last вернут первый и последний элемент из списка
Для того чтобы пройтись по всем элементам можно использовать метод for вместе с range(), count(), для создания диапазона и nth() для перебора по локаторам
menu_buttons = page.locator(".ms-desktop-menu__item.ws:visible")
for number in range(menu_buttons.count()):
    menu_buttons.nth(number).click()
Начиная с версии playwright 1.29 появился специализированный метод locator.all() для перебора всех совпадающих элементов
Если локатор находит несколько  элементов, метод locator.all() возвращает массив локаторов указывающих на соответствующие элементы
print(type(menu_buttons.all())) # <class 'list'> - список
print(menu_buttons.all()) # [<Locator frame=<Frame name= url='https://www.motorsport.com/'> selector='.ms-desktop-menu__item.ws:visible >> nth=0'>, <Locator frame=<Frame name= url='https://www.motorsport.com/'> selector='... ] - список локаторов
for button in menu_buttons.all():
    button.click()

| Метод                    | Для каких элементов                              | Что делает                                    | Особенности                              |
| ------------------------ | ------------------------------------------------ | --------------------------------------------- | ---------------------------------------- |
| .click()                 | Любой кликабельный (button, link, checkbox, div) | Имитирует обычный клик мышью                  | Может включить **или** выключить чекбокс |
| .check()                 | Только `checkbox` и `radio`                      | Устанавливает состояние **checked**           | Если уже checked > ничего не делает      |
| .uncheck()               | Только `checkbox`                                | Устанавливает состояние **unchecked**         | Если уже unchecked > ничего не делает    |
| .set_checked(True/False) | Только `checkbox`                                | Гибко: `True` > включить, `False` > выключить | Заменяет пару `.check()` + `.uncheck()`  |
| .dblclick()              | Любой кликабельный                               | Двойной клик                                  | Можно указать задержку между кликами     |


Действия с элементами
Прежде чем предпринимать какие-либо действия с веб-элементами, Playwright выполняет широкий спектр проверок
Он автоматически ждет, пока пройдут все соответствующие проверки, и переходит к следующему шагу
Это происходит в течение заданного тайм-аута и завершается неудачей, если произошла ошибка проверки
Проверка  элемента  включает:
Attached - элемент присоединен к DOM. Элемент считается прикрепленным, если он подключен к DOM или ShadowRoot.
Editable - элемент редактируемый. Элемент считается редактируемым, если он включен и у него не установлено свойство "read only".
Enabled - элемент включен. Считается включенным, если у тегов button, select, input, textare не имеют свойства disabled.
Receive Events - получает события, не заслоняемые другими элементами.
Stable - элемент стабилен. Элемент считается стабильным, если он сохраняет ту же  область после двух или более последовательных кадров анимации.
Visible -  элемент является видимым
Каждое действие (click, tap, check, hover, fill, getAttribute, selectOption...) требует определенный набор проверок

locator.click(**kwargs) - этот метод кликает на элемент, выполняя следующие действия:
Ждет проверки элемента на возможность действия с ним (если не установлен параметр force)
При необходимости сделает скролл до элемента, чтобы он стал видимым
Ждет успешного или неудачного завершения инициированных навигаций, если не установлена ??опция noWaitAfter
Данный метод принимает несколько аргументов, которые влияют на работу данного метода:
click(button='right') - <"левая"|"правая"|"средняя"> По умолчанию
сlick(force=True) - обходить проверки на возможность действия
click(modifiers=["Shift"]) - клавиши-модификаторы, которые необходимо нажать

dblclick() - двойной клик по элементу
page.get_by_text("Копировать").dblclick()

locator.fill(текст, **kwargs) - для ввода данных в поле ввода
Этот метод ожидает готовности  элемента к  действию, фокусируется на элементе и заполняет его данными переданными в качестве аргумента
Передаваемые данные заполняются сразу единым блоком, не важно сколько символов вы передали 5 или 100, в поле назначения все символы введутся сразу, одним действием

В отличие от  fill() - метод type() передает данные посимвольно
Фактически данный метод посылает события keydown, keypress/input и keyup для каждого символа в тексте
Данный метод может пригодиться в случае тестирования полей ввода с автозаполнением

locator.press(key, **kwargs) - для отправки функциональных клавиш:
F1 - F12, Backspace, Tab, Delete, Escape, ArrowDown, End, Enter, Home, Insert, PageDown, PageUp, ArrowRight, ArrowUp и так далее

keyboard.down() и keyboard.up() — для более точного контроля нажатия и отпускания клавиш, например:
page.keyboard.down("Shift")
page.keyboard.press("KeyA")
page.keyboard.up("Shift") # сочетания клавиш Shift и a
"KeyA" — это код клавиши клавиатуры в стандарте UI Events KeyboardEvent code values
"KeyA" означает клавишу буквы A на клавиатуре, это именно физическая клавиша A, не символ 'a' или 'A'
"Keya" — не сработает, потому что правильный код клавиши всегда в верхнем регистре: "KeyA", "KeyB", и т.д.

Checkbox, radio-button and toggle
Существует два основных метода playwright для работы с данным типом веб-элементов
check() - метод playwright созданный специально для работы с чекбоксами и радио кнопками
Этот метод проверяет элемент, выполняя следующие действия:
проверяет, что элемент является checkbox или radio input
ждет проверки элемента на пригодность к действию, если не установлен параметр force
при необходимости осуществляет скролл к  элементу, чтобы он был видим
page.locator("text=Checked checkbox").check()
click() - второй способ взаимодействия с этим типом веб-элементов
page.get_by_text("Default radio").click()

Выпадающий список select и его пукнты option
Cоздается с помощью тега  <select>, а каждый его пункт задается тегом <option>
select_option() - метод для выбора пункта из выпадающего списка типа select, проверяет, что целевой элемент является тегом  <select>
Принимает 2 аргумента: селектор выпадающего списка и аттрибут, который определяет стратегию поиска пункта в выпадающем списке
Существует 3 аттрибута для поиска в списке select:
index - опции для выбора по индексу
page.select_option('#floatingSelect', index=1)
value - для выбора по значению атрибута value
page.select_option('#floatingSelect', value="3")
label - выбор по текстовому значению
page.select_option('#floatingSelect', label="Нашел и завел bug")
По умолчанию используется поиск по value - по значению аттрибута value или по значению в пункте
Можно использовать синтаксис, без явного указания стратегии поиска
page.select_option('#floatingSelect', "3")
<option value="additional-data-1-of-2">Additional Data</option>
page.select_option(selector_select, "additional-data-1-of-2") # Выбор по значению value="additional-data-1-of-2"
page.select_option(selector_select, "Additional Data") # Выбор по значению пункта Additional Data (тексту), а не значению аттрибута value

Drag-and-drop
drag_and_drop(source, target, **kwargs) - метод для тестирования перетягивания элементов
В качестве аргументов принимает селекторы элемента который нужно перетащить (source) и элемента на который следует перетащить (target)
page.goto("https://tympanus.net/Development/DragDropInteractions/sidebar.html")
page.drag_and_drop(".grid__item >> nth=1", ".drop-area__item >> nth=1")

Alert/Dialog
Playwright может взаимодействовать с диалоговыми окнами веб-страницы alert, confirm, prompt
beforeunload - редкий случай, при попытке закрыть страницу
По умолчанию диалоговые окна  автоматически закрываются Playwright, поэтому вам необязательно их обрабатывать
page.goto("https://zimaev.github.io/dialog/")
page.get_by_text("Диалог Alert").click() # Алерт будет закрыт автоматически и не вызовет ошибку
Для действий с диалоговыми окнами - нужно зарегистрировать обработчик перед действием, которое вызывает диалоговое окно
page.goto("https://zimaev.github.io/dialog/")
page.on("dialog", lambda dialog: dialog.accept()) # Подписка на прослушивание события dialog и регистрация обработчика
page.get_by_text("Диалог Confirmation").click() # Вызов алерта
Playwright позволяет прослушивать различные типы событий, происходящих на веб-странице (такие как сетевые запросы, открытие страницы в новой вкладке, появление диалогового окна и т.д)
Прежде чем обрабатывать какое-либо событие, необходимо подписаться на прослушивание события которе вас интересует с помощью таких методов  как - on или once (добавляет прослушиватель, который будет выполняться только один раз)
Для отписки от событий используйте метод removeListener
page.on -  прослушивает события которые, происходит в приложении
"dialog" - указывает на тип события которое нужно обработать
lambda dialog: dialog.accept() - анонимная функция обрабатывающая событие
page.on("dialog", lambda dialog: dialog.accept())
В данном примере анонимная функция, в качестве параметра принимает экземпляр класса Dialog
Далее метод dialog.accept()  заставляет Playwright нажимать на кнопку OK в диалоговом окне
По умолчанию  диалоговые окна типа confirm, Playwright обрабатывает отказом (т.е нажимаем на Отмена)
Диалоговые окно завершаются автоматически, если нет слушателя page.on("dialog")
Если слушатель присутствует, то так же обязательно должен быть либо dialog.accept(), либо dialog.dismiss()
В противном случае  страница застынет в ожидании действия с окном и тест вызовет ошибку

Для работы диалоговым окном в Playwright используется класс Dialog, содержащий методы для работы с диалоговыми окнами
dialog.accept() - закрыть диалоговое окно нажав кнопку «OK»
page.once('dialog', lambda dialog1: dialog3.accept("Prompt alert text")) # Ввод текста в поле ввода алерта типа prompt
dialog.dismiss() - закрыть диалоговое окно нажав кнопку «Отмена/Cancel»
page.once('dialog', lambda dialog2: dialog3.dismiss())
dialog.message - возвращает сообщение отображаемое в диалоговом окне
dialog.default_value - возвращает значение подсказки в поле ввода, только в случае если тип диалога prompt
dialog.type - возвращает тип диалогового окна
Для использования методов message, default_value и type, обработчик нужно создавать в отдельной функции, так как lambda не дает возможности вставить промежуточную логику
def handle_prompt(dialog):
    print("Тип:", dialog.type)  # Например: prompt
    print("Сообщение:", dialog.message)  # например: Введите имя
    print("Значение по умолчанию:", dialog.default_value)  # Например: John Doe

    # Принять диалог с кастомным значением
    dialog.accept("My name is")

page.once("dialog", handle_prompt)
page.get_by_text("Диалог Prompt").click()

Если в тесте используется 2 диалоговых окна, то нужно использовать один из следующих принцыпов:
1. использовать слушатель once
2. добавлять 1 общий слушатель
3. создавать 2 слушателя в функциях и удалять 1-ый после его вызова/перед вызовом второго алерта
Использование 2х обычных слушаетелей неправильно, так как второй не заменяет первый, а добавляется и в итоге получается 2 слушателя, которые срабатывают на один и тот же диалог
Playwright вызывает все dialog-обработчики, в порядке добавления
page.on('dialog', lambda dialog1: dialog1.accept())
page.locator("text=Диалог Alert").click() # Сработает первый обработчик и нажимается кнопка ОК

page.on('dialog', lambda dialog2: dialog2.dismiss())
page.get_by_text("Диалог Confirmation").click() # Так же срабатывает первый обработчик и нажимается кнопка ОК (accept), а не Отмена (dismiss) и алерт уже будет закрыт

Пример 2
def handle(dialog):
    time.sleep(2)
    if dialog.type == 'prompt':
        print(dialog.message)
        print(dialog.default_value)
        dialog.accept("Text for a prompt dialog")
    elif dialog.type == 'confirm':
        print(dialog.message)
        dialog.dismiss()
    else:
        dialog.accept()

page.on('dialog', handle)
page.locator("text=Диалог Alert").click()
page.get_by_text("Диалог Confirmation").click() # Вы хотите сохранить изменения?
page.get_by_text("Диалог Prompt").click() # Please enter any number # 10

Пример 3
def confirm_handle(dialog1):
    dialog1.dismiss()

def prompt_handle(dialog2):
    dialog2.accept("Hi")


page.on('dialog', confirm_handle) # Регистрируем слушатель и обработчик
page.get_by_text("Диалог Confirmation").click()
page.remove_listener('dialog', confirm_handle) # Удаляем старый слушатель и обработчик, что бы он не сработал для следующего алерта
time.sleep(2)

page.on('dialog', prompt_handle) # Регистрируем новый слушатель и обработчик
page.get_by_text("Диалог Prompt").click()
page.remove_listener('dialog', prompt_handle) # Удаляем слушатель и обработчик
time.sleep(2)


Загрузка файлов (upload)
set_input_files() - метод для загрузки файлов
Принимает 2 аргумента:
1. selector - селектор поля, куда нужно загружать файл
2. files - путь к локальному файлу (если он не в той же директории, что и файл с тестом) и его название
page.goto('https://zimaev.github.io/upload/')
page.set_input_files("#formFile", "hello.txt")
page.locator("#file-submit").click() # Клик на кнопку загрузки
Но использование set_input_files() не единственный способ реализации сценария загрузки файла
Вы можете зарегистрировать обработчик события "filechooser", метод set_files() и получить тот-же результат
page.goto('https://zimaev.github.io/upload/')
page.on("filechooser", lambda file_chooser: file_chooser.set_files("hello.txt"))
page.locator("#formFileLg").click() # Click on the input-field to select a file from the PC
page.get_by_role("button", name="Upload").click() # Click on the Upload button to upload a file
Или вы можете использовать другой вариант записи с использованием менеджера контекста
page.goto('https://zimaev.github.io/upload/')
with page.expect_file_chooser() as fc_info: # fc_info - контекстный менеджер, который после выхода из блока (with) хранит объект FileChooser
    page.locator("#formFile").click()
file_chooser = fc_info.value # fc_info.value - как раз и возвращает объект FileChooser, с которым можно работать
file_chooser.set_files("hello.txt") # set_files() — чтобы выбрать файл(ы) программно


Скачивание файла (download)
Если скачивание файла происходит после клика - нужно использовать метод expect_download() с менеджером контекста
page.goto("https://demoqa.com/upload-download")
with page.expect_download() as download_info:
    page.locator('.btn.btn-blue.col-span-3.md\\:col-span-1 >> nth=1').click()

Когда загрузка будет завершена, будет возвращена информация о загрузке и download_info примет результат загрузки
Можно получить значения  результата загрузки с помощью download_info.value - download = download_info.value
Какую информацию вы получаете ?
download # <Download url='https://filesamples.com/samples/image/jpeg/sample_1280%C3%97853.jpeg' suggested_filename='sample_1280?853.jpeg'>
download.suggested_filename - возвращает имя файла # sample_1280?853.jpeg
download.url - возвращает загруженный URL-адрес # https://filesamples.com/samples/image/jpeg/sample_1280%C3%97853.jpeg
download.page - возвращает объект страницы, к которой принадлежит загрузка # <Page url='https://filesamples.com/formats/jpeg'>
download.path() - возвращает путь к загруженному файлу # C:\Users\Kirilo\AppData\Local\Temp\playwright-artifacts-4wvt2o\a09a04dd-d546-4556-adf3-47aea6ff4be8
download.save_as(path) - скопирует загруженный файл по указанному пути
download.save_as(os.path.join("./test123/", "test_download.jpeg")) # Скачает файл в папку test123 в той же директории что и файл с тестом
download.cancel() - отменяет загрузку - How to use these 3 methods ?
download.delete() - удаляет загруженный файл - ?
download.failure() - возвращает ошибку загрузки, если таковая имеется - ?
page.goto("https://demoqa.com/upload-download")
with page.expect_download() as download_info:
    page.locator("a:has-text(\"Download\")").click()

download = download_info.value
file_name = download.suggested_filename
destination_folder_path = "./data/"
download.save_as(os.path.join(destination_folder_path, file_name))


Получение текста веб-элемента
Получить текст веб-элемента можно двумя способами:
inner_text() - умеет считывать стили и не возвращает содержимое скрытых элементов
element.inner_text()
text_content() - получает содержимое всех элементов, включая <script> и <style>
element.text_content()
all_inner_texts() и all_text_contents() - получить текст всех элементов с одинаковыми локаторами (например строк таблицы)
В результате использования данных методов вернется массив значений для всех соответствующих элементов
Также кроме текста, можно получить HTML-код элемента - inner_html()


Создание скриншота
page.screenshot() - создает скриншот
path - указывает директорию для сохранения скриншота и его имя
page.screenshot(path="screenshot.png") - создает скриншот с именем screenshot.png
page.screenshot(path="/screenshots/test_screenshot.png") - создает скриншот, сохраняет его в папку screenshots с именем test_screenshot.png
full_page - определяет, следует ли создать скриншот всей страницы (True) или только видимой области (False). По умолчанию значение False
page.screenshot(path='test_screenshot.png', full_page=True)
page.locator('.header').screenshot(path='screenshot_of_header.png') - скриншот веб-элемента
type - задает формат изображения. Доступные варианты включают 'jpeg' и 'png'. По умолчанию 'png'
page.screenshot(path='test_screenshot.png', type='jpeg')
quality - качество сжатия изображения для формата jpeg. Должно быть число от 0 до 100. По умолчанию не определено
page.screenshot(path='test_screenshot.png', quality=80)
clip - задает область для создания скриншота, указав координаты x, y и высоту и ширину
page.screenshot(path="clipped_image.png", clip={"x": 50, "y": 0, "width": 400, "height": 300})
omit_background - позволяет убрать бекграунд, фон изображения
Если True, фон на скриншоте будет прозрачным, что актуально в случае формата 'png'. По умолчанию значение False.
page.screenshot(path="transparent_background.png", omit_background=True)
timeout - задает максимальное время ожидания (в миллисекундах) перед созданием скриншота. Значение "0", чтобы ждать неограниченное время. По умолчанию 30000 миллисекунд (30 секунд)
page.screenshot(path="timeout_example.png", timeout=10000)


Работа со вкладками браузера
Playwright открывает новые вкладки в Контексте браузера
Отслеживать открытие окна по определенному событию, (при нажатии на элемент страницы) можно при помощи менеджера контекста with и метода Контекста - expect_page
page.goto("https://zimaev.github.io/tabs/")
with page.context.expect_page() as tab:
    page.get_by_text("Переход к Dashboard").click()

Метод page.context.expect_page() ожидает открытия новой вкладки. Он принадлежит Конексту браузера, так как вкладка открывается в нем
Переменная tab - это обьект класса EventInfo, возвращаемый менеджером контекста with
Этот обьект содержит страницу, открытую в новой табе браузера, а получить к ней доступ можно с помощью свойства value
new_tab = tab.value
print(type(tab)) # <class 'playwright._impl._sync_base.EventInfo'> # Object of the class EventInfo
print(tab) # <playwright._impl._sync_base.EventInfo object at 0x00000222BD2A1010> # Object
print(type(new_tab)) # <class 'playwright.sync_api._generated.Page'> # Object of the class Page
print(new_tab) # <Page url='https://forums.autosport.com/?_gl=1
new_tab - обьект класса Page и ему доступны все его методы и свойства, например - url
assert new_tab.url == "https://zimaev.github.io/tabs/dashboard/index.html?"
Для переключения между табами нужно использовать список всех табов, их индексы и присваивать табы/страницы переменным
page.context.pages - свойство которое возвращает список всех открытых табов в браузере
pages = page.context.pages
first_tab = pages[0] # Присваивание первой страницы браузера переменной
second_tab = pages[1]
second.locator("#headerNav a:has-text('Sign In')").click() # Используя переменную можно работать со страницей
Работать со страницами можно не переключаясь в них, они все равно доступны для Playwright
Но если это нужно, сделать табу активной можно вызвав метод bring_to_front()
first_tab.bring_to_front() # Переключение в первую табу, открыть ее - опционально
second_tab.locator("#headerNav a:has-text('Sign In')").click() # Клик на кнопку в первой вкладке, когда активна вторая, если небыло first_tab.bring_to_front()


Web-first assertions
Встроенные в Playwright методы проверки, которые автоматически ждут появления нужного состояния на странице, вместо того чтобы проверять его сразу
expect(web-element locator).to_be_visible()
Playwright предлагает большой список проверок. За основу проверок в Playwright взята JS библиотека Expect
expect(locator).to_contain_text()
expect(locator).to_have_attribute()
expect(locator).to_have_class()
expect(locator).to_have_count() - Список имеет указанное количество/длину
locator - должен соответствовать веб-элементам, количество которых нужно проверить
ul class="todo_list"
    li class="todo_item"
    li class="todo_item"
    li class="todo_item"
expect(".todo_item").to_have_count(3) # Не сам .todo_list, а айтемы внутри него
expect(page).to_have_url() - Страница имеет URL (URL передается аргументом к проверке)
expect(api_response).to_be_ok() - Ответ имеет статус OK
Сама запись проверки делится на три части:
1. expect() - вспомогательная функция реализующая процесс опроса страницы
Данная функция ожидает(expect), пока что-то станет истинным в течение определенного периода времени
2. В качестве аргумента функции expect() передается проверяемый веб-элемент, страница или ответ от сервера
3. Условие проверки
В свою очередь условие проверки может иметь два варианта записи:
expect(locator).not_to_be_checked() - без передачи в нее аргументов
expect(locator).not_to_contain_text(expected, **kwargs) - с аргументами
expect(locator).not_to_have_attribute(name, value, **kwargs)
Если указаны ожидаемые значения expected, name, value и т.д, то необходимо их передать для проверки
Данные атрибуты определяют какие выражения, значения атрибутов мы будет сравнивать с фактическим результатом
В обычном Python assert проверка происходит мгновенно — если элемента нет в этот момент - тест упадёт
В web-first assertions Playwright повторяет проверку в течение таймаута (по умолчанию 5 секунд)


То есть это не просто "assert", а assert + встроенный wait, что делает тесты стабильнее
wait_for_selector() - ждёт появления элемента (или другого состояния) - wait
assert page.locator("text=Login").is_visible() - assert
expect(web-element locator) - ждёт и сразу проверяет условие (visible, text, enabled и т. д.) - wait + assert
assert page.locator("text=Login").is_visible() - проверка мгновенная, без ожидания
expect(page.locator("text=Login")).to_be_visible() - Playwright подождёт, пока элемент действительно появится (или исчезнет), прежде чем упадёт тест
Вместе с обычным assert используют явное ожидание page.wait_for_selector(web-element selector), что бы дождаться появления элемента и только потом делать проверку
page.goto("https://example.com/form")
page.wait_for_selector("text=Submit") # Сначала явно ждём кнопку (wait_for_selector)
assert page.locator("text=Submit").is_visible() # Затем assert проверяет видимость в данный момент времени

page.goto("https://example.com/form")
expect(page.locator("text=Submit")).to_be_visible() # Автоматически ждёт появления кнопки (по умолчанию до 5 секунд)
Не нужно явно писать wait_for_selector. 

Код короче и стабильнее — встроенный умный retry
wait_for_selector() - ждёт появления элемента (или другого состояния)
expect(web-element locator) - ждёт и сразу проверяет условие (visible, text, enabled и т. д.)
Таймаут у expect(web-element locator) — 5 секунд по умолчанию.

 Но проверка завершается сразу, как только условие выполнено
page.wait_for_selector() - активно ждёт появления указанного события
expect(web-element locator) - периодически проверяет состояние локатора (каждые ~100 мс)
Можно указать свое сообщение об ошибке в качестве второго аргумента функции expect, например
expect(page.get_by_text("Name"), "Сообщение не отображается на странице").to_contain_text("Open Solutions")

В API-тестах или проверках чистой логики (нет веб-элементов) — там web-first не нужен, используется только обычный assert


PWDEBUG и Playwright Inspector
Playwright Inspector помогает создавать и отлаживать сценарии
Чтобы запустить тест в  Playwright Inspector в режиме дебаг, необходимо указать перед тестовой командой префикс PWDEBUG=1
GitBash - PWDEBUG=1 pytest upload,download.py --headed
PowerShell:
$env:PWDEBUG='1' (или просто $env:PWDEBUG=1 ?)
pytest upload,download.py --headed
Удалить переменные среды:
В GitBash - unset PWDEBUG
Проверка - echo $PWDEBUG - должна вернуть пустую строку 
PowerShell - Remove-Item Env:PWDEBUG
Проверка - echo $env:PWDEBUG # Ничего не должно выводиться
Любой вызов page.pause() в тесте автоматически вызывает Inspector, независимо от способа запуска
Чтобы не вводить постоянно значение переменной в терминал, вы можете возможностью устанавливать переменные окружения в запуск теста с помощью Pycharm
1. Откройте меню Run/Debug Configuration в правом верхнем углу и нажмите Edit Configurations...
2. В поле ввода Environment variables: введите нужное имя и значение переменной (PWDEBUG=1) и сохраните конфигурацию
В поле Additional arguments можно добавить --headed
3. Что бы тесты запускались с этой конфигурацией, их нужно запускать не из Терминала (тоесть напрямую через pytest), а из PyCharm
Для этого, справа верху нужно выбрать нужную Конфигурацию (если была создана новая) и нажать на кнопку Play

Для создания новой конфигурации, в окне Run/Debug Configuration нужно нажать на кнопку + и выбрать pytest
В поле Target, что бы запускать тесты:
из одного файла - выбери Script и укажи нужный файл
все тесты из модуля - выбери Module и выбери нужный модуль

Playwright позволяет выделять селекторы в консоли браузера с помощью объекта playwright
Для того чтобы объект playwright стал  доступен в консоли DevTools, нужно запустить тест в режиме отладки - PWDEBUG=console
GitBash - PWDEBUG=console pytest upload_download.py
PowerShell:
$env:PWDEBUG='console'
pytest upload_download.py --headed






Playwright поставляется со встроенными механизмами ожидания при взаимодействии со страницами
Явное ожидание
Если выполнение теста требует появления определенного элемента на странице - можно явно указать playwright дождаться элемента с помощью page.wait_for_selector()
