Pytest — популярный фреймворк тестирования для Python
Он имеет встроенную или плагиноподобную интеграцию со многими системами CI/CD, такими как Jenkins
Pytest имеет опции для генерации junit.xml файлов, которые требуются Jenkins и другим системам непрерывной интеграции для отображения результатов тестирования

Установка Pytest очень проста, поскольку это пакет Python. Для этого выполните следующую команду в CLI (cmd или терминал в PyCharm):
$ pip install -U pytest
После установки вы можете проверить версию Pytest:
$ pytest --version # pytest 7.2.0

Названия тестовых файлов в Pytest должны начинатся или заканчиваться на test_ / _test.py соответственно
Тестовые функции должны начинаться с префикса test_, а тестовые классы с префикса Test
Например: 'def test_my_code():', 'class TestMyCode', 'test_my_code.py'
Попробуйте запустить простой тест, создав test_sample.py файл со следующим содержимым:
def test_sample():
    assert True

При запуске команды pytest, он ищет файлы, начинающиеся на test_ или заканчивающиеся на _test.py
В них ищет функции, начинающиеся на test_, запускает их и проверяет assert внутри них

Запустить тесты в модуле можно следующей командой pytest test_sample.py
Так же можно запустить тесты в нескольких модулях, перечислив их (можно через запятую или пробел) - pytest test_autouse_fixtures.py, test_fixtures.py
Если в ходе выполнения тестов возникла ошибка - анализируя вывод консоли, вы можете определить причину сбоя
Раздел "FAILURES" объясняет, что пошло не так, включая строку неудавшегося утверждения
С другой стороны, раздел "short test summary info" кратко описывает неудавшиеся тесты и утверждение, которое привело к их сбою, не вдаваясь в подробности
Обратите внимание, что тесты отображаются в виде точек - если они пройдены, буквы F - если они провалены или буквы E - если возникла ошибка
collected 2 items
test_mult_function.py F.

Pytest имеет большой набор параметров командной строки, это аргументы, которые можно передать в интерфейс командной строки (CLI) для изменения поведения запущенной программы
В случае Pytest параметры командной строки можно использовать для управления запуском тестов и указания того, какие тесты следует запустить
pytest -h команда позволяет увидеть доступные параметры

Параметры детализации:
-v/–-verbose управляет подробностью вывода Pytest: ход сеанса тестирования, подробности об возникших ошибках
Ее можно использовать несколько раз для управления уровнем детализации: -v, -vv, -vvv
Наиболее очевидным отличием является то, что каждому тесту отводится отдельная строка, а название теста и результат пишутся прописью, а не обозначаются просто точкой
Когда в тесте возникает ошибка, Python выводит на консоль результат команды, вызвавшей ошибку, и ее описание. Это называется трассировкой/traceback
Трейсбек может содержать ценную информацию, которая может помочь диагностировать проблему
--tb параметр управляет подробностью вывода трейсбека
По умолчанию Pytest использует --tb=auto
--tb=short - уменьшает объем информации о неудачных тестах
--tb=line - вся информация о сбое будет представлена ??в одной строке
--tb=no - трассировка о сбоях не будет выводится

Общие параметры:
--collect–only опция отображает только собранные тесты без их выполнения
Эта опция может быть полезна для проверки зависимостей тестового кода перед запуском всего тестового набора
-x/--exitfirst - остановка всего сеанса тестирования, после первого неудачного выполнения теста
--maxfail=num - опция похожа на -x, однако тут можно выбрать после какого количества неудачных тестов остановить весь тестовый сеанс
--maxfail=1, как и -x, сеанс остановится после первого неудачно выполненого теста, --maxfail=3 - после 3-го
По умолчанию Pytest не позволяет печатать в stdout (окно терминала)
-s/--capture=method - опция позволяет печатать операторы print или вообще любой вывод для печати в терминал
--capture=no - позволяет выводить в терминал любой вывод
--capture=sys заменяет sys.stdout/stderr на in-mem файлы
--capture=fd записывает файловые дескрипторы 1 и 2 во временный файл
-l/--showlocals - выводит локальные переменные в тесте, который не пройден
--lf/--last-failed - запускает только не пройденные тесты
--ff/--failed-first - запускает только проваленные тесты, а затем остальные тесты, которые прошли в прошлый раз
Для использования --lf/--last-failed и --ff/--failed-first команд нужно перейти в корневой каналог, где находятся все тесты
-q - опция делает вывод информации о неудачном тесте довольно лаконичным, а в сочетании с --tb=line, вы получите самую короткую версию, которую может предложить pytest

Параметры выполнения теста:
–k <выражение> опция запускает только те тесты, которые соответствуют заданному выражению подстроки, в котором все имена сопоставлены с именами тестов и их родительскими классами
def test_generator_with_correct_values():
def test_generator_start_more_than_finish():
def test_generator_negative_values():
def test_generator_zero_value():
Если вы хотите запустить только тесты, содержащие значение слова, вы можете указать pytest -k "значение"
Команда pytest -k "values" запустит только те тесты, которые содержат слово values в своих именах
Логические операторы (and, or, not) можно использовать вместе с -k опцией
Только тесты, удовлетворяющие обоим условиям, будут запущены, если логический оператори and используется
pytest -k "generator and negative" -v - запустит 1 тест - def test_generator_negative_values()
При использовании логического оператора or, для запуска тестов достаточно, чтобы они удовлетворяли хотя бы одному условию
pytest -k "correct or negative" -v - запустит def test_generator_with_correct_values() и def test_generator_negative_values()


–m marker_name - опция запускает только тесты, соответствующие заданному маркеру
Маркер - это не функция, это специальная метка для обозначения теста или группы тестов
Он не исполняется, не выполняет каких-либо действий (это не функция) и не изменяет поведение теста
Он служит для классификации или фильтрации тестов по определенным, нужным вам, признаками, например тесты связанные с некоторой функциональностью, частью приложения, условиями тестирования
Например @pytest.mark.slow маркер может обозначать, что тесты отмеченные им выполняются медленно/долго
Маркеры применяются к тестам с использованием следующего синтаксиса:
@pytest.mark.marker_name
Чтобы использовать маркеры, необходимо импортировать модуль pytest в тестовый файл, который содержит тесты
Обычно маркеры определяются в pytest.ini файле, в корневом каталоге автоматизированного набора тестов, рядом с conftest.py
Для этого, сначала, в pytest.ini файле, нужно добавить [pytest], а затем в переменной markers перечислить имена используемых маркеров, и через двоеточие, можно указать их краткое описание
[pytest]
markers = 
    duration
    long_running: mark test as a test which takes a long time to run
    critical: mark test as critical
Тест отмеченный маркером выполняется так же как и без него
Неопределенные маркеры не вызывают ошибок, но считается хорошей практикой всегда регистрировать свои маркеры

Pytest предоставляет множество встроенных маркеров
skip - пропускает тесты при тестовом запуске
@pytest.mark.skip(reason="function not developed yet") # Круглые скобки и параметр reason - опциональны
@pytest.mark.skip
def test_count_down_letters(): # Этот тест не будет запущен
    assert count_lower_letters("Hello, World!") == 8
pytest .\test_skip_mark.py -v

skipif - маркер работает так же, как skip, только при соблюдении определенных условий, указанных в качестве первого аргумента маркера
@pytest.mark.skipif(NameError, reason="function not developed yet") # Тест будет пропущен, если в случае его выполнения возникает NameError
Круглые скобки и параметры являются необязательными, но лучше их указывать. Если указано имя ошибки, параметр reason - обязателен
В качестве имени ошибки может быть указанна любая ошибка или родительский класс Exception
@pytest.mark.skipif
def test_count_down_letters():
    assert count_lower_letters("Hello, World!") == 8
pytest .\test_skipif_mark.py -v
Если этот маркер не указать, при запуске данного теста возникнет ошибка NameError: name 'count_lower_letters' is not defined

xfail - отмечает тест, который, как ожидается, провалится
@pytest.mark.xfail(condition='ZeroDivisionError') # condition - опциональный параметр. Его значением должно быть название ошибки
@pytest.mark.xfail
def test_count_down_letters():
    assert count_lower_letters("Hello, World!") == 8 
При неуспешном выполнении тестов с этим маркером их статус будет XFAIL, а без маркера FAILED

parametrize - вызывает одну и ту же тестовую функцию несколько раз с разными параметрами
Это удобное решение, которое избавляет вас от необходимости писать несколько одинаковых тестов
import pytest
from count_functions import count_up_letters
@pytest.mark.parametrize (
    ("words", "result"),
    [
        ("Hello, World!", 2),
        ("Hop-Hey, Lalaley!", 3),
        ("SuNsHiNe", 4)
    ])
def test_count_up_letters(words: str, result: int):
    assert count_up_letters(words) == result
pytest .\test_parameterize_mark.py -v # В результате тест test_count_up_letters будет вызван три раза с указанными в маркере аргументами
Вы также можете создавать свои собственные маркеры, что позволяет вам объединять тесты для определенной функции и запускать их на этой функции

-m "marker_name" - опция позволяет запускать только те тесты, которые отмечены указанным маркером
pytest -m "my_mark" # Будут запущены только тесты отмеченные маркером my_mark
pytest -m "skip" # Только тесты с маркером skip
Однако, для запуска всех тестов, со всеми определенными маркерами, опцию -m можно не указывать и все тесты будут запущены
Эта опция служит только для фильтрации тестов при запуске
import pytest
from count_functions import count_up_letters 
def test_count_up_letters():
    assert count_up_letters("Hello, World!") == 2

@pytest.mark.extend
def test_count_empty_string():
    assert count_up_letters("") == 0

@pytest.mark.extend
def test_count_numbers_signs():
    assert count_up_letters("21+") == 0

pytest -m "extend" -v # В команде не указано имя файла для запуска тестов. И команда запускает только тесты с "extend" маркером находящиеся в текущем каталоге

Если вызов команды pytest указывается с именем модуля - будут запущены тесты из указанного модуля
C:\Users\User\PycharmProjects\TA\M3_Pytest\L3_CLO\3_k_expression_option>pytest test_cube_value.py -v # Будут выполнены тесты из модуля test_cube_value.py
Если конмада pytest вызывается в каталоге с модулями - будут запущены тесты из модулей в этом каталоге
C:\Users\User\PycharmProjects\TA\M3_Pytest\L3_CLO\3_k_expression_option>pytest -v # Будут выполнены тесты из всех модулей в каталоге 3_k_expression_option

Hook (хук) - представляет собой функцию, которая реализует расширение или полное переписывание определенной функции Pytest
Хуки в pytest дозволяють змінювати або розширювати поведінку тестового процесу на різних етапах
Це може бути запуск тестів, до/після виконання тесту, підготовка середовища, збори результатів і т.д
Хук обьявляется в conftest.py файле, а его название начинается с pytest_
По умолчанию Pytest предоставляет 47 общих хуков, которые изменяют его поведение, и пять специальных хуков для отладки
Pytest также предоставляет специальный @pytest.hookimpl декоратор, позволяющий пользователям управлять поведением выполнения хуков, например, сначала запуская функцию по умолчанию и применяя ваше расширение к результату
pytest_addoption(parser, pluginmanager) - используется для добавления дополнительных опций в парсер командной строки Pytest
# content of test_sample.py 
def test_answer(cmdopt):
    if cmdopt == "type1":
        print("first")
    elif cmdopt == "type2":
        print("second")
    assert 0  # to see what was printed

# content of conftest.py 
import pytest 

def pytest_addoption(parser):
    parser.addoption(
        "--cmdopt", action="store", default="type1", help="my option: type1 or type2"
    ) 

@pytest.fixture
def cmdopt(request):
    return request.config.getoption("--cmdopt")

C:\Users\User\PycharmProjects\TA\M3_Pytest\L6_Hooks\1_pytest_addoption>pytest -q --cmdopt=type2 test_sample.py # Вывод в консоли - "second"

pytest_collection_finish(session) - вы можете изменить результаты фазы сбора тестов или добавить пользовательскую логику для сообщения о собранных тестах
Объект сеанса этого хука содержит поле элементов со всеми собранными элементами в плоском списке
Например, вы можете выполнить поиск среди всех элементов с определенным маркером, перебрав список собранных элементов и вызвав get_closest_marker функцию для каждого элемента
def pytest_collection_finish(session):
    keyword = "long_running"

    long_tests_count = sum(1 for test in session.items if any(keyword in marker.name for marker in test.iter_markers()))
    quick_tests_count = len(session.items) - long_tests_count

    print(f"Collected quick tests: {quick_tests_count}, long-running tests: {long_tests_count}") # Выводит количество тестов у которых в названии маркера есть "long_running"
 
У одного теста может быть несколько маркеров ?

pytest_sessionfinish(session, exitstatus) - вызывается после завершения всего тестового прогона, прямо перед возвратом статуса выхода в систему
Этот хук может использоваться для выполнения различных действий, связанных с результатами тестового прогона, таких как создание отчетов, обновление статусов и отправка уведомлений
Используя этот хук, вы можете получить доступ к объекту session, который содержит информацию о всей тестовой сессии, например, общее количество выполненных тестов, количество пройденных и неудачных тестов и продолжительность тестового прогона
Вы также можете получить доступ к exitstatus аргументу, представляющему статус завершения тестового запуска

pytest_generate_tests(metafunc) - вы можете создавать динамически сгенерированные тесты, расширяя схему параметризации, предоставляемую по умолчанию Pytest
Для этого вы можете использовать pytest_generate_tests хук, который вызывается при сборе тестовой функции
Через переданный metafunc объект, вы можете проверить запрашиваемый тестовый контекст, и, что самое важное, вы можете вызвать metafunc.parametrize() параметризацию
# content of test_strings.py 
def test_valid_string(stringinput):
    assert stringinput.isalpha()

# content of conftest.py 
def pytest_addoption(parser):
    parser.addoption(
        "--stringinput",
        action="append",
        default=[],
        help="list of stringinputs to pass to test functions",
    ) 

def pytest_generate_tests(metafunc):
    if "stringinput" in metafunc.fixturenames:
        metafunc.parametrize("stringinput", metafunc.config.getoption("stringinput"))

C:\Users\Maksym_Korniichuk\PycharmProjects\TA\M3_Pytest\L6_Hooks\2_pytest_generate_tests>pytest -q --stringinput="hello" --stringinput="world" test_strings.py

Фикстуры - это функции, которые Пайтест выполняет перед началом теста, а их результаты передаются в тело теста
Фікстури використовуються для підготовки передумов, які потрібні для тестів
Вони можуть створювати об'єкти, відкривати/закривати ресурси, ініціалізувати стани і т.д.
Вы можете использовать фикстуры для подготовки тестового набора данных, установки соединения с базой данных или переключения системы тестирования в желаемое состояние перед запуском теста
Фикстуры могут быть общими и использоваться несколькими тестами
Они передаются как параметры в тестовые функции и не могут вызываться отдельно, как обычная функция
Для обьявления Фикстур используется декоратор @pytest.fixture()
@pytest.fixture()
def ultimate_question_answer():
    return 42
Когда имя фикстуры передается как параметр в тестовую функцию, Пайтон знает, что ее нужно выполнить перед началом теста
def test_some_data(ultimate_question_answer):
    """Use fixture return value in a test"""
    assert ultimate_question_answer == 42

Иногда фикстуры нужно выполнять в режиме установки-удаления, например, когда некоторые соединения с БД должны быть установлены, а затем изящно закрыты
Для реализации такой функциональности Пайтест имеет yield фикстуры
yield фикстура выполняет до запуска теста и после его окончания
@pytest.fixture()
def ultimate_question_answer():
    print("Set Up")
    yield 42
    print("Teardown")

Фикстуры включают необязательный параметр, называемый областью действия (scope), который контролирует, как часто фикстура вызывается и выключается
Параметр области действия может иметь значения function, class, module, session
scope = 'function' - это значение запускается один раз для каждой тестовой функции
Часть настройки запускается перед каждым тестом с использованием фикстуры
Часть удаления запускается после каждого теста с использованием фикстуры
Это значение области действия используется по умолчанию, когда не указан параметр области действия
scope = 'class' - это значение выполняется один раз для каждого тестового класса, независимо от того, сколько тестовых методов содержится в классе
Если в классе несколько тестовых функций, фикстура будет выполнена только 1 раз
scope = 'module' - это значение выполняется один раз для каждого модуля, независимо от того, сколько тестовых функций, методов или других объектов в модуле его используют
scope = 'session' - это значение запускается один раз за сеанс. Все методы и функции тестирования, использующие фикстуру области сеанса, разделяют один вызов настройки и удаления

Еще один необязательный параметр Фикстур - params
Значением этого параметра должен быть итерируемый обьект (список, словарь, кортеж, сет, строка)
Нужно помнить, что Кортеж из 1 элемента принимается как этот элемент, а не кортеж
Тест, для которого применяется фикстура с параметром params, будет выполнен столько раз, сколько элементов в последовательности params
p = [1, 2, 100]
@pytest.fixture(params=p)
def with_params():
    return p

def test_plus_with_valid_args2(with_params):
    assert plus(with_params[0], with_params[1]) == 3 # Тест будет выполнен 3 раза, потому что последовательность params содержит 3 элемента

Фикстуры можно обьявлять в отдельных тестовых файлах
Для использования одной определенной фикстуры в нескольких файлах, вместо обьявления в каждом файле, ее можно обьявить в файле conftest.py, в корне проекта
Фикстуры из conftest.py файла доступны для всех тестов в каталоге
Таким образом, conftest.py файл позволяет централизовано хранить фикстуры, что б не повторять их в каждом тестовом файле, где нужно их использовать
Это позволяет избежать дублирования кода и упрощает поддержку тестов
Если фикстура обьявленна не в conftest.py, а в другом тестовом файле, то независимо от указанного scope, она будет применятся только к тестам в этом файле
# conftest.py
import pytest

@pytest.fixture
def sample_data():
    return {'name': 'John', 'age': 30}

# test_example.py
def test_name(sample_data): # Фикстура обьявленная в conftest.py файле, в корне каталога, доступна для использования во всех тестовых файлах этого каталога
    assert sample_data['name'] == 'John'

Флаг autouse=True позволяет фикстуре автоматически применятся ко всем тестовым функциям, без необходимости явно ее указывать в параметрах тестовых функций
С autouse=True фикстура будет автоматическим применятся ко всем тестам, в указанной области действия (scope, по умолчанию равен 'function')
# conftest.py
import pytest

@pytest.fixture(autouse=True)
def setup_database():
    print("Підключення до бази даних")
    # Ти можеш виконати налаштування, які потрібні для кожного тесту
    yield
    print("Закриття з'єднання з базою даних")
Фикстура setup_database() будет автоматически применятся ко всем тестовым функциям во всех тестовых файлах, без необходимости явно ее указывать (передавать как параметр в тестовые функции)

# conftest.py
import pytest

@pytest.fixture(autouse=True, scope="module")
def setup_module():
    print("Налаштування для модуля (виконується один раз для всього модуля)")
    yield
    print("Закриття після виконання тестів модуля")
В этом примере, фикстура будет автоматически применятся один раз ко всем тестам в каждом модуле

# conftest.py
import pytest

@pytest.fixture(autouse=True, scope="module")
def setup_module():
    print("Налаштування для модуля (виконується один раз для всього модуля)")
    yield
    print("Закриття після виконання тестів модуля")

# test_example.py
def test_1():
    print("Тест 1")
    assert True

def test_2():
    print("Тест 2")
    assert True

def test_3():
    print("Тест 3")
    assert True

Результат: scope='module', поэтому фикстура вызовется один раз ко всем тестам в модуле, а благодаря autouse=True ее ненужно явно передавать в тестовые функции
Налаштування для модуля (виконується один раз для всього модуля)
Тест 1
Тест 2
Тест 3
Закриття після виконання тестів модуля

Но, если фикстура возвращает какое-либо значение, даже при наличии autouse=True, ее нужно явно передавать как параметр в функцию, иначе значение не будет доступно в тестовой функции
# conftest.py
import pytest

@pytest.fixture(autouse=True, scope="module")
def setup_module():
    print("Налаштування для модуля")
    return 22

# test_example.py
def test_1(setup_module): # Фикстура setup_module() возвращает значение, и что б оно было доступно в тестовых функциях ее нужно явно туда передавать
    print(f"Тест 1: {setup_module}")  # Використовуємо значення фікстури
    assert setup_module == 22

def test_2(setup_module):
    print(f"Тест 2: {setup_module}")  # Використовуємо значення фікстури
    assert setup_module == 22

def test_3(setup_module):
    print(f"Тест 3: {setup_module}")  # Використовуємо значення фікстури
    assert setup_module == 22

Результат:
Налаштування для модуля
Тест 1: 22
Тест 2: 22
Тест 3: 22

Таким образом, параметры autouse=True и scope не подходят для фикстур, которые возвращают значение, потому что их все равно прийдется явно передавать как параметры в тестовые функции

Тестовые функции в качестве параметров могут принимать только Фикстуры

При запуске тестов с использованием Pytest любые сообщения логирования уровня WARNING или выше, генерируемые во время выполнения теста, автоматически фиксируются Pytest
Затем Pytest отображает эти захваченные сообщения в отдельном разделе для каждого неудачного теста
Они могут использоваться для предоставления дополнительной информации о тестовом запуске и любых проблемах, которые могли возникнуть
Таким образом, Pytest предоставляет удобный и централизованный способ просмотра всей соответствующей информации о тестовом запуске, что упрощает отладку и устранение любых возникающих проблем
По умолчанию в каждом записанном сообщении журнала отображается модуль, номер строки, уровень журнала и сообщение
При необходимости можно указать формат журнала и дату для всего, что поддерживает модуль логирования, передав определенные параметры форматирования:
pytest --log-format="%(asctime)s %(levelname)s %(message)s" \ 
        --log-date-format="%Y-%m-%d %H:%M:%S"
Эти параметры также можно настроить с помощью pytest.ini файла
[pytest]
log_format = %(asctime)s %(levelname)s %(message)s 
log_date_format = %Y-%m-%d %H:%M:%S
[pytest] - указывает, что следующие параметры относятся именно к настройкам Pytest и должны быть применены при запуске тестов
Це секція конфігурації, яка дозволяє налаштовувати різні параметри тестів, як-от: рівень логування, параметри виконання тестів, шляхи до тестових файлів тощо
Без этого, Pytest не будет знать, что это его конфигурация/настройки и может их не применить
log_format - формат вывода сообщений
%(asctime)s - время, когда было записано сообщение
%(levelname)s - уровень логирования, например DEBUG, WARNING, ERROR, INFO
%(message)s - само сообщение
log_date_format - формат даты и времени, который используется для %(asctime)s
%Y — рік (4 цифри),
%m — місяць (2 цифри),
%d — день місяця (2 цифри),
%H — година (2 цифри, від 00 до 23),
%M — хвилина (2 цифри),
%S — секунда (2 цифри)

--show-capture=no - отключает отчетность по захваченному контенту (stdout, stderr и журналы) при неудачных тестах