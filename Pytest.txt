Pytest — популярный фреймворк тестирования для Python
Он имеет встроенную или плагиноподобную интеграцию со многими системами CI/CD, такими как Jenkins
Pytest имеет опции для генерации junit.xml файлов, которые требуются Jenkins и другим системам непрерывной интеграции для отображения результатов тестирования
Установка Pytest очень проста, поскольку это пакет Python. Для этого выполните следующую команду в CLI (cmd или терминал в PyCharm):
$ pip install -U pytest
После установки вы можете проверить версию Pytest:
$ pytest --version # pytest 7.2.0
Все тестовые функции и файлы в Pytest должны начинаться с префикса test_, а тестовые классы должны начинаться с префикса Test
Например: 'def test_my_code():', 'class TestMyCode', 'test_my_code.py'
Попробуйте запустить простой тест, создав test_sample.py файл со следующим содержимым:
def test_sample():
    assert True
Запустить тест можно следующей командой pytest test_sample.py
Если в ходе выполнения тестов возникла ошибка - анализируя вывод консоли, вы можете определить причину сбоя
Раздел "FAILURES" объясняет, что пошло не так, включая строку неудавшегося утверждения
С другой стороны, раздел "Short test summary" кратко описывает неудавшиеся тесты и утверждение, которое привело к их сбою, не вдаваясь в подробности
Обратите внимание, что тесты отображаются в виде точек, если они пройдены, или буквы F, если они провалены
collected 2 items
test_mult_function.py F.
Pytest имеет большой набор параметров командной строки, это аргументы, которые можно передать в интерфейс командной строки (CLI) для изменения поведения запущенной программы
В случае Pytest параметры командной строки можно использовать для управления запуском тестов и указания того, какие тесты следует запустить
pytest -h команда позволяет увидеть доступные параметры

Параметры детализации:
-v/–-verbose управляет подробностью вывода Pytest: ход сеанса тестирования, подробности об возникших ошибках
Ее можно использовать несколько раз для управления уровнем детализации: -v, -vv, -vvv
Наиболее очевидным отличием является то, что каждому тесту отводится отдельная строка, а название теста и результат пишутся прописью, а не обозначаются просто точкой
Когда в тесте возникает ошибка, Python выводит на консоль результат команды, вызвавшей ошибку, и ее описание. Это называется трассировкой
Трассировка может содержать ценную информацию, которая может помочь диагностировать проблему
--tb параметр управляет трассировкой
По умолчанию Pytest использует --tb=auto
--tb=short - уменьшает объем информации о неудачных тестах
--tb=line - вся информация о сбое будет представлена ​​в одной строке
--tb=no - трассировка о сбоях не будет выводится

Общие параметры:
--collect–only опция отображает только собранные тесты без их выполнения
Эта опция может быть полезна для проверки зависимостей тестового кода перед запуском всего тестового набора
-x/--exitfirst - остановка всего сеанса тестирования, после первого неудачного выполнения теста
--maxfail=num - опция похожа на -x, однако тут можно выбрать после какого количества неудачных тестов остановить весь тестовый сеанс
--maxfail=1, как и -x, сеанс остановится после первого неудачно выполненого теста, --maxfail=3 - после 3-го
По умолчанию Pytest не позволяет печатать в stdout (окно терминала)
-s/--capture=method - опция позволяет печатать операторы print или вообще любой вывод для печати в терминал
-l/--showlocals - выводит локальные переменные в тесте, который не пройден
--lf/--last-failed - запускает только не пройденные тесты
--ff/--failed-first - запускает только проваленные тесты, а затем остальные тесты, которые прошли в прошлый раз
Для использования --lf/--last-failed и --ff/--failed-first команд нужно перейти в корневой каналог, где находятся все тесты
-q - опция делает вывод информации о неудачном тесте довольно лаконичным, а в сочетании с --tb=line, вы получите самую короткую версию, которую может предложить pytest

Параметры выполнения теста:
–k <выражение> опция запускает только те тесты, которые соответствуют заданному выражению подстроки, в котором все имена сопоставлены с именами тестов и их родительскими классами
def test_generator_with_correct_values():
def test_generator_start_more_than_finish():
def test_generator_negative_values():
def test_generator_zero_value():
Если вы хотите запустить только тесты, содержащие значение слова, вы можете указать pytest -k "значение"
Команда pytest -k "values" запустит только те тесты, которые содержат слово values в своих именах
Логические операторы (and, or, not) можно использовать вместе с -k опцией
Только тесты, удовлетворяющие обоим условиям, будут запущены, если логический оператори and используется
pytest -k "generator and negative" -v - запустит 1 тест - def test_generator_negative_values()
При использовании логического оператора or, для запуска тестов достаточно, чтобы они удовлетворяли хотя бы одному условию
pytest -k "correct or negative" -v - запустит def test_generator_with_correct_values() и def test_generator_negative_values()

–m <MARKEXPR> - опция запускает только тесты, соответствующие заданному маркеру
Маркеры применяются к тестам с использованием следующего синтаксиса:
@pytest.mark.<markername>
Чтобы использовать маркеры, необходимо импортировать модуль pytest в тестовый файл
Pytest предоставляет множество встроенных маркеров
skip -  пропускает тесты при тестовом запуске
@pytest.mark.skip (reason="function not developed yet")
def test_count_down_letters(): # Этот тест не будет запущен
    assert count_lower_letters("Hello, World!") == 8
pytest .\test_skip_mark.py -v
skipif - маркер работает так же, как skip, только при соблюдении определенных условий, указанных в качестве первого аргумента маркера
@pytest.mark.skipif(NameError, reason="function not developed yet") # Тест будет пропущен, если в случае его выполнения возникает NameError
def test_count_down_letters():
    assert count_lower_letters("Hello, World!") == 8
pytest .\test_skipif_mark.py -v
Если этот маркер не указать, при запуске данного теста возникнет ошибка NameError: name 'count_lower_letters' is not defined
xfail - отмечает тест, который, как ожидается, провалится
@pytest.mark.xfail
def test_count_down_letters():
    assert count_lower_letters("Hello, World!") == 8 
При неуспешном выполнении тестов с этим маркером их статус будет XFAIL, а без маркера FAILED
parametrize - вызывает одну и ту же тестовую функцию несколько раз с разными параметрами
Это удобное решение, которое избавляет вас от необходимости писать несколько одинаковых тестов
import pytest
from count_functions import count_up_letters
@pytest.mark.parametrize (
    ("words", "result"),
    [
        ("Hello, World!", 2),
        ("Hop-Hey, Lalaley!", 3),
        ("SuNsHiNe", 4)
    ])
def test_count_up_letters(words: str, result: int):
    assert count_up_letters(words) == result
pytest .\test_parameterize_mark.py -v # В результате тест test_count_up_letters будет вызван три раза с указанными в маркере аргументами
Вы также можете создавать свои собственные маркеры, что позволяет вам объединять тесты для определенной функции и запускать их на этой функции
Чтобы запустить их на определенном маркере, используйте -m вариант
Если маркер для -m опции отсутствует в коде — все тесты будут пропущены
Обычно маркеры определяются в pytest.ini файле, в корневом каталоге автоматизированного набора тестов, рядом с conftest.py 
Неопределенные маркеры не вызывают ошибок, но считается хорошей практикой всегда регистрировать свои маркеры
import pytest
from count_functions import count_up_letters 
def test_count_up_letters():
    assert count_up_letters("Hello, World!") == 2

@pytest.mark.extend
def test_count_empty_string():
    assert count_up_letters("") == 0

@pytest.mark.extend
def test_count_numbers_signs():
    assert count_up_letters("21+") == 0

pytest -m "extend" -v # В команде не указано имя файла для запуска тестов. А команда запускает только тесты с "extend" маркером находящиеся в текущем каталоге

Если вызов команды pytest указывается с именем модуля - будут запущены тесты из указанного модуля
C:\Users\User\PycharmProjects\TA\M3_Pytest\L3_CLO\3_k_expression_option>pytest test_cube_value.py -v # Будут выполнены тесты из модуля test_cube_value.py
Если конмада pytest вызывается в каталоге с модулями - будут запущены тесты из модулей в этом каталоге
C:\Users\User\PycharmProjects\TA\M3_Pytest\L3_CLO\3_k_expression_option>pytest -v # Будут выполнены тесты из всех модулей в каталоге 3_k_expression_option