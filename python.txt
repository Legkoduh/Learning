Перевірити чи встановленний Пайтон на ПК:
Open the command line or PowerShell and type in: python --version
Якщо Пайтон встановленний на ПК - буде показана його версія, якщо ні - нічего

Перейти в інтерпритатор Пайтон в Командній строці або PowerShell:
Open the command line or PowerShell and type in: python
cls - to clear the cmd or PowerShell (not the Python interpreter)

PyCharm - інтегрована середа розробки (IDE) для Пайтон

В Пайтон все сущности - обьекты (даже число и строка - экземпляры классов)
Обьект - это экземпляр определенного класса
Класс - это шаблон, каркас для создания обьектов
Аттрибут обьекта, значение которого функция - метод

Типы данных в Пайтон:
int - целые числа (3, 0, -1)
str - строки ('Hi')
bool - логические значения (только true и false)
list (список) - набор данных (могут быть разных типов) через запятую в квардратных скобках ([1, 2, 3, 'Hi', true])
dict (словарь) - набор элементов, которые состоях из пары: ключ, значение, в фигурных скобках ({'min': 1, 'max': 3})

name = 'Bogdan'
name - переменная значение которой строка (str)
name - обьект типа строка, обьект класса строка (str)

Что бы вызвать функцию, к ее названию нужно добавить пару круглых скобок - myFn()
Методы обьектов вызываются с помощью точечной записи - name.upper()
Метод dir возвращает имена/названия/ключи всех аттрибутов обьекта

Встроенные (built-in) методы Пайтон:
print, input, dir, any, all...
all(итерируемый обьект) - возвращает True если все элементы последовательность (переданного аргумента) являются правдивыми (имееют значение True)
any(итерируемый обьект) - возвращает True если хотя бы 1 элемент последовательность является правдивым
all([1, True, [2, 'name']]) # True
all([1, tuple(), [2, 'name']]) # False - пустой набор приравнивается к False
any([0, tuple(), False]) # False
any([1, True, [2, 'name']]) # True

Для выполнения кода Пайтон в терминале с использованием интерпретатора Пайтон - python3 main.py
Вместо 3 можно ввести любую другую нужную версию Пайтон
В JS - node main.js

Для разделения блоков кода во многих ЯП используются фигурные скобки {}
В Пайтон для этого используют отступы (4 пробела)
Работает и с 1-3 пробелами, но это не соответствует PEP8 (общепринятым правилам в Пайтон)
def show(text):
    print(text)


show('Hello from PyCharm')

Некоторые выдержки из PEP8:
Функции и классы должны быть отделены от других строк кода 2 пустыми строками
Файл с кодом должен заканчиваться 1 пустой строкой
Импорт каждого модуля должен быть на отдельной строке
Для отступов использовать 4 пробела, а не Tab
Длина строк должна быть менее 79 символов

Formatting Python code in the VS Code
Отфарматировать код под условия PEP8:
Ctrl+Shift+P
Fill in the appeared input field with "Format" word
Select "Format Document With..."
Select "Python"
Instal the Formatter "autopep8" if it's not installed yet

Set necessary formatter by default:
Ctrl+Shift+P
Select "Format Document With..."
Click on the "Configure Default Formatter..."
Choose "Python"

Automatically formatting of the file after saving the file:
Ctrl+,
Fill in the appeared input field with "Format on save" text
Activate a checkbox in the "Editor: Format On Save" block
The Formatter "autopep8" should be installed before

Комментарии игнорируются интерпретатором Пайтон
Комментарии добавляются при помощи знака решетки #
Многострочные комментарии можно сделать с использованием тройных одиранрых или двойных кавычек

Функции в Пайтон определяются при помощи ключевого слова def
После def идет название функции и круглые скобоки, а затем ставиться двоеточие, после которого идет блок кода функции
Тело функции, как и другие отдельные блоки кода, отделено от остального кода 4 пробелами слева
Параметр функции (name) - это переменная, которая указывается в круглых скобках, после названия функции, при ее обьявлении
Аргумент функции ('Bogdan') - это значение, которым инициализируется параметр функции
Параметру присваивается значение агрумента в момент вызова функции
def hello(name):
    print('Hi', name)
    print("How are you ?")

hello('Bogdan')

return - ключевое слово, инструкция, которая используется в функциях для возвращения значения из них
По умолчанию, в Пайтон, любая функция без ключевого слова return, возвращает None (в JS - undefined)
print(print('Bogdan'))
# Bogdan - результат вызова print('Bogdan')
# None - результат вызова функции print аргументом которой является значение, которое вернула print('Bogdan'), а она ничего не возвращает (нет return)
Как только функция доходит до слова return - она возвращает значение (если оно указано) и далее не выполняется, прекращает свою работу
Код, который находится после ключевого слова return, не будет выполнен

При обьявлении функции, можно указать тип данных для ее параметров. В Пайтон это называется аннотацией параметров
Для этого, после имени параметра следует поставить двоеточие и указать необходимый тип данных
def check(a: int, name: str, greeting: str):
Так же можно указать тип данных для результата, который возвращает функция - аннотация
Для этого, после закрывающей круглой скобки с параметрами нужно поставить стрелочку и указать нужный тип данных для результат функции, а затем двоеточие
def check(a: int, name: str, greeting: str) -> str:
Однако аннотация не является правилом и парметры, возвращаемое функцией значение могут иметь другой тип данных, нежели указан в аннотации к ним в функции

Из функции можно вернуть сразу несколько значений, в кортеже
Это можно указать в аннотации функции при ее обьявлении, после стрелочки указывается тип возвращаемого значения - tuple
Далее квадратные, а не круглые, как используются для кортежа, скобки и в них - типы возвращаемых значений через запятую, и вконце - двоеточие
Если вместо типа tuple указать list - все равно будет возвращен кортеж, а return будет подсвечен с предупреждением Expected type 'list[int, bool]', got 'tuple[{__gt__}, bool]' instead
Если вместо квадратных указать круглые скобки, будет выброшена ошибка - TypeError: tuple expected at most 1 argument, got 2

def return_two(a, b) -> tuple[int, bool]:
    if a > b:
        return a, True
    return b, False

print(return_two(3, 2)) # (3, True)

Звездочка в параметрах функци означает, что все дальнейшие параметры при вызове функции, должны быть именоваными аргументами, а не позиционными
def check(a, *, name, greeting): - a может быть позиционным или именованным аргументом, а name и greeting - только именованными
  print(a)
  print(f"{greeting}, {name}!")

# Правильний виклик функції
check('Hi', name = "Олексій", greeting = "Привіт") # Hi		Привіт, Олексій!
check(a = 'Hi', name = "Олексій", greeting = "Привіт") # Hi		Привіт, Олексій!

# Неправильний виклик функції (викличе помилку)
check('Hi', "Олексій", "Привіт") # TypeError: check() takes 1 positional argument but 3 were given



Выражение (expression) всегда возвращает значение
Функция - возвращает результат работы функции либо None,
5+4 - возвращает 9,
'Hello ' + 'World!' - возвращает новую строку "Hello World",
a>b - возвращает True или False
Все это выражения, так как они возвращают какое-то значение
Проверить, является ли часть кода выражением можно используя функцию print
Если блок кода является выражением - его результат будет выведен в консоль, а если нет - произойдет ошибка
print('Hello ' + 'World') > 'Hello World'
print(if True: print('Hi')) > error: expected expression

Инструкция (statements) выполняет действия
Создание/обьявление функции
my_name = 'Bogdan' - создание переменной
if True:
    print ('Hi') - логическая инструкция
import datetime
return result
print(import datetime) > error: expected expression
В JS создание переменной - выражение, которое возвращает undefined

Переменные дают возможность повторного доступа к значениям
snake_case используется для переменных, функций, методов и модулей
UPPER_SNAKE_CASE - для констант
PascalCase - для классов
dash-case - для пакетов
Пакеты - это наборы модулей

В Пайтон, обьявление переменной и присвоение ей значения происходит на 1 строке
name = 'Bogdan'
Эти действия нельзя разделять, это ошибка
name
name = 'Bogdan'
> error: name 'name' is not defined
Если переменная с таким же именем уже была создана ранее, то ее значение просто перезапишется/изменится
name = 'Kirilo'
name = 'Bogdan'
Пайтон - язык с динамической типизацией
Это значит, что одной и то й же переменной могут быть присвоенны значения разных типов (и даже функция)
val = 3
val = 'value'
val = True

В Пайтон отсутствуют примитивные типы данных (как например в JS - number ?)
Все сущности - обьекты
При создании переменной со значением целого числа, в памяти создается обьект класса int, значение которого указанное целое число
В Пайтон типы данных/обьекты делятся на изменяемые (mutable) и неизменяеммые (immutable)
Неизменяемый обьект нельзя изменить, можно только создать новый, с таким же названием и другим значением
Изменяемый тип можно изменять/мутировать (добавлять/удалять элементы, менять значение элементов), так как он сохраняется в памяти
К неизменяемым типам данных относятся: str, int, bool, float, None (имеет единственное значение None), tuple (кортеж), range
Изменяемые: list, dict, set, objects of user-defined classes (экземпляры классов созданных пользователем)

При создании переменной в памяти создается обьект
Переменная содержит/является ссылкой на этот обьект в памяти
Если переменной присвоить другое значение, то будет создан новый обьект, а старый, через некоторое время, будет удален Пайтон
Если переменной присвоить другую, ранее созданную переменную, то новый обьект не будет создаваться. Новая переменная будет проинициализированна ссылкой ранее созданной переменной
date = 09012024 - создается новый обьект в памяти. Переменная date не содержит значение 09012024, она содержит ссылку на обьект в памяти со значением 09012024
my_name = 'Bogdan' - создается обьект в памяти
my_name = 'Kirilo' - создается новый обьект в памяти, а предыдущий будет удален
my_name = 'Bogdan' - создается обьект в памяти
new_name = my_name - переменная new_name проинициализированна ссылкой в переменной my_name, новый обьект не создается
new_name и my_name содержат одну и ту же ссылку на один обьект в памяти со значением 'Bogdan'
Узнать адресс обьекта в памяти можно при помощи встроенной в Пайтон функции id, которая в качестве параметра принимает название переменной
my_name = 'Bogdan'
print(id(my_name)) > 140719189080568
my_name = 'Kirilo'
print(id(my_name)) > 140719189080760
Ссылки на разные обьекты в памяти
my_name = 'Bogdan'
new_name = my_name
print(id(my_name)) > 140719189080568
print(id(new_name)) > 140719189080568
Ссылка на 1 обьект в памяти
При каждом запуске программы ссылки могут менятся, так как переменные создаются заново и заново записываются в память, попадая в ее новую область

Строка - это последовательность символов
Строка является экземпляром класса str
Строка - неизменяемым тип данных
Строку в несколько строк можно создать при помощи 3 одинарных или двойных кавычек """/'''
longStr = """multi
rows
string"""
Встроенная функция type - возвращает класс, обьектом которого является переменная переданная в качестве аргумента
print(type(longStr)) > class 'str'
Строка находится в обьекте, который является экземпляром класса str
Если функция type возвращает type (class 'type') - это значит что аргумент, переданный ей, сам является классом
type(str) > class 'str'
len - встроеная функция которая возвращает длину последовательности переданной как аргумент
print(len(longString)) > 17
Строка является упорядоченной последовательностью, а для них можно использовать синтаксис с квадратными скобками
В скобках указываются индексы нужных символов
longStr[0] = 'm' - первый символ строки начиная с начала
longStr[-1] = 'g' - первый символ строки с конца
Так же можно выделять последовательности из строк, используя квадратные скобки и двоеточие (slice)
longStr[start:stop:step] - шаг при этом не обязателен
longStr[6:11] = 'rows' - набор символов с индекса 6 по 11
longStr[:11] - начало пропущено, поэтому старт начинается с индекса 0, набор символов с начала, по символ с индексом 11
longStr[3:] - стоп пропущен, поэтому окончание будет крайним элементом строки, с индекса 3 и до крайнего
longStr[:] - вся строка
longStr[::-1] # gnirts swor itlum - точка шага устанавливается на -1
Python интерпретирует срез как каждый элемент от конца до начала. Минус означает из конца в начало
Разделить строку на список символов можно при помощи встроенной функции list, которая в качестве аргумента принимает последовательность
my_str = 'Awesome'
print(list(my_str)) # ['A', 'w', 'e', 's', 'o', 'm', 'e']

Целые числа являются экземпляром класса int
С помощью встроенной функции int можно конвертировать числа в формате строки в тип данных int
int('3') > 3
Для удобства чтения, большые числа, в Пайтон, можно разделять одним нижним подчеркиванием
bigInt = 1_00_0_0_0_0
print(bigInt) > 1000000
print(type(bigInt)) > class 'int'
smallInt = 1_1
print(smallInt) > 11
Если в функцию int будет передана строка, которая содержит не только числа, то будет выброшена ошибка и выполнение кода остановится на строке с этим вызовом int
int('Hi') > error
invalidInt = 1_0_00__0_00_0 > error (разрешено только 1 нижнее подчеркивание)

Числа с десятичной точкой являются экземплярами класса float
val = 10.5
print(type(val)) > class 'float'
Встроенный метод float позволяет конвертировать строки и числа других типов в тип float
str_val = '10.5'
float(str_val) > 10.5
Встроенный метод round округляет числа с десятичной точкой
round(7.5) > 8
round(8.5) > 8, round(val) > 10 ?

Комплексные числа являются экземплярами класса complex
Комплексное число состоят из действийтельной (целое число) и мнимой (число с j) частей
complex_a = 7 + 8j
complex_b = 9 + 7j
Сложение и вычитание комплексных чисел
complex_a + complex_b = 9 + 15j
complex_a - complex_b = 5 + 1j
Умножение комплексных числел более сложное
complex_a * complex_b = (7 + 8j)*(9 + 7j) = 7*9 + 7*7j + 8j*9 + 8j*7j = 63 + 49j + 72j + 56j^2
Мнимая часть в квадрате равна -1
56*j^2 = 56 * -1 = -56
63 + 49j + 72j - 56 = 7 + 121j

Логические значения являются экземпляром класса bool
Логический тип имеет всего 2 значения: True, False
type(True) # class 'bool'
Логический тип часто используется для проверки правдивости выражений: больше, меньше, сравнивания
print("Long string" > 'Short') # False - строки сравниваются посимвольно, а не их длина
print("Long string" > 'Long') # True - так как первый и 3 последующих символа совпадают
print("Long string" > 'long string') # False - L не соответствует l
print([1, 2, 3] == [1, 2, 3]) # True (в JS, Java - это 2 разных обьекта и поэтомму будет возвращено False)
При помощи встроенной функции bool любое значение можно конвертировать в тип bool
print(bool('Hi')) # True
print(bool(-1)) # True
print(bool(0)) # False
print(bool('')) # False
print(bool([])) # False (true в JS)
print(bool({})) # False (true в JS)
print(bool(None)) # False
print(9 > 2) # True - тут не используется конвертация в тип bool при помощи встроенной функции bool, потому что логический тип является результатом такого выражения (сравнения)

Пайтон не выполняет неявную конвертацию типов значений
В JS это доступно для строк и чисел: '1'+1 > '11', 8+(+'1') > 9
Если тип значения нужно конвертировать в другой, вы должны это сделать сами/явно, используя соответствующие встроенный функции
int(), str(), float(), list(), tuple(), set()
При операциях с некоторыми разными типами, в Пайтон, ошибка не выкидывается
int_num = 2
float_num = 1.9
int_num + float_num # 3.9
Под капотом, знак + заменяется на магический метод __add__ класса int
int_num.__add__(float_num)
В результате возвращается строка Not implemented, которая означает, что в классе int не реализована возможность сложения целого числа и дроби
После этого операнды меняются местами, вызывается метод __radd__ класса float и возвращается результат - 3.9
float_num.__radd__(int_num) # 3.9
Методы __add__ и __radd__ есть в обоих классах int и float, однако в каждом классе они работают по разному
В классе int, __add__ принимает в качестве аргумента только значения типа int, а в классе float, метод __radd__ значения типа float
В методе __radd__ класса float значения типа int конвертируются в тип float путем добавления точки и нулевой дробной части - .0

True + 2 # 3 - bool + int = int
True - 1, False - 0

str_val = 'abc'
int_num = 50
int_num * str_val # строка в которой 'abc' повторяется 50 раз
str_val * int_num # так же строка в которой 'abc' повторяется 50 раз
Это из-за того, что оба метода __mul__, __rmul__ в классе str, в качестве аргумента принимают целое число
str_val.__mul__(int_num) # строка в которой 'abc' повторяется 50 раз
int_num.__mul__(str_val) # Not implemented
str_val.__rmul__(int_num) # строка в которой 'abc' повторяется 50 раз
str_val.__rmul__('Hi') и str_val.__mul__('Hi') - вернут ошибки, так как в качестве аргумента передана строка, а не целое число

Методы имена которых начинаются и заканчиваются на 2 нижних подчеркивания ( __ ) называются магическими
Магические методы являются внутренними методами классов и вызываются неявно/под капотом, при использовании различных операторов (+, -, *, /)
[1, 2, 3].__eq__([1, 2, 3]) # True
В данном примере вызывается магический метод __eq__ класса list
Узнать, как работает магический метод можно при использовании функции help
help(list.__eq__) # описание метода __eq__ класса list
Многие магические методы определены сразу в нескольких классах, например метод __add__ есть в классах int, float, str

Список - упорядоченная последовательность элементов
Порядок элементов в списке имеет значение
Элементы в списке могут быть различных типов
post_ids = [155, 254, 762, 859]
post_ids2 = [254, 155, 762, 859]
post_ids == post_ids2 # False
Каждый элемент в списке имеет свой уникальный индекс, и начинается от с 0
Получить элемент с помощью его индекса можно используя его в квадратных скобках
makes_list[3] # 859
Если в квадратных скобках указывать индексы со знаком минус - будут выводится элементы начиная с конца списка
makes_list[-1] # 'Toyota'
Список относится к изменяемым типам данных
Изменять значения элементов можно при помощи индекса в квадратных скобках
post_ids[0] = 189
post_ids # [189, 254, 762, 859]
При изменении значения элемента списка не создается новый список, а мутируется текущий
Это можно проверить при помощи встроенной функции id
id(post_ids) # 2925927848128
post_ids[1] = 555
id(post_ids) # 2925927848128
Для удаление определенного элемента списка используется ОПЕРАТОР del
del post_ids[2]
post_ids # [189, 254, 859]
del post_ids[-1] - удаление последнего элемента списка при помощи отрицательного индекса
post_ids # [189, 254]
Элементы в список можно добавлять при помощи уже имеющихся переменных
post1_id = 36
post2_id = 87
post3_id = 111
new_posts_ids = [post1_id, post2_id, post3_id]
new_posts_ids # 36, 87, 111
Пайтон подставит значения переменных в соответствующие места в списке
Для доступа к значению словаря в квадратные скобки передается ключ в его исходном формате. Строка - строка, bool - bool и тд
vals_list = [{'one': 1, 'two': 2, 'three': 3, True: 'Hi'}, [1, 2, 3], True]
vals_list[0]['three'] # 3 - получить доступ к значению словаря, с ключем типа строка, внутри списка
vals_list[0][True] # 'Hi'
В JS это так же можно делать при помощи точечной записи, так как все ключи в обьектах являются строками - vals_list[0].three
При обращении к элементу за пределами списка, по ключу, который больше длины списка - будет выброшена ошибка индекса
vals_list[10] # IndexError: list index out of range - индекс 10 находится за границами списка, так как его длинна 3
Методы списков:
1.) append - добавляет переданный параметр в конец списка,
2.) insert - принимает 2 параметра, 1ый - это индекс в списке, а 2ой - значение, которое нужно вставить в список по указанному индексу
Элементы списка, которые находятся после указанного индекса сдвигаются вправо на 1
3.) pop - удаляет элемент из списка
Может вызыватся с параметром и без
Если параметр не указан - удаляет последний элемент списка, если параметр передается - он используется в качестве индекса по которому удаляется элемент списка
Метод pop возвращает удаленный элемент, поэтому он может быть присвоен переменной
post_ids = [189, 254, 387, 543, 859]
removed_val = post_ids.pop()
removed_val # 859
post_ids # [189, 254, 387, 543]
post_ids(0) # 189
post_ids # [254, , 387, 543]
4.) sort - может быть вызван с именованным параметром и его значением и без парметра
Если вызывается без параметра - список сортируется по возростанию
Если передан именованный параметр reverse и значение True - сортируется по убыванию
post_ids = [859, 254, 387, 189, 543]
post_ids.sort() # [189, 254, 387, 543, 859]
post_ids.sort(reverse=True) # [859, 543, 387, 254, 189]
5.) insert - вставляет элемент в список
Принимает 2 параметра: 1-ый - индекс элемента в списке, перед которым нужно вставить значение, переданное как 2-ой параметр
arr = [1, 2, 3, 5, 8, 9, 11]
arr.insert(3, 4)
arr # [1, 2, 3, 4, 5, 8, 9, 11]
sorted - встроенный метод позволяет упорядочить последовательность, по умолчанию - по возрастанию
l = [10, 2, 8, 7, 3, 9, 4, 6, 5]
soterd(arr) # [2, 3, 4, 5, 6, 7, 8, 9, 10]
В список (list) можно конвертировать другие последовательности (строки, словари) при помощи встроенного метода list
greetings = 'Hello all'
list(greetings) # ['H', 'e', 'l', 'l', 'o', ' ', 'a', 'l', 'l']
При конвертации словаря в список, добавляются только ключи, а значения теряются
vals_dict = {a: 3, b: 5, c: 7, d: 8, e:9, f: 11}
list(vals_dict) # [a, b, c, d, e, f]
Для арифметических операций со списками используются методы min, max, sum
post_ids = [189, 254, 387, 543, 859]
max(post_ids) # 859
Соеденить несколько списков в один можно при помощи оператора +
Это возможно благодаря тому, что под капотом, оператор + заменяется на вызов магического метода __add__ класса list, который умеет соединять списки
post_ids = [189, 254, 387, 543, 859]
keys = [a, b, c, d, e, f]
post_ids + keys # [189, 254, 387, 543, 859, a, b, c, d, e, f]
Добавить список в конец другого списка можна так же используя метод extend()
first_list = [1, 2, 3, 4, 5]
second_list = [6, 7, 8, 9, 10, 11]
first_list.extend(second_list)
first_list # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Часть списка можно получить указав в квадратных скобках, разделив двоеточием, индекс нужного первого элемента и индекс, до которого, нужны элементы
post_ids = [189, 254, 387, 543, 859]
post_ids[1:3] # [254, 387]
post_ids[-3:5] # [387, 543, 859]
post_ids[1:-1] # [254, 387, 543]
Скопировать список, как отдельный обьект, можно 3 способами:
newarr = arr.copy()
newarr = list(arr)
newarr = arr[:]
Копирование путем присвоения 1 списка другому приводит к копированию ссылки в новую переменную, а не созданию нового, отдельного обьекта
newarr = arr
id(newarr) == id(arr) # True

Словарь - обьект класса dict, это не упорядоченная последовательность элементов, где каждый элемент состоит из пары: ключ, значение
Ключ отделяется от значения двоеточием, а элементы разделены запятыми
Ключи словаря могут быть объектами любого хешируемого типа данных (стандартные хешируемые типы данных в Пайтон - это неизменяемые типы), зачастую используется тип str
Ключи в словарях - уникальны и не могут повторятся
Если добавить пару ключ-значение, у которой ключ уже есть в словаре - в таком случае его текущее значение просто перезапишется на новое
Значение может быть любого типа: другой словарь, список, функция и тд
Создать словарь можно при помощи фигурных скобок или встроенной функции dict()
Если она вызывается без аргументов - будет создан пустой словарь
empty_dict = dict() # {}
Но она так же может принимать аргумент, который должен быть последовательность пар (ключ и значение)
new_d = dict([('one', 1), ('two', '2'), ('three', True)])
print(new_d) # {'one': 1, 'two': '2', 'three': True}
Так же, в качестве аргументов, можно передавать пары ключ-значение с оператором присваивания просто через запятую
new_dict = dict(one=1, two='two', three=True)
new_dict # {'one': 1, 'two': 'two', 'three': True}
my_car = {
	'make': 'BMW',
	'model': 5,
	'fast': True
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'}
}
Порядок элементов в списке - не важен (в отличии от строк и списков)
my_car_again = {
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'},
	'make': 'BMW',
	'fast': True,
	'model': 5,
}
my_car == my_car_again # True - порядок ключей разный, но их названия, количество и значения - одинаковые
В Пайтон сравнить 2 разных обьекта можно при помощи оператора сравнения ==
not_my_car = {
	'make': 'BMW',
	'model': 5,
	'fast': False
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'}
}
my_car == not_my_car # False - значения у одного из ключей разные
Для доступа к значениям ключей используются квадратные скобки и нужный ключ внутри них. Ключ передается как строка
my_car['make'] # 'BMW'
Синтаксис с точечной записью не доступен для ключей списков в Пайтон, (доступен в JS), так как они не являются аттрибутами, а данный синтаксис работает только с ними
my_car.make # NameError
То, что ключи словаря не являются аттрибутами можно подтвердить при помощи метода dir
dir(my_car) # будут выведены аттрибуты, обычные и магические методы класса dict, а make, model, fast и specs - отсутствуют
Этот же синтаксис используется для:
изменения значений существующих ключей в словарях
my_car['model'] = 'X5'
добавления новых
my_car['price'] = 70000
и удаления ключей и, соответственно, их значений
Но для этого необходим оператор del
del my_car['fast']
Переменные можно использовать для:
1.) создания словарей
make = 'brand'
model = 'model'
cost = 'price'
my_car = {
    make: 'BMW',
    model: 'X5',
    cost: 90000
}
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 90000}
2.) добавления новых ключей в словарь
painted = 'color'
wheels = 'tires'
my_car[painted] = 'black'
my_car[wheels] = 21
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 90000, 'color': 'black', 'tires': 21}
3.) добавления новых значений
is_fast = True
year = 2024
my_car['fast'] = is_fast
my_car['produced'] = year
{'brand': 'BMW', 'model': 'X5', 'price': 90000, 'color': 'black', 'tires': 21, 'fast': True, 'produced': 2024}
4.) или изменения значений, если такой ключ уже есть в словаре
price = 85000
my_car['price'] = price
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 85000, 'color': 'black', 'tires': 21, 'fast': True, 'produced': 2024}
Количество элементов в словаре можно получить при помощи встроенной функции len
len(my_car) # 7
Если попытаться использовать ключ, которого нет в словаре - будет выброшена ошибка ключа и выполнение кода остановится
my_car['engine_volume'] # KeyError
Если вы не уверены, что ключ есть в словаре, можно использовать метод словарей get.
Если ключа нет в словаре - он вернет None, если есть - его значение. Тоесть в любом случае ошибки не будет и выполнение кода не будет остановлено
my_car.get('engine_volume') # None
В случае, когда ключ отсутсвует, значение по умолчанию None можно заменить на любое другое, указав его после названия ключа и запятой, в вызове метода get
my_car.get('engine_volume', 'Absent) # 'Absent'

Методы словарей:
1.) my_dict.keys() - возвращает обьект класса dict_keys, который содержит список из ключей словаря my_dict
# dict_keys(['first', 'second', 'third'])
2.) my_dict.values() - возвращает обьект класса dict_values, к	оторый содержит кортеж из значений словаря my_dict
# dict_values(['one', 'two', 3])
3.) my_dict.items() - возвращает обьект класса dict_items, который содержит список кортежей, каждый из которых содержит пару ключ и значение словаря my_dict
# dict_items([('second', 'two'), ('first', 'one'), ('third', 3)])
4.) copy() - метод для создания нового словаря на основе другого (копирования)
new_dict = my_dict.copy()
Созданный словарь в результате вызова метода copy является новым, отдельным обьектом
id(my_dict) == id(new_dict) # False
5.) update() - метод принимает другой словарь или некоторую коллекцию пар ключ-значение в качестве аргумента и обновляет все соответствующие пары в исходном словаре, а также добавляет пары ключ-значение для ключей, которых нет в исходном словаре:
d = {
    "name": "Filip",
    "age": 32,
    "is_registered": False,
    "rate": 12.5,
    "total_score": 200,
    "linked_ids": [1, 45, 98]
}
blank_d = {
    "name": "",
    "age": 0,
    "is_registered": False,
    "rate": 0,
    "new_key": 'New',
    "total_score": 0,
    "linked_ids": []
}
d.update(blank_d)
print(d) # {'name': '', 'age': 0, 'is_registered': False, 'rate': 0, 'total_score': 0, 'linked_ids': [], 'new_key': 'New'} - значения в исходном словаре обновлены значениями аргумента функции update и добавлена новая пара ключ-значение
Создать новый словарь можно на основе последовательности, в которой есть 2 значения, они будут интерпретированы как ключ и значение
1.) Списка списков
dict1 = dict([['first', 1], ['second', 'two'], ['third', True]])
2.) Списка кортежей
dict2 = dict([('first', 1), ('second', 'two'), ('third', True)])
3.) Кортежа кортежей
dict3 = dict((('first', 1), ('second', 'two'), ('third', True)))
4.) Списка в котором есть списки и кортежи
dict4 = dict([('first', 1), ['second', 'two'], ['third', True]])
5.) Кортежа в котором есть списки и кортежи
dict5 = dict((['first', 1], ('second', 'two'), ('third', True)))
Все 5 списков - {'first': 1, 'second': 'two', 'third': True}
Для создания словаря из 1 пары ключ, значение, с помощью кортежа кортежей, нужно после 1-го элемента поставить запятую
tuple1 = (('first', 1))
dict6 = dict(tuple1) # Error
tuple1 = (('first', 1),)
dict7 = dict(tuple1) # {'first': 1}

Кортеж (tuple) - обьект класса tuple - это упорядоченная последовательность элементов
Порядок элементов в кортеже важен
tuple1 = (1, 2, 3, 5)
tuple2 = (3, 1, 2, 5)
tuple1 == tuple2 # False - элементы одинаковые, но их последовательность - разная
Кортеж является не изменяемым типом данных, тоесть в него нельзя добавить или удалить новые элементы
tuple[4] = 7 # TypeError
del tuple[1] # TypeError
Изменять элементы кортежа можно только в том случае, если их тип данных - изменяемый
tuple1[3] = 'Three' # TypeError - тип данных int - не изменяемый, поэтому выпадает ошибка
tuple3 = ([1, 2, 3], [5, 7, 8], [9, 11, 18])
tuple3[0][2] = 'Three'
tuple3 # ([1, 2, 'Three'], [5, 7, 8], [9, 11, 18]) - list, как и dict, set - изменяемые типы данных, поэтому их в Кортеже можно изменить и ошибки не будет
Функция len доступна и для Кортежей и возвращает их длину
Обьеденять кортежи можно при помощи оператора +
В такой способ соединять кортежи и списки нельзя
У Кортежа 2 метода:
1.) count - возвращает количество раз сколько переданный аргумент встречается в Кортеже
2.) index - возвращает индекс переданного аргумента
Может принимать 1 или 2 аргумента, где 1-ый - элемент индекс которого ищем, 2-ой - индекс с которого начинать поиск этого элемента
tuple1 = (1, 2, 3, 4, 5, 3, 8, 9, 11)
tuple1.index(3, 4) # 5 - ищем индекс элемента 3 начиная с индекса 4
tuple1[5] # 3
Если аргумент встречается в Кортеже несколько раз - будет возвращен индекс первого такого элемента
Если такого аргумента нет в Кортеже - будет выброшена ошибка
Метода get Кортежей нет
Последовательность элементов можно конвертировать в Кортеж используя встроенную функцию tuple()
list1 = [1, 2, 3]
tuple1 = tuple(list1)
type(tuple1) # tuple
Если Кортеж нужно изменить, его можно конвертировать в список, при помощи функции list, изменить, а затем конвертировать обратно в Кортеж используя функцию tuple
При конвертации словаря в Кортеж добавляются только ключи, а значения теряются
vals_dict = {a: 3, b: 5, c: 7, d: 8, e:9, f: 11}
tuple(vals_dict) # (a, b, c, d, e, f)

Для создания Кортежа с одним значением, нужно добавить запятую после этого значение, иначе интерпретатор поймет это как арифметическое выражение, потому, что скобки используются как оператор приоритета
my_tuple = (1,)
print(type(my_tuple)) # <class tuple>
my_tuple = (1)
print(type(my_tuple)) # <class int>

Кортежу доступны операции распаковки и упаковки
(a, b, c) = (40, 56.6, 90)
print(a, b, c) # 40 56.6 90
Кортеж (a, b, c) формируется операцией упаковки, когда разделенные значения собираются в одно
И поскольку элементы кортежа записаны как переменные, эти переменные инициализируются
Переменные a, b, c инициализируются каждая отдельным значением потому, что кортеж (40, 56,6, 90) неявно разделяется/распаковывается на отдельные значения — 40, 56,5 и 90
a, b, c = 40, 56.6, 90 # Так же круглые скобки можно опустить
print(a, b, c) # 40 56.6 90
Это хороший способ объявить несколько переменных в одном действии и в одной строке кода
Распаковку можно вызвать с помощью специального оператора распаковки *
my_tuple = 40, 56.6, 90
print(my_tuple) # (40, 56.6, 90)
print(*my_tuple) # 40, 56.6, 90
Так же, операции упаковки и распаковки удобно использовать когда нужно двум переменным переставить их значения
a, b = 1, 2
print(a, b) # 1, 2
b, a = a, b
print(a, b) # 2, 1

Набор (set) - неупорядоченная последовательность элементов, экземпляр класса set
Порядок элементов в Наборе не имеет значения и поэтому у элементов нет индексов
Это потому что у класса Set нет магического метода __getItem__
posts = {'Hi', True, 3, 5.5}
posts[0] # Error
Элементы в Наборе - уникальны. При добавлении элемента, который уже есть в набое - он не будет добавлен
Если дубликаты добавлены в Набор во время создания, далее они будут удалены
name = {'Alan', 'Audren', 'Alan', 'Roman', 'Andrey', 'Kirilo', 'Roman'}
print(name) # {'Alan', 'Audren', 'Roman', 'Andrey', 'Kirilo'}
Набор - изменяемый тип данных
Набор не может содержать изменяемые типы данных: list, dict, set, только не изменяемые
posts = {'Hi', True, 3, 5.5}
type(posts) # class 'set'
У Набора есть длина и определить ее можно при помощи встроенной фукнции len
len(posts) # 4
Каждому элементу в наборе, под капотом, генерируется хэш
При добавлении нового элемента или обьединении нескольких наборов, все хэши сравниваются и если есть 2 и более одинаковых - то их соответствующие элементы удаляются из Набора
new_set1 = {1, True, 10.5, 'Hi', (1, 2, 3)}
new_set2 = {3, (5, 9, 11),'Hi'}
Операции с Наборами в Python можно выполнять двумя способами: с помощью операторов (|, &, -) или методов
Но есть разница, когда вам нужно работать с любым итерируемым типом в качестве аргумента, например, множествами и списками
Оператор работает только с Наборами, а метод может принимать в качестве аргумента любой итерируемый тип
s1 = {"a", "d", "h"}
s2 = {"n", "b", "c", "d"}
s3 = ["c", "d"]
union1 = s1 | s2 | s3
print(union1) # TypeError: unsupported operand type(s) for |: 'set' and 'list'
union2 = s1.union(s2, s3)
print(union2) # {'h', 'a', 'n', 'b', 'd', 'c'}
Методы Наборов:
1.) add - добавляет новый элемент в Набор
2.) union - обьеденяет 2 Набора и удаляет все дубликаты
Так же вместо union можно использовать оператор или |
s1 = {"a", "d", "h"}
s2 = {"n", "b", "c", "d"}
s3 = {"c", "d"}
union1 = s1 | s2 | s3
print(union1) # {'h', 'a', 'n', 'b', 'd', 'c'}
union2 = s1.union(s2, s3)
print(union2) # {'h', 'a', 'n', 'b', 'd', 'c'}
Результирующий набор содержит все элементы из s1, s2 и s3 без дубликатов
3.) intersection - возвращает Набор, который содержит только те элементы, которые присутствуют в обоих Наборах
Так же можно использовать оператор &
Это симметричный/зеркальный метод, поэтому его можно применять как к Набору 1, так и к Набору 2 и результат будет одинаковый
new_set1.intersection(new_set2)
new_set1 & new_set2
s1 = {"a", "d", "h"}
s2 = {"n", "b", "c", "d", "a"}
s3 = {"n", "a", "d"}
my_intersection1 = s1 & s2 & s3
print(my_intersection) # {'a', 'd'}
my_intersection = s1.intersection(s2, s3)
print(my_intersection2) # {'a', 'd'}
Результирующий набор содержит элементы, представленные в каждом указанном наборе, и он одинаков для обоих вариантов
В качестве аргумента метод принимает любое итерируемое значение: строку, список, словарь
При передаче словаря, сравнение будет проводиться с его ключами
4.) issubset - проверяет включен ли 1-ый Набор во 2-ой (являеться ли 1-ый Набор подмножеством 2-го)
Все элементы подмножества должны быть в супермножестве. Если нет хотя бы 1 - метод вернет False
new_set1 = {3, True, 10.5, 'Hi', (1, 2, 3)}
new_set2 = {1, True,'Hi'}
new_set2.issubset(new_set1) # False - значения 1 нет в new_set1
new_set2 = {3, True,'Hi'}
new_set2.issubset(new_set1) # True
5.) issuperset - проверяет включает ли 1-ый Набор в себя 2-ой (являеться ли 1-ый Набор супермножеством 2-го)
6.) difference - возвращает разницу двух множеств, элементы которые не повторяются, уникальны в 2-х множествах
Вместо этого метода, для Наборов, можно использовать оператор минус -
s1 = {"a", "d", "h", "c", "j"}
s2 = {"n", "b", "c", "d", "a"}
s3 = {"n", "a", "d"}
my_difference1 = s1 - s2 - s3
print(my_difference1) # {'h', 'j'}
s1 = {"a", "d", "h", "c", "j"}
s2 = {"n", "b", "c", "d", "a"}
s3 = {"n", "a", "d"}
my_difference2 = s1.difference(s2, s3)
print(my_difference2) # {'h', 'j'}
Результирующий набор содержит элементы из первого набора, которые не представлены в других наборах
7.) discard - удаляет переданное значение из Набора
Если переданного элемента нет в Наборе - ошибки не будет
8.) remove - удаляет переданное значение из Набора
Работает как и discard, однако, если аргумента нет в Наборе - будет выброшена ошибка
9.) symmetric_difference (симетричная разница) - возвращает уникальные элементы двух Наборов
Элементы которые есть в Наборе 1, но нет в Наборе 2 и элементы которые есть в Наборе 2 и отсуствуют в первом Наборе
set1 = {'a', 'b', 'c', 'd'}
set2 = {'a', 'b', 'c', 'e'}
set1.symmetric_difference(set2) # {'e', 'd'} - 'е' есть в set2, но нет в set1, 'd' есть в set1, но нет в set2
Так же это можно сделать обьеденив 2 Набора в один, а затем отняв от него пересекающиеся элементы (которые есть в 2-х Наборах)
(set1 | set2) - (set1 & set2) # {'d', 'e'}
(set1.union(set2)) - (set1.intersection(set2)) # {'d', 'e'}
10.) update - метод изменяет значение исходного набора на объединение с указанными наборами (схож с union)
s1 = {"a", "b", "k"}
s2 = {"a", "d", "h"}
s3 = {"n", "b", "d"}
s1.update(s2, s3)
print(s1) # {'d', 'a', 'h', 'b', 'k', 'n'} - Набор s1 обьеденен сs2, s3
11.) clear - полностью очищает Набор
s1 = {"a", "b", "k"}
s1.clear()
print(s1) # set() - Пустой Набор
Проверка членства в наборах происходит значительно быстрее
a = 5
my_set = set([1, 2, 3, 1, 2, 5])
if a in my_set:
    print(f"The {a} value is in the set")
Если нужно работать с Набором, как с неизменяемым типом, можно использовать тип данных - frozenset

Диапазон (range) - упорядоченная неизменяемая последовательность элементов, обьект класса range
Создать диапазон используя только какие либо скобки нельзя, для этого нужно использовать одноименную фукнцию конструктор - range
В качестве аргумента эта функция принимает целое число
Аргументов может быть 1, 2 или 3
Первый аргумент указывает с какого числа начинать итерирование/отсчет
Второй - верхняя не досягаемая граница, число до которого будет произведен отсчет, не включая его
Третий - шаг, число на которое будет увеличиваться каждый элемент диапазона начиная с 1-го, при каждой итерации
Если шаг не указан, по умолчанию, он равен 1
my_range1 = range(3) - итерирование с 0 до 2, потому что верхняя граница не включается, последний элемент такого Диапазона - 2 # 0, 1, 2
my_range2 = range(10, 20) - итерирование с 10 до 19
my_range3 = range(10, 20, 2) - с 10 до 19, увеличивая каждый элемент на 3 # 12, 14, 16, 18
Элемента 20 в таком Диапазоне не будет, так как это уже верхняя граница, а она не включается, инкрементация элементов идет до нее
Диапазон можно конвертировать в список, при помощи встроенной функции list
В таком случае будет произведена итерация, в соответствии с переданными аргументами, и все полученный элементы будут добавлены в список
list(my_range3) # [10, 12, 14, 16, 18]
Обьект класса range часто используют в цикле for
count = range(3, 10)
for i in count:
    print(i)
Для цикла for, шаг с созданием обьекта range можно пропустить и сделать это прямо в цикле
for i in rage(3, 10)
    print(i) # 3, 4, 5, 6, 7, 8, 9
У Диапазонов 2 метода:
count - возвращает 1 если переданный аргумент есть в Диапазоне
index - возвращает индекс переданного аргумента, если он есть в Диапазоне и выбрасывает ошибку если его нет
Что бы не получить ошибку при использовании метода index, перед ним лучше проверить наличие аргумента в Диапазоне при помощи метода count
my_range = range(10, 30, 4)
val = 26
check = my_range.count(val)
# print(my_range.index(val)) ValueError: 19 is not in range
if check:
    print(my_range.index(val))
else:
    print('The element is not in range')

Типы данных в Пайтон:
1.) int - неизменяемый
2.) float - неизменяемый
3.) str - неизменяемый и упорядоченный тип данных
4.) None - неизменяемый
5.) bool - неизменяемый
6.) dict - изменяемый тип данных и неупорядоченный
7.) list - изменяемый, упорядоченный
8.) tuple - неизменяемый и упорядоченный
9.) set - изменяемый и неупорядоченный
10.) range - неизменяемый и упорядоченный

В Python все является объектом
Объект в Python можно считать хешируемым, если класс этого объекта реализует несколько специальных методов, которые позволяют получить хеш-значение
Все неизменяемые типы в Python также хешируемы
Однако некоторые пользовательские типы могут быть изменяемыми и хешируемыми одновременно. Это зависит от реализации их классов
some_tuple = (1, 2, 3)
print(hash(some_tuple)) # 529344067295497451
Хэш — это просто некоторое целочисленное значение
Самое главное, что это значение останется неизменным, даже если внутреннее состояние объекта изменилось

zip - встроенная функция, которая обьеденяет несколько последовательностей в 1. При этом последовательности могут быть разных типов (list, tuple, str)
В результате использования этой функции будет получет обьект zip, который затем можно конвертировать в другой тип/последовательность (list, tuple, dict)
Длина последовательностей-аргументов может быть разной
Длина результирующей последовательности (обьекта zip) будет равна длине самой короткой последовательности из переданных аргументов
arr = ['BMW', 'Audi', 'Mercedes', 'VW']
kortej = (30, 20, 35) - длина 3
set1 = {'Hi', 'Hello', 'Hola', 'Wazzap'}
zipped1 = zip(arr, kortej, set1)
print(zipped1) # <zip object at 0x000001BD8A84FB00> - обьект zip и его место в памяти
print(list(zipped_list)) # [('BMW', 30, 'Hola'), ('Audi', 20, 'Hello'), ('Mercedes', 35, 'Hi')] - список кортежей длиной 3
Для конвертации zip обьекта в словарь, он должен быть получен на основании только 2-х аргументов
Первый аргумент будет определен как ключи, а второй - значения
zipped2 = zip(arr, kortej)
print(dict(zipped_dict)) # {'BMW': 30, 'Audi': 20, 'Mercedes': 35}
print(dict(zipped1)) # ValueError: dictionary update sequence element #0 has length 3; 2 is required - элементы zip-обьект состоят из 3-х, а не 2-х значений
Конвертировать обьект zip в другой тип можно только 1 раз. Для последующих конвертаций можно использовать результат 1-ой конвертации
zipped3 = zip(arr, set1)
print(dict(zipped3)) # {'BMW': 'Hola', 'Audi': 'Hello', 'Mercedes': 'Wazzap', 'VW': 'Hi'} - первая конвертация успешна
print(list(zipped3)) # [] - можно использовать результат первой конвертации присвоив его переменной

Все переменные в Пайтон хранят ссылку на обьект в памяти
При создании новой переменной значение которой неизменяемого типа, Пайтон проверяет память и если находит обьект с таким же значение, то не создает новый обьект, а присваивает переменной ссылку на уже существующий
val1 = 10
val2 = 10
val3 = 10
print(id(val1)) # 140718936898264
print(id(val2)) # 140718936898264
print(id(val3)) # 140718936898264
print(id(10)) # 140718936898264 - указывает на ранее созданный обьект, так как у них идентичные значения
У val1, val2 и val3 - одинаковые значения не изменяемого типа, поэтому все они ссылаються на 1 и тот же обьект в памяти, а не на разные
Но, при изменении обьекта неизменяемого типа - создаеться новый обьект, а старый остаеться без изменений
val1+=5
print(id(val1)) # 140718936898424 - место в памяти именилось, так как это новый обьект
print(id(val3)) # 140718936898264 - место в памяти не изменилоь, это тот же обьект что и был
val4 = 15
print(id(val4)) # 140718936898424 - val1 и val4 ссылаються на 1 обьект, так как их значения одинаковые

При создании переменных значения которых изменяемого типа - каждый раз создаеться новый обьект в памяти, даже если значения идентичны
arr1 = [1, 2, 3]
arr2 = [1, 2, 3]
print(id(arr1)) # 2801734046080
print(id(arr2)) # 2801734047936 - значения одинаковые, но тип данных - изменяемый, поэтому создаються 2 разных обьекта
Таким образом изменения переменной arr1 не будут отражаться на arr2
arr1.append(4)
arr1 # [1, 2, 3, 4]
arr2 # [1, 2, 3]
При копировании обьектов изменяемых типов используя оператор равно - копируеться ссылка на обьект и обе переменные указывают на 1 обьект
arr3 = arr1
print(id(arr3)) # 2801734046080 - тот же обьект что и у переменной arr1
При таком копировании изменения переменной arr1 будут применены и для arr3
arr1.append(5)
arr1 # [1, 2, 3, 4, 5]
arr3 # [1, 2, 3, 4, 5]
Создать новый, отдельный обьект, на основании уже существующего можно при помощи встроенной функции copy
arr4 = arr3.copy()
print(id(arr3)) # 2801734046080
print(id(arr4)) # 2099065305344 - 2 разных обьекта
Но метод copy не создает новые обьекты для вложенных обьектов, а копирует их ссылку
obj = {	'author': 'Bogdan',
       	'instructor': True,
       	'reviews': [] }
new_obj = obj.copy()
obj['reviews'].append('Python')
print(obj['reviews']) # ['Python']
print(new_obj['reviews']) # ['Python'] - изменения свойста reviews обьекта obj произошли в таком же свойсте в обьекте new_obj, хотя они отдельные, независимые обекты
Это из-за того что метод copy не создает новые обьекты для вложенных свойст, а просто копирует их ссылку. Создает копию верхнего, 1-го уровня, поверхностную (shallow)
Для создания полность новой копии изменяемого обьекта можно использовать метод deepcopy модуля copy, который нужно импортировать в файл программы
from copy import deepcopy
full_new_obj = deepcopy(obj)
obj['reviews'].append('Typescript')
print(obj['reviews']) # ['Python', 'Typescript'] - добавляем к изменяемому обьекту review в обьекте obj новый элемент
print(new_obj['reviews']) # ['Python'] - изменения не применились к вложенному изменяемому обьекту reviews (list) в обьекте full_new_obj
Новый обьект созданный при помощи метода deepcopy являеться отдельным новым обьектом и все его вложенные обьекты так же

Функция - это блок кода который можно вызывать многократно
Обьявление функции в Пайтон начинается с ключевого слова def
Далее следует имя функции (присвоение функции переменной), круглые скобки с параметрами (они опциональны) и двоеточие
def my_func(a, b):
Тело функции отделяеться отступом
Функция, как и все в Пайтон, это обьект и каждая функция являеться экземплятор класса function
Параметры - это переменные доступные только внутри функции, а аргументы - это значения и они могут меняться в каждом вызове функции
Значение параметрам функции передаеться при ее вызове с аргументами. Параметры инициализируються значениями аргументов. Значения аргументов присваиваються параметрам
Ключевое слово pass (заглушка) используеться тогда, когда в блоке кода еще нет строк кода (мы их еще не написали). В таком случает без использования слова pass будет выброшена ошибка
Все переменные в Пайтон (изменяемые и неизменяемые) - это обьекты которые хранят ссылки на соответствующие обьекты в памяти
При вызове функции с аргументами, в качестве аргументов передаються ссылки на эти обьекты в памяти, а не значения
Если аргументы неизменяемые типы/обьекты - то при их изменении в теле функции создаються новые обьекты (потому что это неизменяемый тип данных)
В таком случае изменить внешнюю переменную невозможно
val1 = 10
print(id(val1)) # 140718564195032 *
def check (a):
	print(id(a)) # 140718564195032 * - все еще обьект val1
	a += 1
	print(id(a)) # 140718564195064 - создался новый обьект
	return a

res = check(val1)
print(res) # 11 - функция вернула измененное значение
print(val1) # 10 - но значение переданного аргумента осталось без изменений, так как это неизменяемый тип данных
print(id(res)) # 140718564195064 - новый обьект, созданный в ходе изменения переданного аргемента
print(id(val1)) # 140718564195032 * - обьект аргумента не изменился
def multiple_lines(text, num):
  text = text * num
  print(text)

text = 'external text'
multiple_lines(text, 3) # external textexternal textexternal text
print(text) # 'external text' - значение переменной за пределами функции не изменилось, потому что она неизменяемого типа
В функции была создана новая локальная переменная text и ей было присовено новое значение external textexternal textexternal text (text * num = 'external text' * 3)

Но, при передаче изменяемых обьектов - изменяеться обьект, ссылка на который передана
Таким образом после вызова функции изменяется внешний обьект, который был обьявлен до функции
def check1(arr):
	print(id(arr)) # 2420286148992 - обьект переданный как аргумент
	arr.append(4)
	print(id(arr)) # 2420286148992 - тот же обьект, переданный как аргумент. Он не изменился, не создался новый, так как это изменяемый тип данных, он может изменяться
	return arr

ar = [1, 2, 3] - внешний обьект
print(id(ar)) # 2420286148992 - тот же обьект, переданный как аргумент
res = check1(ar)
print(res) # [1, 2, 3, 4] - результат вызова функции
print(id(res)) # 2420286148992 - тот же обьект
print(arr) # [1, 2, 3, 4] - значение внешнего обьект изменилось после/в вызова функции
print(id(arr)) # 2420286148992 - обьект не изменился, а его значение изменилось
Что бы измежать изменения внешних обьектов, если они изменяемых типов данных (dict, list, set), внутри функции можно их копировать в новую переменную при помощи функции copy или deepcopy, в зависимости от того, есть ли у обьекта вложенные изменяемые обьекты
Или копировать обьект прямо в вызове функции
check1(ar.copy())
check1(deepcopy(ar))

В вызове функции количество аргументов должно совпадать с количеством параметров этой функции, заданых при ее обьявлении
Что бы функцию можно было вызывать с неопределенным количеством аргументов, при ее обьявлении, возле параметра нужно указать оператор звездочки *
Это упакует все аргументы в новый кортеж
def my_fn(*args):
В таком случае все аргументы будут собраны в Кортеж и с ним можно будет работать
my_fn(1, 2, 3) - не вызовет ошибку, внутри функции будет создан Кортеж (1, 2, 3)
my_fn(1) - Кортеж (1)
my_fn(1, 2, 3, 5, 8, 9, 11) - (1, 2, 3, 5, 8, 9, 11)
Аргументы бывают позиционные и именованные
Позиционными называються аргументы порядок (позиция) которых, при вызове функции, важен. Если изменить их порядок - результат вызова функции измениться
def show_str(a, b):
    print(f"{a} has {b} posts")
show_str('Bogdan', 25) # Bogdan has 25 posts - ожидаемый результат
show_str(25, 'Bogdan') # 25 has 25 Bogdan - из-за неправильного порядка аргументов результат не правильный
Именованные аргументы указываються при вызове функции вместе с соответствующими названиями параметров этой функции и символом равно (=)
Порядок именованных аргументов (аргументов с ключевыми словами) не важен, так как переданные значения будут присвоенны указанным параметрам
show_str(a='Bogdan', b=25) # Bogdan has 25 posts
show_str(b=25, a='Bogdan') # Bogdan has 25 posts - 25 было присвоено параметру b, а строка 'Bogdan' параметру a
Так же позиционные и аргументы с ключевыми словами можно использовать вместе
show_str('Bogdan', b=25) # Bogdan has 25 posts
Но важно не присвоить 2 аргумента одному параметру
show_str('Bogdan', a=25) # TypeError: show_str() got multiple values for argument 'a' - параметру a присваиваеться 2 значения/аргумента
И что бы позиционный аргумент был указан до именованного, а не после
show_str('Bogdan', b=25)
show_str(a='Bogdan', 25) # SyntaxError: positional argument follows keyword argument
Что бы вызывать функцию с неопределенным количеством именованных аргументов их нужно обьеденить, в функции, в словарь при помощи оператора 2 звездочки (**)
def my_func(**kwargs): # kwargs - keyword arguments
    print(kwargs)
    print(type(kwargs)
    print(f"The value of the first key is {kwargs['one']}, "
    print(f"the value of the second key is {kwargs['two']}, "
    f"and the value of the third key is {kwargs['three']}") - в таком случае Пайтон произведет конкатенацию строк
my_func(two=2, one='first', three=True)
# {'two': 2, 'one': 'first', 'three': True} - первый ключ two потому что этот аргумент с ключевым словом указан первым в вызове функции
# <class 'dict'>
# The value of the first key is 1, the value of the second key is two, and the value of the third key is True
При использовании оператора 2 звездочки, можно применять только аргументы с ключевыми словами, позиционные приведут к ошибке (для них нет ключей ?)
Значение параметров функции по умолчанию задаеться при обьявлении функции при помощи знака равно = и необходимого значения
Параметр, со значением по умолчанию, делает соответствующий аргумент, при вызове функции, необязательным. Тоесть он может быть, а может и отсутствовать
Если такой аргумент указан, будет использовано его значение для инициализации соответствующего параметра со значением по умолчанию
Если такой аргумент отсутсвует, то для инициализации соответствующего параметра будет использовано значение по умолчанию, указаное при обьявлении функции
def sum(a, b=3)
    return a+b

sum(5, 4) # 9
sum(5) # 8
Так же, в качестве значения по умолчанию, может использоваться результат вызова другой функции
def multi(c, d=sum(9))
    return c*d

multi(3, 3) # 9
multi(3) # 36 - d = (9 + 3) * c = 12
Но, с параметрами значения которых по умолчанию имеют изменяемый тип данных нужно быть осторожным
def test(value, arg_list=[]):
  arg_list.append(value)
  print(f'Inside the function: {arg_list}')

test(3) # Inside the function: [3]
test(5) # Inside the function: [3, 5] - значение по умолчанию изменяемого типа не пересоздалось, а сохранило все свои прошлые изменения
Такая переменная хранит ссылку на обьект по умолчанию, который изменяется каждый раз при вызове функции без этого аргумента, а не пересоздается на новый как обьект неизменяемого типа

Оператор / - означает, что все аргументы указанные до него могут быть только позиционными
Оператор * - означает, что все аргументы указанные до него могут быть только именованными (аргументами с ключевыми словами)
Позиційні аргументи завжди повинні йти перед іменованими аргументами, інашке буде помилка
def test(a, b, c, /, d, e, f):
    print(a, b, c)
    print(d, e, f)
    
test(1, 2, 3, d='first', e='second', f='third') # 1 2 3    first second third
test(a='Hi', 2, 3, d='first', e='second', f='third') # SyntaxError: positional argument follows keyword argument
def test(a, b, c, *, d, e, f):
    print(a, b, c)
    print(d, e, f)
    
test(1, 2, 3, d='first', e='second', f='third')
test(a='Hi', 2, 3, d='first', 'second', f='third') # SyntaxError: positional argument follows keyword argument
def test(a, b, *, c, d, /):
    print(a, b, c)
    print(d, e, f)
    
test(a='Hi', b='first', 'second', True) # SyntaxError: invalid syntax - позиционные аргументы идут после именованных

Колбэк функция - это функция, которая вызываеться внутри другой функции и передаеться в нее как аргумент
Передаеться только имя колбэк функции, без круглых скобок (иначе она будет вызвана), как параметр и аргумент
def show_value(value):
    print('The value is', value)

def main_fn(num, callback_fn): - колбэк функция передана без круглых скобок
    callback_fn(num)

main_fn(9, show_value) # 'The value is 9 - колбэк функция как аргумент так же без круглых скобок

docstring - используеться для описания/документирования функций, классов, модулей
Описание указываеться внутри 3 пар одинарных или двойных кавычек
Описывать можно как саму функцию так и ее паргументы
Описание будет выводиться при навередении курсора на название функции или при установлении курсора в круглые скобки
def print_number_info(num):
    """
    Calculates is the number even or odd and then prints the result - описание функции

    Args: - описание аргумента
    num (int): Number to be evaluated
    """
    if num % 2 == 0:
        print('The number is even")
    else:
        print("The number is odd")
Автоматически создавать шаблон для описания можно при помощи расширения autoDocstring

Область видимости определяет границы действия, доступности переменной
Области видимости в Пайтон бывают всего 2 типов: Глобальная и область видимости Функции (Локальная)
Области видимости блока кода, в Пайтон, нет
Если переменная создаеться в логической конструкции if, то она будет создана в области видимости, в которой находится этот if - в Функции или Глобальной
Цепочка областей видимости:
a = 3
def outer_fn():
    def inner_fn():
        print(a)

outer_fn()
Сначала поиск переменной a будет произведен по области видимости функции inner_fn
Переменная там не будет найдена, и поэтому, поиск начнеться во внешней, для функции inner_fn, области видимости - ОВФ outer_fn
Там ее так же нет, поэтому поиск будет совершен по внешней, для этой функции области видимости.
А функция outer_fn обьявлена в Глобальной области видимости, где так же обьявлена переменная а
Эта переменная будет найдена и использована в функции inner_fn
Область видимости функции и переменные обьявленные/созданные в ней, создаються каждый раз при вызове функции (5 вызовов - 5 раз создаеться ОВФ)
Параметры функции являються переменными области видимости функции
При вызове функции создаються все переменные обьявленные в ее области видимости
После того, как функция завершит свою работу/дойдет до своей последней строки кода, все переменные, в ее области видимости, удаляються/область видимости очищается
Но, если функция возвращает переменную, то такая переменная может существовать и после завершения работы функции
В Пайтон нельзя создать переменную без значения. Переменную нужно сразу после обьявления инициализировать значением

Переменная неизменяемого типа данных, обьявленная в ГОВ, измененная внутри функции - не изменится в ГОВ, после вызова функции
Потому что, переменные неизменяемого типа данных, при изменении их значений - создаются заново
При вызове функции - переменная из ГОВ будет создана, а не изменена, в ее области видимости, а после завершения работы функции - удалена и переменная из ГОВ - не изменится
test_int = 2
print(id(test_int)) # 9801280
test_int = 4
print(test_int) # 4 - переменная изменена
print(id(test_int)) # 9801344 - создана новая переменная с именем test_int
Но, в Пайтон, если переменной с неизменяемым типом данных присваивавается такое же значения как и было - новая переменная не создается, а используется уже существуюшая, так как их значения идентичны
test_int = 2
print(id(test_int)) # 9801280
test_int = 2
print(test_int) # 2
print(id(test_int)) # 9801280
Переменная изменяемого типа данных, из ГОВ, после изменения внутри функции - изменится и в ГОВ, после вызова функции
Потому что, переменные изменяемого типа данных, при изменении ссылаются на один и тот же обьект в памяти
test_list1 = [1, 2, 3]
print(id(test_list1)) # 140007925138240
test_list1.append(4)
print(test_list1) # [1, 2, 3, 4] - список изменился
print(id(test_list1)) # 140007925138240 - обьект остался тот же

При помощи ключевого слова global можно создавать/обьявлять или использовать переменные из Глобальной области видимости в Области видимости функции
Переменные с ключевым словом global не создаются в Области видимости функции, они будут создаватся в ГОВ
Сначала идет строка с ключевым словом global и названием переменной, а на следующей - действия с этой переменной. Обьявление и инициализация на одной строке приведут к ошибке
Глобальная переменная создается/изменяется в момент присвоения значения, а не на строке с ключевым словом global
def my_fn():
    # global a = 9 - SyntaxError: invalid syntax
    global a
    a = 9 - создается переменная а

print(a) - ошибка, переменная a is not defined
Что бы переменная a была создана в Глобальной области видимости используя функцию my_fn - эту функцию нужно вызвать, она выполнит свой код - создаст переменную а в Глобальной области видимости
А затем эту переменную уже можно будет использовать в ГОВ
my_fn() - выполняется тело функции - создается переменная а в ГОВ
print(a) # 9
Если одноименная переменная уже была создана в ГОВ ранее, то такой код перезапишет ее значение на новое, присвоенное в функции
a = 3
print(a) # 3
my_fn()
print(a) # 9
Проверить, что в функции, переменная с ключевым словом global является переменной из ГОВ можно сравнив их идентификаторы
a = 3
def check_id():
    global a
    print(id(a))
    a = 9
    print(id(a))

print(id(a)) # 140712746957304 - переменная из Глобальной области видимости
check_id()
# 140712746957304 - таже переменная из ГОВ внутри функции check_id
# 140712746957496 - новая переменная а со значением 9, созданная в Области видимости функции (int - неизменяемый тип данных, при изменении - создается новая переменная, а не изменяется старая)
print(id(a)) # 140712746957304 - переменная а из ГОВ осталась без изменений - No it's changed. Need to re-check

Встроенный метод dir - возвращает список переменных доступных в текущей области видимости
Вызов dir() в Глобальной области видимости вернет массив имен глобальных переменных
Такой же вызов внутри функции - вернет массив имен переменных внутри Области видимости этой функции
dir() # ['a', 'my_fn']
Если в функции есть переменные с ключевым словом global, то вызов dir, в этой функции, их не покажет
Так как они обьявлены или создаются в Глобальной области видимости, а dir вызывается внутри функции

Операторы:
1. Арифметические: +, -, *, /, %, //
2. Сравнения: ==, !=, >, <, >=, <=
3. Логические: and, or, not
4. Текстовые: and, or, not, in, not in, is, is not
5. Присвоения: =
a = 10
= - бинарный оператор
a, 10 - операнды
% - оператор остатка от деления
16 % 5 = 1
// - оператор целочисленного деления
16 // 5 = 3
a = True
print(a is not True) # False
Оператор is - проверяет совпадают ли ссылки на обьекты в памяти
Оператор сравнения (==) проверяет совпадают ли значения у обьектов, их количество и порядок (если он важен для последовательности: set, list)
a = 3
b = a
a is b # True
a = 3
b = 3
a is b # True
int - неизменяемый тип данных
В Пайтон все является обьектами
В Пайтон неизменяемые обьекты создаются в памяти 1 раз
Если такое же значение будет использован еще раз - Пайтон просто переиспользует созданный ранее обьект и передаст новой переменной ссылку на него в памяти
При b = 3 не создается новый обьект типа int, а используется созданный ранее обьект а и переменная b инициализируется ссылкой на него
id(b) == id(a) # True - айди у переменных одинаковые, это значит что они ссылаются на 1 ячейку в памяти
c = {
  'three': 3
}
d = {
  'three': 3
}
dict - изменяемый тип данных и поэтому он каждый раз создается заново/новый
print(c is d) # False - переменные c и d содержат ссылки на разные списки
print(c == d) # True - списки c и d - одинаковые
Операторы in, not in используются для проверки наличия элемента в последовательности
При использовании операторов вызываются соответствующие магические методы определенных классов
Класс из которого вызывается магический метод соответствует классу левого операнда, в примере ниже - переменной а
a = 3
b = 3
a == b # True
Мегический метод класса int, соответствующий оператору сравнения, называется __eq__
a.__eq__(b) # True - что происходит под капотом при использовании оператора сравнения
Из-за того, что tuple - неизменяемый тип данных
x = (1, 2, 3)
y = (1, 2, 3)
print(x == y) # True
print(id(x), id(y)) # 2005905318592 2005905318592 - х и у указывают на один и тот же обьект в памяти
Но, если переменным присваиваются сложные расчеты, а не готовые значения, то создаются разные обьекты и такие переменные ссылаются на разные обьекты в памяти
Это свойственно и неизменяемым типам данных
x = 2**2
y = 2**2
print(id(x)) # 140013980558720 - расчет простой, поэтому создается один обьект в памяти и обе переменные х и у ссылаются на него
print(id(y)) # 140013980558720
x = 2**65
y = 2**65
print(id(x)) # 140596008760736 - сложный расчет, создается два обьекта в памяти и переменные ссылаются на них
print(id(y)) # 140596008581760
x = (1, 2, "python" * 1000)
y = (1, 2, "python" * 1000)
print(x == y) # True
print(id(x), id(y)) # 139771239650240 139771239679872
print(x is y) # False

Унарные операторы используются только с 1 операндом (справа): -, +, not
Оператор - конвертирует знак числа на противоположный
+ явно показывает что переменная является числом
Так же конвертирует тип bool в целые числа
not - отрицание
Так же используется двойное отрицание not not, с помощью которого любое значение можно конвертировать в логическое значение и оценить его ложность
a = True
+a # 1
a = 1
-a # -1
not a # False
not not a # True
a = ''
print(not a) # True
print(not not a) # False
print(bool(a)) # False
В JS пустой словарь/список - true (!!{} - true)
Унарные префиксные (перед операндом) операторы, кроме not, так же могут быть бинарными (2 операнда) инфиксными (между 2 операндами) операторами
Порядок выполнения оператор можно задавать самому используя оператор группирования - круглые скобки ()
(((a + b) * c) / d) - e
Так же есть таблица приоритетности операторов в Пайнтон и ее можно найти в интернете

Ложными являются значения, которые при привидении к логическому типу данных bool выдают False
Сделать это можно используя встроенную функцию конструктор bool()
bool(0) # False
Проверить значение на ложность можно также при помощи двойного оператора отрицания not
not not 0 # False
not 0 # True
Ложными значениями в Пайтон являются: 0, 0.0, 0j, False, None и все пустые последовательности

Логический оператор not всегда возвращает значение логическое типа bool
Операторы and и or являются инфиксными бинарными и возвращают значение одного из операндов
Оператор and ищет первое ложное значение и возвращает его. Если его нет - возвращает значение последнего правдивого операнда, как результат всего выражения
Оператор or ищет первое правдивое значение и возвращает его. Если его нет - возвращает значение последнего ложного выражения, как результат всего выражения
0 and 1 # 0
1 and 0 # 0
0 or 1 # 1
1 or 0 1
1 and 2 # 2
1 or 2 # 1
and, or - операторы короткого замыкания
and - если первое значение ложно, следующие операнды игнорируются
or - если первое выражение правдиво - следующие игнорируются
Так же, с помощью этих операторов можно вызывать или не вызывать функции (потому что функция - это выражение которое возвращает результат)
my_list = [1, 2, 3]
my_list and print("The list is not empty") # The list is not empty

a = {
  'three': 3,
  'one': 1
}

b = {
  'one': 1,
  'three': 3
}

a == b and print('Dictionaries are equal') # Dictionaries are equal

Оператор распаковки словарей ** - используется для создания новых словарей и обьединения уже существующих
button = {
  'width': 400,
  'text': 'Buy',
  'color': 'grey'
}

red_button = {
  **button, - распаковываются все ключи и значения словаря button и записываются в словарь red_button
  'color': 'red',
  'height' : 100
}

print(red_button) # {'width': 400, 'text': 'Buy', 'color': 'red'} - словарь red_button содержит все ключи и значения словаря button, а так же свои новые - height
Порядок указания распаковки в новом словаре важен когда они содержат одинаковые ключи, так как их значения будут перезаписаны
В примере выше, после распаковки словаря button, значение ключа color будет перезаписано с grey на red
red_button = {
  'color': 'red',
  'height' : 100,
  **button
}
В таком случае значение ключа color сначала будет red, а после распаковки словаря button - перезапишется на grey
Создание нового словаря на основе уже существующих с использованием оператора распаковки
В новом словаре, значения одинаковых ключей, если такие есть, будут перезаписаны на значения из словаря, который указан, распаковывается последним
new_button = {
  **button,
  **red_button
}
Начиная с версии Пайтон 3.9.0, это можно сделать проще, при помощи оператора обьединения |, который так же равнозначен методу обьединения union для наборов (set)
new_button = button | red_button
В параметрах функций оператор ** используется для обьединения разного количества именованых аргументов/с ключевыми словами в словарь
Там же, оператор * обьединяет разное количество аргументов в кортеж

del - инструкция для удаления элементов различных последовательностей в Пайтон
Проверить, что del - это инструкция, а не оператор, можно поместив ее вызов в функцию print
my_list = [1, 2, 3]
print(del my_list[0]) # SyntaxError: invalid syntax. Expected expression
Тоесть, это не выражение, а значит - инструкция
Магическим методом инструкции del является метод __dellitem__()

f-strings - один из способов форматирования строк в Пайтон
С его помощью можно использовать любые выражения (переменные и даже вызов функции) динамически в строках
При этом, перед строкой указывается буква f, а выражения указываются в фигурных скобках
В фигурных скобках можно использовать выражения любых типов, они будут автоматически конвертированы в тип str
hello = 'Hi'
world = 'World'
print(f"{hello} {world}) # 'Hi World' - 

def show(s):
    return s
gr2 = f"{hello} {world} {show(9)}" -  вызов функции в f-strings
print(gr2) # 'Hi World 9' - число 9 конвертировано в тип строка
print(f'[1, 2, 3]') # '[1, 2, 3]' - список автоматически конвертирован в строку

Так же, для форматирования строк можно использовать метод строк format, передавая ему в качестве аргументов переменные
name = 'Kirilo'
age = '33'
country = 'UK'
message = 'Hello, my name is {}, I am {} and I\'m from {}'.format(name, age, country)
print(message) # Hello, my name is Kirilo, I'm 33 and I'm from UK
Или значения напрямую
message = 'Hello {}, how are {} ?'
print(message.format('all', 'you')) # Hello all, how are you ?

Метод split принимает другую строку в качестве разделителя и возвращает список частей строки
my_str = 'Hello all, how are you today, fine ?'
parts = my_str.split(',')
print(parts) # ['Hello all', ' how are you today', ' fine ?']

Метод strip используется для удаления пробелов вначале и вконце строки
my_str = '   Hello all. How are you ? '
print(my_str.strip()) # Hello all. How are you ?

Для экранирования символа одной кавычки используется эскейп-символ - обратный слэш \
time = '9 o\'clock'
Или строку просто можно указать в двойных кавычках
time = "9 o\'clock"

Лямбда функции начинаются с ключевого слова lambda, затем через 1 пробел идут параметры (1 или больше через запятую)
После ставится двоеточие и указывается выражение, результат которого возвращает функция
Круглые скобки для параметров ненужны
Ключевое слово return для выражения, можно не указывать, оно будет добавлено автоматически, под капотом
Вся лямбла функция обьявляется на одной строке
Лямбда функция не имеет имени и всегда анонимна
lambda a, b: a * b
Так как лямбда функция анонимна, для ее вызова/использования - ее можно присвоить переменной
Лямбда-выражение возвращает указатель на функцию, который можно присвоить имени функции
mult = lambda a, b: a * b - анонимная лямбда функция присвоена переменной mult и теперь имеет имя
print(mult(3, 3)) # 9 - вызов лямбда функции
res = mult(3, 3) - присвоения результат вызова лямбда функции переменной
print(res) # 9
Но, документ AutoPEP8 не рекомендует присвоение лямбда функций переменным, в таком случае он заменит синтаксис обьявления лямбда функции на обычную, при исполнении кода
В момент запуска кода, такая лямбда функция будет автоматически заменена на обычную встроенным автоформатированием кода в Пайтон - AutoPEP8
def mult(a, b): return a * b - обычная функция вместо лямбда функции
Если тело обычной функции состоит из 1 строки - ее можно указывать после двоеточия, а не переносить на новую строку с отступом
lambda c: c ** 2 - еще 1 пример
res = lambda b: b*3
print(res(3))
Лямбда функция может не иметь параметров, тогда после ключевого слова lambda сразу идет двоеточие
res = lambda: 'Hi'
print(res()) # Hi

При присвоении лябмда функции переменной, этой переменной присваивается сама лямбда функция, а не ее результат, потому что она не вызывается
res = lambda: 'result'
print(type(res)) # <class 'function'> - переменной res была присвоенная лямбда функция, а не ее результат
print(res) # <function <lambda> at 0x7f00d9456d30>
print(res()) # 'result' - вызов функции res возвращает результат лямбда функции, которая была ей присвоена

Обычно лямбда используется, когда другая функция или метод может получить объект входной функции
Если функция получает вызываемый входной аргумент (другую функцию которая вызывается в ней), вы можете легко использовать лямбда-функцию в качестве этого аргумента
Например, sort метод списков, filter, map или reduce из модуля functools
Эти методы принимают в качестве аргумента функцию, которая применяется к каждому элементу последовательности, с которой они взаимодействуют

sort(key=None, reverse=False) - key - функция которая применяется к каждому элементу списка, reverse - направление сортировки, по умолчани от меньшего к большему
pairs = [(1, 'one'), (3, 'three'), (2, 'two'), (4, 'four')]
print(pairs.sort()) # [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
Если вам необходимо отсортировать список кортежей по текстовому значению (в алфавитном порядке), это можно сделать следующим образом
pairs.sort(key = lambda a: a[1])
print(pairs) # [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
pairs.sort(key = lambda a: a[1], reverse = True) # порядок сортировки от большего к меньшему, а в примере с текстом - в обратном алфавитном порядке
print(pairs) # [(2, 'two'), (3, 'three'), (1, 'one'), (4, 'four')]

map(function, iterable) - возвращает итератор, который применяет функцию к каждому элементу итерируемого объекта (аргумента)
nums = [48, 6, 9, 21, 1]
square_all = map(lambda num: num ** 2, nums)
square_all  # map returns an iterable object - <map object at 0x000002951E273CA0>
print(list(square_all)) # [2304, 36, 81, 441, 1]

filter(function, iterable) - возвращает итератор из элементов итерируемого обьекта (аргумента), для которого функция возвращает True
Если функция None, то все элементы итерируемого объекта, которые являются ложными, удаляются
nums = [48, 6, 9, 21, 1, 35, 16, 12, 0, -1]
print(list(filter(lambda num: num % 2 == 0, nums))) # [48, 6, 16, 12, 0]
print(list(filter(None, nums))) # [48, 6, 9, 21, 1, 35, 16, 12, -1] - 0 was removed because 0 == False

reduce(lambda x, y: x+y, iterable, initializer) - применяет функцию с двумя аргументами ко всем элементам итерируемого обьекта, слева направо и вконце сводит итерируемый к одному значению
initializer - значение которое будет добавлено к финальному результату, необязательный элемент
reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
reduce вычисляет в порядке ((((1+2)+3)+4)+5)
Для первой итерации берет первые два элемента из итерируемого. В нашем случае это 1 и 2
Затем он применяет к ним функцию и обрабатывает результат функции как первый элемент итерируемого обьекта вместо 1 и 2
В результате:
[1, 2, 3, 4, 5] - 1+2 = 3
[3, 3, 4 ,5] - 3+3 = 6
[6, 4, 5] - 6+4 = 10
[10, 5] - 10+5 = 15
Результат - 15
result = reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
print(result) # 15
Функцию reduce нужно импортировать из модуля functools
from functools import reduce  # import a reduce function
nums = [1, 2, 3, 4, 5]
res = reduce(lambda x, y: x+y, nums)
print(res) # 15
res2 = reduce(lambda x, y: x+y, nums, 100)
print(res2) # 115 - 15 + 100 (initializer)

Так же правильным считается использование лямбда функции, например, в Замыканиях (Closures), в качестве возвращаемой функции, если ее тело состоит из одного выражения
Замыкание - это когда одна функция (внешняя) возвращает другую (внутренюю), обьявленую внутри
В таком случае, внутреняя функция имеет доступ к параметрам и переменным внешней функции
def morning_greetings(phrase):
    return lambda name: f"{phrase}, {name} !" - лямбда функция обьявлена внутри morning_greetings функции и имеет доступ к ее параметру phrase

show1 = morning_greetings('Good morning') - в результате вызова функции morning_greetings будет возвращена лямбда функция и присвоена переменной show1
print(show1('Bogdan')) # Good morning, Bogdan !

Лямбда функцию можно заменить на обычную
def evening_greetings(phrase):
    def name(n):
        return f"{phrase}, {n} !"

    return name

show2 = evening_greetings('Good evening')
print(show2('Bogdan')) # Good evening, Bogdan !

def good_luck(phrase):
    def name(n): return f"{phrase}, {n} !" - обычная функция, тело которой состоит из
    return name

show3 = good_luck('Have a nice day')
print(show3('Bogdan')) # Have a nice day, Bogdan !

def check(a):
    outer_arr = [0, 1, 2, 3]
    return lambda b: a + b + inner_arr[3] - внутреняя лямбда функция имеет доступ к переменным внешней функции (outer_arr) (к внешней области видимости функции ?), внутри которой она обьявлена

res = check(3)
print(res(3)) # 9


Замыкания - это функции, которые запоминают переменные из скоупа, в котором они были созданы (внешняя функция), даже после того как этот скоуп перестал существовать (после окончания работы внешней функиции)
Это позволяет вложенной функции использовать переменные внешней, даже после того как она завершила исполнение
def outer_func(x):
    def inner_func(y):
        return x + y
    return inner_func

# Викликаємо outer_func з аргументом 10 і отримуємо функцію
closure_func = outer_func(10)
# Тепер можемо викликати замикання, яке запам'ятало значення x = 10
print(closure_func(5))  # Виведе 15
print(closure_func(7))  # Виведе 17
Функція outer_func(x) повертає функцію inner_func(y), яка використовує змінну x із зовнішньої функції
Після виклику outer_func(10) ми отримуємо функцію closure_func, яка запам'ятала значення x = 10
Коли ми викликаємо closure_func(5), функція додає y = 5 до запам'ятаного x = 10, і результатом буде 15
Таким чином, вкладена функція утворює замикання, оскільки вона «замкнула» значення змінної x з зовнішнього простору

Але, якщо потрібно змінити змінну, яка оголошена у функції outer_func всередині функції inner_func, ви можете використати ключове слово nonlocal
Воно дозволяє вкладеній функції змінювати змінну з зовнішньої функції, а не створювати нову локальну змінну.
def outer_func():
    counter = 0
    def inner_func():
        nonlocal counter  # Використовуємо nonlocal, щоб змінити змінну counter
        counter += 1
        return counter
    return inner_func

# Створюємо замикання
closure_func = outer_func()

print(closure_func())  # Виведе 1
print(closure_func())  # Виведе 2
print(closure_func())  # Виведе 3
Функція outer_func оголошує змінну counter і повертає функцію inner_func.
Всередині inner_func ми використовуємо nonlocal counter, щоб вказати, що ми хочемо змінити змінну counter з зовнішнього простору видимості
Кожного разу, коли ми викликаємо closure_func(), змінна counter збільшується на 1, і цей результат зберігається, оскільки він знаходиться у замиканні (у скоупі - область зовнішньої функції ?)
Таким чином, nonlocal дозволяє вам змінювати змінну зовнішньої функції у вкладеній функції

Без використання ключового слова nonlocal, змінювати змінну з зовнішньої функції у Python не можна напряму, оскільки Python автоматично трактує її як локальну змінну всередині вкладеної функції
Якщо ви спробуєте змінити таку змінну без nonlocal, то отримаєте помилку, тому що Python сприйме, що ви намагаєтеся присвоїти нове значення локальній змінній, яка ще не ініціалізована

Якщо ви не хочете використовувати nonlocal, то є декілька альтернативних варіантів:

1. Використання змінної, що є об'єктом, наприклад списку або словника
Можна використовувати змінну, яка є змінним об'єктом, таким як список або словник
Це працюватиме, оскільки змінні об'єкти можна змінювати без використання nonlocal.
def outer_func():
    counter = [0]  # Список для збереження значення
    def inner_func():
        counter[0] += 1  # Змінюємо перший елемент списку
        return counter[0]
    return inner_func

closure_func = outer_func()

print(closure_func())  # Виведе 1
print(closure_func())  # Виведе 2
print(closure_func())  # Виведе 3
Тут ми використовуємо список як контейнер для змінної counter, і можемо змінювати його значення, оскільки списки є змінними об'єктами.

2. Використання атрибутів класу (альтернативний спосіб з класом)
Замість функцій можна використовувати класи, щоб зберігати стан змінних. Це дозволяє змінювати значення без використання nonlocal.
class Counter:
    def __init__(self):
        self.counter = 0
    
    def increment(self):
        self.counter += 1
        return self.counter

c = Counter()

print(c.increment())  # Виведе 1
print(c.increment())  # Виведе 2
print(c.increment())  # Виведе 3
Тут ми зберігаємо змінну counter як атрибут класу, і можемо змінювати її через методи

Без nonlocal, пряме змінювання змінних у вкладених функціях неможливе
Але за допомогою таких підходів, як використання змінних об'єктів (списків, словників) або класів, можна досягти аналогічного результату

Так, в JavaScript немає еквіваленту nonlocal, оскільки механізм роботи з замиканнями дещо відрізняється від Python
У JavaScript, якщо ви оголошуєте змінну без ключових слів let, const або var, вона стає глобальною
Локальні змінні в JavaScript, оголошені за допомогою let або const, доступні тільки в обсязі (scope) функції, в якій вони були створені
Вкладені функції в JavaScript автоматично мають доступ до змінних своєї батьківської функції без необхідності використовувати додаткові ключові слова
Це дозволяє вкладеним функціям використовувати та змінювати локальні змінні батьківської функції без необхідності вказувати, що вони "не локальні"
function outer() {
    let count = 0; // Локальна змінна
    return function inner() {
        count += 1; // Можемо змінювати count без nonlocal
        return count;
    };
}

const increment = outer();
console.log(increment()); // Виведе 1
console.log(increment()); // Виведе 2
console.log(increment()); // Виведе 3
Таким чином, JavaScript реалізує замикання без додаткових слів, таких як nonlocal. Просто потрібно слідкувати за обсягами видимості змінних, щоб не використовувати глобальні змінні без потреби.


Рекурсия - это метод решения вычислительной задачи, где решение зависит от решений меньших экземпляров той же задачи
Рекурсия это решение задачи с помощью функций, которые вызывают сами себя из своего собственного кода (тела функции)
Классический пример рекурсии из повседневной жизни — два зеркала, поставленные друг напротив друга
def get_fib(n):
    """Get a Nth element of the Fibonacci sequence."""
    if n == 1: # base case
        value = 0
    elif n == 2: # base case
        value = 1
    else:
        value = get_fib(n - 2) + get_fib(n - 1) # recursive call

    return value

print(get_fib(5)) # 3
print(get_fib(7)) # 8
Есть несколько плюсов и минусов использования рекурсивных функций, но самый большой недостаток в том, что рекурсивные функции занимают много места
Каждый вызов рекурсии будет добавлен в стек вызовов
STACK
get_fib(1)
get_fib(2)
get_fib(1)
get_fib(2)
get_fib(3)
get_fib(4)
main


При возникновении ошибки - выполнение кода/программы останавливается
Что бы этого избежать, ошибку нужно отловить
Сделать это можно при помощи конструкции try, except
В блок try - помещают код, при выполнении которого возможно появления ошибок
В блоке except - указывают конкретный тип ошибки (ее класс) и код, который нужно выполнить при ее появлении
Так же, в блоке except, можно указывать несколько ошибок - except (TypeError, ZeroDivisionError): # handle multiple exceptions
try:
    print(10 / 0)
except ZeroDivisionError:
    print('Can't devide by zero')

ZeroDivisionError - это класс, ошибка которого возникает при делении чисел на 0
Сама ошибка является экземпляром этого класса
try:
    print(10 / 0)
except ZeroDivisionError:
    print(ZeroDivisionError) # class ZeroDivisionError
    print('Can't devide by zero')

Что бы получить доступ к возникшей ошибке, ее можно записать в переменную при помощи оператора as
try:
    print(10 / 0)
except ZeroDivisionError as error:
    print(error) # division by zero

Когда функция print получает в качестве аргумента обьекта класса, она выводит его текстовое значение автоматически вызывая встроенный магический метод __str__()
print(error) # division by zero
print(error.__str__()) # division by zero

Указывать для каждого типа ошибки блок except - неудобно, поэтому можно использовать родительский класс всех ошибок в Пайтон - класс Exception
try:
    print(10 / 0)
except Exception as error:
    print(error)

Так же можно вообще не указывать тип ошибки в блоке except, однако так не рекомендуется делать и нет доступа к ошибке, в случае ее возникновения (присвоение переменной при помощи оператор as)
try:
    print(10 / 0)
except:
    print('Some error happened')

Хорошей практикой считается не указывать все Исключения в 1 except, а разделять их
try:
    # do something
    pass

except ValueError:
    # handle ValueError exception
    pass

except (TypeError, ZeroDivisionError):
    # handle multiple exceptions
    # TypeError and ZeroDivisionError
    pass

except:
    # handle all other exceptions
    pass

В блок else - помещают код, который будет выполнен только в том случае, если ошибок небыло, даже если они были обработаны в блоке except
try:
    print(10 / 0)
except ZeroDivisionError:
    print('Can't devide by zero')
else:
    print('There were no errors') # Не будет выполнен, так как код в блоке try содержит ошибку

В блок finally - код, который будет выполнен всегда, вне зависимости от того были ошибки или не было, были они обработаны или нет
try:
    print(10 / 0)
except ZeroDivisionError:
    print('Can't devide by zero')
else:
    print('There were no errors') # Не будет выполнен, так как код в блоке try содержит ошибку
finally:
    print('Finally') # Будет выполнен всегда, когда код в блоке try содержит или не содержит ошибку


Можно самостоятельно создавать Исключения путем создания нового класса, который наследуется от встроенного класса Exception
Большинство встроенных исключений также являются производными от базового класса Exception
Вызывать ошибки нужно используя инструкцию raise с названием класса нужного Исключения и необязательным аргументом - сообщением об ошибке
После слова raise нужно указать функцию конструктор того класса ошибка которого нужна
Это сообщение будет показано когда эта ошибка возникнет
raise ValueError('The value is wrong') # Встроенный класс Исключения
def divide(a, b):
    if b == 0:
    raise ValueError('Can't divide by 0')
    return a / b

print(divide(10, 0)) # Can't divide by 0
print(divide(10, 2)) # 5

class InputError(Exception): # Пользовательский класс Исключения
    pass
    
raise InputError('Custom exception') # InputError: Custom exception


Функция распаковки (unpack) позволяет извлекать значения из последовательностей и присваивать их переменным
При этом, количество новых переменных должно соответствовать количеству значений в последовательности, иначе будет выброшена ошибка
list1 = [1, 2, 3]
first, second, third = list1 - созданы 3 новые переменные и им присвоенны соответствующие порядку, в котором они указаны, значения списка list1
print(first, second, thirs) # 1, 2, 3
first, second = list1 # ValueError: too many values to unpack (expected 2)

tuple1 = (1, 'two', 3, True, [1, 2, 3])
one, two, three, four, five = tuple1
print(three, four) # 3, True

При использовании распаковки, для одной новой переменной, можно использовать оператор звездочки *, что бы собрать несколько значений в список
Переменная со звездочкой может быть обьявлена первой, внутри или последней
tuple2 = (1, 'two', 3, True, [1, 2, 3])
first, *other, last = tuple2 
print(first) # 1
print(other) # [two', 3, True] - список, хотя tuple2 - это кортеж
print(last) # [1, 2, 3]

list3 = [1, 'two', 3, True, [1, 2, 3]]
*other, last = list3
print(other) # [1, two', 3, True]
print(last) # [1, 2, 3]

При распаковке, оператор звездочки может применятся только к одной новой переменной
Если таких переменных будет больше - будет выброшена ошибка
tuple12 = (1, 'two', 3, True, [1, 2, 3])
*t1, t2, *t3 = tuple12
print(*t1, t2, *t3) # SyntaxError: multiple starred expressions in assignment

Но переменная со звездочкой не может быть обьявлена единственной
*new_list = list3 # SyntaxError: starred assignment target must be in a list or tuple
В таком случае можно просто присвоить список list3 новой переменной или использовать один из способов копирования списка
new_list = list3 - один и тот же обьект
new_list = list3.copy() - новый обьект
new_list3 = []
new_list3.extend(list3) - новый обьект

При распаковке словаря, переменные получают значения ключей, а не их значений
dict1 = {
    'name': 'Bogdan',
    'coments_qty': 3
}

var1, var2 = dict1
print(var1, var2) # name coments_qty

Распаковку словаря можно использовать при вызове функции, для получения аргументов с ключевыми словами, при помощи оператора **
В таком случае, все свойства словаря будут распакованы как аргументы с ключевыми словами
При этом необходимо:
1. Что бы имена ключей словаря совпадали с названиями параметров функции
Так как свойства словаря распаковываются как именованные аргументы, тоесть имеют свое имя и значение, а параметр функции уже имеет свое имя
2. Количество свойств словаря должно совпадать с количеством параметров функции
def show(n, q=0):
    if q:
        return f"{n} has {q} comments"
    return f"{n} has no comments"

dict2 = {
    'n': 'Bogdan',
    'q': 3
}

print(show(**dict2)) # Bogdan has 3 comments - имена ключей и их количество в словае dict2 совпадает с параметрами функции show

dict1 = {
    'name': 'Bogdan',
    'coments_qty': 3
}
print(show(**dict1)) # TypeError: show() got an unexpected keyword argument 'name' - имя ключа не совпало с названием параметра функции

dict2 = {
    'n': 'Bogdan',
    'q': 3,
    'id': 98765
}
print(show(**dict2)) # TypeError: show() got an unexpected keyword argument 'id' - передано аргументов больше чем указано параметров в функции

Распаковку списков, кортежей так же можно использовать в вызове функции, для получения позиционных аргументов, при помощи оператора *
При этом, необходимо что бы количество элементов в списке, кортеже соответствовало количеству параметров у функции
list1 = [1, 'Hi', 3, None, True]
def show1(a, b, c, d, e):
    return f"The 3rd element is {c} and the 5th is {e}"

print(show1(*list1)) # The 3rd element is 3 and the 5th is True

list2 = [1, 2, 3]
print(show1(*list2)) # TypeError: show1() missing 2 required positional arguments: 'd' and 'e' - количество аргументов меньше чем параметров

Распаковка словаря при вызове функции - оператор ** - в результате - аргументы с ключевыми словами, их количество и имена должны совпадать с параметрами функции
Распаковка списка при вызове функции - оператор * - в результате - позиционные аргументы, их количество должно совпадать с количеством параметров функции

Функции распаковки и "упаковки" можно использовать в одной функции, для обьединения нескольких последовательностей в одну при помощи оператора одной звездочки *
Или для обьединения нескольких словарей в один, при помощи оператора две звездочки **
def new_fn(*args): # Все аргументы будут собраны в новый кортеж
    return args

l5 = [1, 2, 3, 4, 5]
l6 = [6, 7, 8, 9, 10]
print(new_fn(*l5, *l6)) # (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
Каждый список был распакован в отдельные элементы, которые были переданы в функцию, где собраны в один новый кортеж

def new_fn2(**kwargs):
    return kwargs

d5 = dict4 = {
    'a': 1,
    'b': 'Hi',
    'c': 3,
}
d6 = {
    'd': True,
    'f': None
}
print(new_fn2(**d5, **d6)) # {'a': 1, 'b': 'Hi', 'c': 3, 'd': True, 'f': None}
Оба словаря, при вызове функции, были распакованы в отдельные именованные аргументы, переданы в функцию где были собраны в один новый словарь
Функция распаковки - разделяет посделовательность на отдельные элементы (с ключевыми словами для словаря)
Упаковки - собирает отдельные элементы в новый кортеж или словарь (для элементов с ключевыми словами)

Код указаный после условной инструции if будет выполнен только в том случае, если ее условие - правдиво
Условие в инструкции if является выражением, которое возвращает результат, после чего он оценивается - правдив он или ложен
if 10 > 0:
    print("The number is positive")

if 10 < 0: - условие ложно и поэтому строка "The number is positive" не будет выведена
    print("The number is positive")
Отрицание правдивого значения - ложно, а отрицание ложного - правдиво
not True - False
not False - True
if not 10 > 0 - отрицание правдивого вернет False и поэтому строка "The number is positive" не будет выведена
    print("The number is positive")

Код указанный после инструкции else будет выполнен только в том случае, когда условие в инструкции if - ложно
if 10 < 0:
    print("The digit is negative")
else:
    print("The digit is positive") - будет выполнен этот блок кода, так как условие 10 < 0 - ложно

Условная инструкция elif содержит условие
Код указанный в инструкции elif будет выполнен только тогда, когда условие в инструкции if - ложно, а собственное условие - правдиво
if 10 < 0:
    print("The number is positive") - условие ложно, строка не будет выведена и код перейдет к следующей условной инструкции elif
elif 10 == 10:
    print("The number is 10") - строку будет выведена, так как условие 10 == 10 - правдиво и выражение в инструкции if - ложно

if 10 > 0:
    print("The number is positive") - будет выведена эта строка
elif 10 == 10:
    print("The number is 10") - эта строка не будет выведена, так как условие в инструкции if - правдиво

if 10 > 0:
    print("The number is positive")
elif 10 == 1:
    print("The number is 10") - ничего не будет выведено, так как оба условия - ложны

В Пайтон нет блочной области видимости, есть локальная и глобальная области видимости
Поэтому, переменные созданные внутри блоков if, elif и else доступны и вне

def check(a, b):
    if type(a) is not int or type(b) is not int:
        info = "Some of the arguments is not an integer"
    elif a >= b:
        info = f"{a} is bigger or eqaul to {b}"
    else:
        info = f"{a} is less than {b}"
    return info - переменная обьявленная в блоках кода инструкций if elif else доступная вне их

print(check(10, 2)) # 10 is bigger or eqaul to 2

Тернарный оператор используется в условных выражениях, так как оно возвращает результат/значение
Этот оператор использует 3 операнда и 2 оператора: if и else
Выражение 1 if Условие else Выражение 2 - это все является условным выражением
Если условие верно - будет оценено Выражение 1 и возвращен его результат, как результат всего условного выражения с тернарным оператором, а Выражение 2 будет проигнорировано
Если Условие ложно - будет оценено Выражение 2, возвращен его результат, а Выражение 1 будет пропущено
В качестве Выражений 1, 2 и Условия могут быть не только переменные, но и вызовы функций
a = 3
print("The value is int") if type(a) == int else print("The value is not integer") - вызов функций в качестве Выражений 1 и 2
print("The value is 3" if a==3 else "The value is not 3") - результатов условного выражения будет строка и она сразу же помещена в вызов функции print
result = 10 if a == 10 else 1 - присвоение результата всего условного выражения переменной

Циклы позволяют выполнять однотипные действия определенное количество раз, а так же проводить перебор, итерации по любым последовательностям
В Пайтон 2 типа циклов: for in и while
for, in - зарезервированные ключевые слова
for Переменная in Последовательность:
Переменная создается в цикле и на каждой его итерации представляет определенный элемент последовательности
Последовательность может быть любой: dict, list, tuple, str, set, range
l1 = [1, 2, 3]
for elem in l1:
    print(elem) # Значение переменной elem меняется при каждой итерации. При первом проходе по циклу elem = 1, при втором - 2, при третем - 3
При использовании for in цикла для словарей, переменная цикла будет принимать имена ключей цикла, а для доступа к их значениям можно использовать синтаксис с квадратными скобками
dict1 = {
    'f': 1,
    's': 'Two',
    't': True }
for key in dict1:
    print(key, dict1[key]) # f, 1; s, 'Two'; t, True
Доступ к ключам и значениям словарей можно получить при помощи метода словарей - items
Он возвращает последовательность типа dict_items, которая состоит из кортежей. Каждый кортеж имеет 2 элемента, первый - ключа, а второй - его значение
print(dict1.tems()) # dict_items([('f', 'One'), ('s', True), ('three', 3)]) - последовательность кортежей
for item in dict1.items():
    print(item) # ('f', 'One') ('s', True) ('three', 3) - каждлый кортеж состоит из ключа и значения
Можно распаковать каждый кортеж последовательности dict_items прямо в обьявлении цикла for in и таким образом сразу получить доступ к ключу и его значению, на каждой итерации цикла
for key, value in dict1.items():
    print(key, value) # f One   s True   three 3

Переменная созданная в цикле будет доступна в Глобальной области видимости, потому что в Пайтон нет блочных областей видимости, а только область видимости функций
И поэтому такая переменная должна иметь оригинальное имя, которое не использовалось в коде ранее
Проверить это можно вызвав функцию dir в Глобальной области
print(dir()) # Список всех переменных ГОВ, среди которых будет и переменная key, созданная в цикле for in
Она будет иметь значение присвоенное ей на последней итерации цикла
print(key) # True

Класс bool, в Пайтон, является дочерним от класса int
Поэтому:
isinstance(True, bool) # True
isinstance(True, bool) # True
В таком случае, для сравнения типа bool, можно использовать встроенную функцию type
type(True) is int # False
type(True) == int # False

Существует так же сокращенный метод for in, так называемый comprehension
Он является выражением, а не инструкцией, и поэтому, возвращает значение - новую последовательность
Его можно использовать не для всех последовательностей, а только для list, tuple, dict и set
Соответственно существуют list comprehension, dict comprehension и так далее
Сокращенный цикл for in позволяет:
1. сразу же создавать новую переменную и последовательность и инициализировать ею эту новую переменную
2. изменять элементы оригинальной последовательности и записывать их в новую, не изменяя при этом оригинальный обьект
3. фильтровать элементы в новой последовательности при помощи условия в if
Условие с if является опциональным
[ Выражение for Переменная in Последовательность if Условие ]
Выражение - имеет доступ к Переменной на каждой итерации по Последовательности и возвращает значение которое будет записано в новую последовательность
Переменная - элемент оригинальной Последовательности на каждой итерации цикла for in
Условие - имеет доступ к Переменной на каждой итерации по Последовательности. Является не обязательным, опциональным
Тип новой последовательности определяется типом скобок в которых записывается сокращенный for in
Оригинальная Последовательность, при этом, не изменяется
[ Выражение for Переменная in Последовательность if Условие ] - будет создан новый список
all_nums = [1, -2, 3, -4, 5, -6, 7, 8, 9, -10]
new_all_nums = [elem for elem in all_nums]
print(new_all_nums) # [1, -2, 3, -4, 5, -6, 7, 8, 9, -10] - элементы не изменились, потому что с переменной elem не выполнялось никаких действий
double_nums = [elem*2 for elem in all_nums]
print(double_nums) # [2, -4, 6, -8, 10, -12, 14, 16, 18, -20] - все элементы умножены на 2, потому что это было сделано в сокращенном цикле for in - elem*2
positive_nums = [elem for elem in all_nums if elem > 0]
print(positive_nums) # [1, 3, 5, 7, 8, 9] - в новый список добавлены только элементы которые прошли проверку в условной инструкции if - elem > 0
d1 = {'o': 1, 't': 2, 'three': 3, 'four': 4}
new_d = {k: v*10 for k, v in d1.items()}
print(new_d) # {'o': 10, 't': 20, 'three': 30, 'four': 40}
new_l = [v*10 for k, v in d1.items()]
print(new_l) # [10, 20, 30, 40] - формирование нового списка, который содержит только значения, из словаря
При помощи list comprehension из списка можно сформировать словарь
l2 = [1, 2, 3]
d1 = {key: value for key, value in enumerate(l2)} - используя метод enumerate, который возвращает последовательность кортежей типа enumerate object
print(list(enumerate([1, 2, 3]))) # [(0, 1), (1, 2), (2, 3)]. Каждый кортеж содержит 2 элемента: 1-ый - индекст элемента списка, а второй - сам элемент
print(d1) # {0: 1, 1: 2, 2: 3}
d2 = {l2.index(val): val for val in l2} - используя метод списков index
print(d2) # {0: 1, 1: 2, 2: 3}
Так же в comprehension можно использовать ключевое слово else
В таком случае, условная инструкция if else обьявляется перед циклом for in
[Выражени1 if Условие else Выражение2 for in]
Выражение 1 будет возвращено, если Условие верно, а Выражение 2 - если ложно
new_l = [val ** 2 if val % 2 == 0 else 'odd' for val in range(10)] # [0, 'odd', 4, 'odd', 16, 'odd', 36, 'odd', 64, 'odd']
Так же в comprehension можно использовать несколько циклов for in одновременно
[Выражение1 с Выражением2 for in Последовальность1 for in Последовальность2]
В таком варианте, 1-ый цикл for in является внешним, а 2-ой - внутренним
Тоесть, сначала начнет выполнятся 1-ый цикл, и на каждой его итерации - будет выполнятся 2-ой, от начала и до конца
l1 = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]
l2 = [2, 1, 0]
l3 = [a[i] for a in l1 for i in l2]
1-ый цикл for in начинает свою работу и инициализирует переменную а соответствующим значением элемента списка l1
Затем, переменная i принимает соответствующее значения из списка l2 на каждой итерации 2-го цикла for in
2-ой цикл завершается, после чего 1-ый цикл for in опять выполняется и инициализирует переменную a уже новым значением из списка l1
И так пока 1-ый цикл не будет завершен

print(l3) # [30, 20, 10, 60, 50, 40, 90, 80, 70]

matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

transpose_matrix1 = []
for i in range(len(matrix)):
    new_row = []
    for row in matrix:
        new_row.append(row[i])
    transpose_m4.append(new_row)

print('Lector\'s solution 1', transpose_matrix1) # Lector's solution 1 [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

transpose_matrix2 = [[row[i] for row in matrix] for i in range(len(matrix))]
print('Lector\'s solution 2', transpose_matrix2) # Lector's solution 2 [[1, 4, 7], [2, 5, 8], [3, 6, 9]]


Встроенный метод sorted используется для сортировки элементов последовательностей
По умолчанию, сортировка осуществляется от меньшего к большему
Первым аргументом метод принимает последовательность, а так же может принимать ключ - это не обязательный аргумент
def_l = [7, 10, 1, 4, 8, 3]
sorted_l = sorted(def_l)
print(sorted_l) # [1, 3, 4, 7, 8, 10] # элементы списка отсортированы по возростанию
Что бы отсортировать элементы в обратном порядке, от большего к меньшему, нужно передать ключ reverse со значением True (именованный аргумент)
reversed_l = sorted(def_l, reverse = True)
print(reversed_l) # [10, 8, 7, 4, 3, 1]
Строки метод sorted сортирует по английскому алфавиту
def_l2 = ['banana', 'apple', 'hamburger', 'citrus', 'dophamine', 'farma']
sorted_l2 = sorted(def_l2)
print(sorted_l2) # ['apple', 'banana', 'citrus', 'dophamine', 'farma', 'hamburger']
reversed_l2 = sorted(def_l2, reverse=True)
print(reversed_l2) # ['hamburger', 'farma', 'dophamine', 'citrus', 'banana', 'apple']

Так же, в качестве второго аргумента, метод sorted может принимать ключ-функцию, ее имя, а не вызов (без круглых скобок)
Функция должна передаваться как именованный аргумент, с ключевым словом/именем key
sorted(Последовательность, key=Функция)
Функция должна возвращать какое-то значение
Каждый элемент последовательности будет передан, как аргумент, в эту функцию и она вернет соответствующее ему значение
В результате, будет сформирован набор значений, которые будут отсортированы, от большего к меньшему, и отсортированы соответствующие им элементы последовательности
def return_len(word): 
    return len(word) # Функция возвращает длину аргумента
sorted_l22 = sorted(def_l2, key=return_len)
print(sorted_l22) # ['apple', 'farma', 'banana', 'citrus', 'dopamine', 'hamburger'] - элементы отсортированы по длине, от меньшей к большей
reversed_l22 = sorted(def_l2, key=return_len, reverse=True)
print(reversed_l22) # ['hamburger', 'dopamine', 'banana', 'citrus', 'apple', 'farma'] - отсортированы от большей длины к меньшей

Если значения возвращаемые функцией, в методе sorted, могут быть идентичны, метод может сравнивать элементы последовательности сразу по нескольким значениям
В таком случае, нужно что бы эта функция возвращала несколько значений для каждого элемента последовательности для их сравнених с другими
def_l3 = [
    {'a': 3, 'b': 2, 'c': 1, 'numer': 1},
    {'a': 3, 'b': 2, 'c': 2, 'numer': 2},
    {'a': 3, 'b': 3, 'c': 1, 'numer': 3},
    {'a': 3, 'b': 1, 'c': 2, 'numer': 4},
]
В последовательности def_l3 у всех элементов (словари) ключ 'a' имеет одинаковое значение и поэтому, для их сравнения, нужны дополнительные значения
Например, значения ключей 'b', но они так же имеют одинаковые значения у 2-х элементов
Тогда можно возвращать еще и значение ключа 'c' и этого хватит, так как все они - уникальны и не повторяются
def check2(d):
    return d['a'], d['b'], d['c']
Функция возвращает кортеж значений ключей а, b и c
Метод sorted будет сравнивать кортежи между собой
В случае, если первые значения будут идентичны (ключа а), сравнение будет произведено по вторым значениям (ключа b)
Если же и они буду идентичны - то по третим значениям (ключа c)
sorted_def_l3 = sorted(def_l3, key=check2)
print(sorted_def_l3) # [{'a': 3, 'b': 1, 'c': 2, 'numer': 4}, {'a': 3, 'b': 2, 'c': 1, 'numer': 1}, {'a': 3, 'b': 2, 'c': 2, 'numer': 2}, {'a': 3, 'b': 3, 'c': 1, 'numer': 3}]
Первым будет словарь с number = 4, так как значение ключа 'b' - наименьшее
Затем - number = 1, так как значение ключа b у него такое же как и у number = 2, но значение ключа с - меньше
Потом - number = 2
И  number = 3, так как значение его ключа b - наибольшее

В методе sorted, в качестве ключ-функции можно использовать лямбда функции
check_sorted2 = sorted(def_l4, key=lambda d: (d['a'], d['b'], d['c']))
print(check_sorted2) # [{'a': 3, 'b': 1, 'c': 2, 'numer': 4}, {'a': 3, 'b': 2, 'c': 1, 'numer': 1}, {'a': 3, 'b': 2, 'c': 2, 'numer': 2}, {'a': 3, 'b': 3, 'c': 1, 'numer': 3}]


Встроенный метод filter используется для итерации по последовательностям и проверки их каджого элемента на соответствие определенным условиям
Эти условия описаны в функции, которая передается первым аргументом
Эта функци должна возвращать значение только типа bool
Аргементом этой функции будет каждый элемент последовательности, при итерациях по ней
Если условие в этой функции вернет True - элемент последовательности будет добавлен в результирующую последовательность метода filter, если False - не будет
Вторым аргументом, метод filter, принимает саму последовательность, по которой нужно совершить итерацию
filter(Функция, Последовательность)
Метод filter возвращает последовательность типа filter object и для работы с ним, его можно конвертировать в другой тип последовательности, при помощи встроенных функций list, tuple, set, но не dict
Для создания новой последовательности с измененными элементами или для ее фильтрации можно использовать как comprehension так и встроенную функцию filter
l1 = [35, None, True, 'Hi', 5, [1, 2, 3], 4.0, (7, 8, 9), {'s': 2}]
def check_out(e):
    return type(e) is int # Если условие возвращает True - элемент е будет добавлен в последовательность filter object, а если False - не будет

print(list(filter(check_out, l1))) # [35, 5]

def ret(l, t): - основная функция
    # def check(elem): - функция, для метода filter, в которой будут проверятся элементы последовательности l
        # if type(elem) == t: - их можно проверить с использованием цикла for in
        #     return True

        # return True if type(elem) == t else False - или с использованием условного выражения и тернарного оператора

        # return type(elem) == t - или при помощи простого сравнения

    # return list(filter(check, l)) - вызов функции filter, которая первым аргументом принимает функцию для проверки элементов последовательности, а второым - последовательность

print(ret(l1, int)) # [35, 5]

В качестве функции, для метода filter, можна использовать лямбда функцию
def ret(l, t):
    return list(filter((lambda elem: type(elem) == t), l)) - лямбда функция будет вызвана для каждого элемента последовательности l, а ее аргументом и будут эти элементы

print(ret(l1, int)) # [35, 5]

Цикл while выполняется по тех пор, пока его условие - правдиво
Но, что бы цикл не выполнялся бесконечно, в его теле необходимо изменять переменную, которая влияет на его условие
while Условие:
i = 10
while i < 50:
    print(i) # Данный цикл бесконечный, потому что переменная i из его условия, не изменяется, и оно всегда правдиво - i всегда меньше 50

while i < 50:
    print(i)
    i += 10 # 10, 20, 30, 40
Переменная из условия цикла i, изменяется в теле цикла на каждой его итерации и в определенный момент, когда i будет равно 50, условие станет ложно, в следствии чего - цикл завершит свою работу

Так же, цикл можно остановить принудительно, вне зависимости от его условия при помощи ключевого слова break
while i < 50:
    if i == 30:
        break
    print(i)
    i += 10 # 10, 20. Когда i будет равно 30 - условие будет правдиво, однако, в условной инструкции if, сработает ключевое слово break и остановит цикл

Переходить сразу же к следующей итерации, к началу цикла, можно при помощи ключевого слова continue
В таком случае, код указанный после слова continue - не будет выполнен
while i < 50:
    i += 10
    if i == 30:
        continue
    print(i) # 20, 40, 50. Когда i было равно 30 - цикл сразу же перешел на следующую итерацию, в начало цикла, и код после слова continue не был выполнен

В цикле while можно использовать ключевое слово else
Код в блоке else цикла while будет выполнен только в том случае, если цикл выполнил свою работу до конца и не был прерван
while i < 50:
    print(i)
    i += 10
else:
    print("While loop ends it's work") # Строка будет выведена, так как цикл while был выполнен до конца (i равно 50)

while i < 50:
    print(i)
    i += 10
    if i == 40:
        break
else:
    print("While loop ends it's work") # Строка не будет выведена, так как цикл не был выполнен до конца, а был прерван когда i стала равна 40

Код в блоке else будет выполнен если сработает continue, потому что это не считается прерыванием цикла
i=0
while i<70:
  i += 10
  if i==40:
    continue
  print(i)
else:
  print("While loop ends it's work") # Строка будет выведена, так как цикл while был выполнен до конца (i равно 70)

Код в блоке else в цикле while и конструкции try except, будет выполнен если все отработало до конца - цикл не был прерван, ошибка не была выброшена

JSON - текстовый формат передачи данных
JSON появился в Javascript, но стал применятся во всех языках программирования
В Пайтон, упаковать данные в формат JSON, можно при помощи модуля json
Сначала его нужно импортировать - import json
Функция dumps, этого модуля, запаковывает данные в формат json
Если результат ее вызова присвоить переменной, то ее значение будет типа str
А функция loads - распаковывает json в соответствующий тип данных
l1 = [1, 2, 3]
js1 = json.dumps(l1)
print(type(js1)) # <class 'str'>
print(js1) # [1, 2, 3]

unpack_js1 = json.loads(js1)
print(type(unpack_js1)) # <class 'list'>
print(unpack_js1) # [1, 2, 3]

l1 = (1, 2, 3)
js1 = json.dumps(l1)
print(type(js1)) # <class 'str'>
print(js1) # [1, 2, 3] # В Javascript нет типа данных Кортеж, есть только Список

unpack_js1 = json.loads(js1)
print(type(unpack_js1)) <class 'list'>
print(unpack_js1) # [1, 2, 3] # Поэтому и после распаковки, тип данных будет - Список

l1 = None
js1 = json.dumps(l1)
print(type(js1)) # <class 'str'>
print(js1) # null - эквивалент типа данных None в Javascript

unpack_js1 = json.loads(js1)
print(type(unpack_js1)) # <class 'NoneType'>
print(unpack_js1) # None # В Пайтон нет типа данных null, поэтому он заменен на его эквивалент - None


Пространство имен (namespace) — это место, где хранится переменная
Пространства имен имеют разное время жизни. Когда Python выполняет программу, он создает пространства имен по мере необходимости и удаляет их, когда они больше не нужны
Поэтому обычно в любой момент времени существует много пространств имен
Различные пространства имен могут существовать одновременно и быть полностью изолированными. Следовательно, одно и то же имя, которое может существовать в разных модулях, не конфликтует
В Python существует четыре типа пространств имен:
Built-in (встроенное) - содержит имена всех встроенных объектов Python
Интерпретатор Python создает его при запуске, и оно существует до тех пор, пока интерпретатор не завершит свою работу
Вот почему имена из этого пространства имен (встроенные функции), такие как id, print, type, map, всегда доступны из любой части программы
Global (глобальное) - содержит имена на уровне основной программы
Создается при запуске основного тела программы и сохраняются до завершения работы интерпретатора
Интерпретатор также создает глобальное пространство имен для любого модуля, который загружает ваша программа с помощью ключевого слова import 
Для каждой функции интерпретатор создает новое пространство имен, локальное для этой функции и существующее до завершения функции
Enclosing (охватывающее) - включает имена, определенные внутри внешней функции
Local (локальное) - включает локальные имена обьявленные внутри функции
Global, enclosing, local пространства имен реализованы как словари, где ключи — это имена объектов, а значения — сами объекты
Built-in пространство реализовано как модуль
Имена переменных в пространствах имен - уникальны
def outer():
    name = 'Hi' # Охватывающее пространство имен
    print(name)
    def inner():
	name = 'Hello' # Локальное пространоство имен функции inner
	print(name)
    
    inner()

outer() - в меммент вызова функции outer Python создает пространство имен для нее
Когда outer вызывает inner для нее создается ее отдельное пространство имен
Каждое из этих пространств имен сохраняется до тех пор, пока не завершится соответствующая функция

Если переменные с одинаковым названием существуют в нескольких пространствах имен, Python понимает какую из них нужно использовать при помощи концепции области действия имени
Область действия имени (scope) — это область действия программы, в которой данное указанное имя имеет значение
Пайтон определяет область действия имени на основе места обьявления переменной и места в коде, куда ссылается это имя
The interpreter determines it during the runtime based on the name definition place and name referencing place in the code
Интерпретатор ищет имя изнутри наружу, просматривая локальную, охватывающую, глобальную и, наконец, встроенную область действия — это называется правилом LEGB

Интерпретатор Python предоставляет две встроенные функции: globals() и locals() которые позволяют вам получить доступ к глобальным и локальным словарям пространств имен
print(globals()) # {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, ... , '__builtins__': <module 'builtins' (built-in)>}
Получить доступ к глобальным и локальным переменым можно по их имени или с помощью этих функций
a = 'bar'
print(globals()) # {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, ... , '__builtins__': <module 'builtins' (built-in)>, 'a': 'bar'}
print(globals()['a']) # 'bar'
def sum_numbers(x, y):
    res = x + y
    print('List of local variables: ', locals()) # locals() вернет словарь переменных в пространстве имен функции sum_numbers
    return res

sum_numbers(1, 2) # List of local variables: {'x': 1, 'y': 2, 'res': 3} 
С помощью функции globals() можно изменять значение глобальных переменных, она возвращает фактическую ссылку на словарь глобального пространства имен
a = 3.14
globals()['a'] = 'Hi'
print(a) # 'Hi' - значение переменной из глобального пространства имен изменилось
Функция locals() возвращает только копию локального пространства имен
Таким образом, изменение словаря возвращенного locals() не повлияет на реальное локальное пространство имен

Что бы внутри функции получить доступ к переменной из глобального пространсва имен используется ключевое слово global, или функция global()[] и имя нужной переменной в квадратных скобках
Используя ключевое слово global внутри функции можно изменить значение этой переменной в глобальном пространстве имен
Что бы внутри вложенной функции получить доступ к переменным из охватывающего пространства имен внешней функции используется ключевое слово nonlocal
x = 1
def outer():
    x = 2
    def inner():
	    global x # х ссылается на переменную из глобальной области видимости, которая равна 1
	    print(f'inside inner fn {x=}')
    
    inner()
    print(f'enclosing {x=}') # х из локальной для outer функции области видимости

outer() # inside inner fn x=1	# enclosing x=2

def outer():
    x = 2
    def inner():
	    nonlocal x # х ссылается на переменную не из локальной области видимости. Следующая - охватывающая область видимости, функции outer, где х = 2
	    print(f'inside inner fn {x=}')
    
    inner()

outer() # inside inner fn x=2

"Scope" — это правило для поиска привязок (значение с назначенным именем), какие пространства имен будут просматриваться и в каком порядке (по правилу LEGB), а "namespace" — это словарь для хранения всех переменных


Большие задачи/программы разбиваются на более мелкие управляемые подзадачи или модули
Модуль — это программный файл без исполняемого, но вызываемого кода, который имеет расширение .py
Методы не вызываются внутри модулей, как запуск веб-сервера или создание файла в файловой системе ОС
Каждый модуль содержит приватное пространство имен
Посмотреть его можно при помощи функции globals
Пространство имен содержит все переменные, функции, классы обьявленные в его модуле
my_int = 3
print(globals()) # {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': ... , my_int: 3}
Вернет обьект, который содержит все переменные данного модуля и среди них так же будет переменная my_int
import json
print(globals().keys()) # {'__name__', ... , <module 'json'>}

Оператор import переносит код из одного модуля в другую программу
Можно импортировать весь код из модуля, указав ключевое слово import, за которым следует имя модуля, который вы хотите импортировать
Импорт позволяет заводить в локальное пространство имен файла/модуля другие модули и библиотеки, которые содержат свой код (классы, методы, переменные)
Это позволяет компоновать код и разбивать его на отдельные файлы/модули, а не хранить весь код в одном файле
В Python есть три способа импорта кода из модулей:
1. Импорт всего модуля
import time
Весь код из модуля time импортирован в текущую программу
Теперь все функции и переменные из time доступны в текущей программе
Вызвать их можно использовав точечную запись - time.time()
Также можно использовать множественный импорт, но он должен быть указан на отдельных строках, а не на одной
import time
import random
import time, random # Wrong 
2. Импорт некоторых частей из модуля
from time import sleep
3. Импорт с использованием псевдонимов
В оригинальном модуле названия не меняются
from [module name] import [function or value] as [your module alias]
import [function or value] as [your module alias]
from time import time as t_time
from datetime import time as dt_time
import time as timing
import folder as folder_1 # папка переименована
from folder import calculator as calc # модуль переименован
from folder.calculator import plus as adding # метод переименован
Кроме того, есть два типа импорта:
Первый — абсолютный , когда вы прописываете полный путь к модулю
from my_application.service.module1 import method1
Второй — относительный , где точка означает текущий каталог:
from . import module1 # Импорт всего модуля из текущей директории
from .module1 import method1  # import from module1, which is located in the same directory
Символ звездочки * означает все, что содержится внутри
from folder import * - импорт всего, что есть в папке folder
from folder.calculator import * - импорт всего, что есть в модуле calculator, который в папке folder
При импорте нужно избегать символа *, это может привести к нарушению пространства имен программы
from time import *  # Wrong
from time import time
from datetime import *
print(time())  # return 00:00:00
Python вызовет метод time из последнего импорта, и потому что datetime модуль также имеет time метод, этот метод будет вызван
Импортировать модули можно при помощи ключевых слов from и import
Синтаксис может быть разным:
1.) Можно импортировать папку со всеми модулями
import folder
В таком случае, обращатся к нужным методам, переменным нужно через имя папки и названия нужного модуля, используя точечную запись
folder.calculator.plus(1, 2) # Метод plus находится в модуле calculator, который лежит в папке folder
2.) Можно импортировать весь модуль
from folder import calculator
Тогда нужные элементы модуля нужно вызывать используя его имя, точку и название элемента
calculator.plus(1, 2)
3.) Можно импортировать только нужные переменные, функции и классы из модуля
from folder.calculator import plus, minus # методы plus и minus были импортированы из модуля calculator, который находится в папке folder
В таком случае методы plus и minus можно вызывать напрямую - plus(1, 2), minus(2, 1)
4.) Можно импортировать сразу из модуля (как ?)
from calculator import plus, minus

При достижении оператора import Пайтон выполняет весь код в импортируемом модуле и если там есть вызов функций - они будут вызваны
# a.py
print("Hello from a.py")
def foo():
    pass

# b.py
from a import foo # As a result - 'Hello from a.py' string printed in the console
import a # Same result
Избежать этого можно при помощи магической переменной __name__
По умолчанию она равна '__main__', но если модуль импортируется в другой, ее значение перезаписывается на имя своего модуля
Таким образом следующая конструкция позволит избежать запуска кода модуля (если запуск там есть) при импортировании его
# first.py 
def foo(): 
    pass 
print("printing inside first.py")

# second.py 
from first import foo 
foo() # 'printing inside first.py'

# first.py 
def foo(): 
    pass 
if __name__ == "__main__": 
    print("printing inside first.py")

# second.py 
from first import foo 
foo() # В консоль ничего не будет выведено, так как магическая переменная __name__ в first.py модуле равна '__first__', а не '__main__'

Циклический импорт возникает когда файлы пытаются импортировать функции друг друга
# a.py 
from b import func1 
def func2(): 
    pass

# b.py 
from a import func2 
def func1(): 
    pass

ImportError: cannot import name 'func2' from partially initialized module 'a' (most likely due to a circular import)
Когда Python видит выражение from a import func2, он пытается импортировать func2 из a.py
Однако в a.py, есть также заявление from b import func1, что создает циклический импорт
Вы можете импортировать модуль и использовать модуль.func обозначение для решения этой проблемы (does it works ?)
Другое возможное решение — поместить импорт внутрь функций, чтобы импорт происходил всякий раз, когда вызываются функции
# a.py 
def func2(): 
    from b import func1 
    pass

# b.py 
def func1(): 
    from a import func2 
    pass

При вызове func1 в модуле b, from a import func2 - импортирует модуль а, но так как функция func2 в нем не вызывается - from b import func1 не будет вызван

Код из __init__ файла выполняется во время импорта модулей из его каталого
# folder/__init__.py 
print("inside __init__.py")

# y.py 
from folder import x # "inside __init__.py" - запущен код из файла __init__.py который находится в той же папке folder, где и модуль x.py
Например, можно поместить тесты в__init__.py и таким образом, тесты будут выполняться всякий раз, когда импортируются функции или классы

В общем случае следующие утверждения равнозначны:
from module import func
=
import module
func = module.func
del module

После импорта модуля, его части (функции, переменные) можно передать новым переменным - изменить их имя в модуле, куда они были импортированны
import datetime 
my_time_method = datetime.time 
print(my_time_method())  # 00:00:00 

Пакет в Python — это каталог, который включает в себя другие подпакеты и модули, а также содержит__init__.py файл
Этот файл помогает интерпретатору Python понять, что этот каталог является пакетом
Пакеты должны формировать пространство имен и обеспечивать высокий уровень вложенности
Подпакеты так же должны содержать __init__.py файл и могут содержать модули и другие файлы
				    Package(Robot):
__init__.py file      Sub-package Design      Sub-package Actions      Sub-package Sound
		      __init__.py file        __init__.py file         __init__.py file
		      face.py (module)        walk.py                  alarm.py
		      outfit.py               hello.py
Файл__init__.py может быть пустым, но также может ограничивать, какие объекты будут доступны из пакета через __all__ заявление
# file __init__.py
from module1 import method1
from module2 import method2, method3
__all__ = ("method1", "method2")
Как результат, method3 не будет доступен для импорта в другом коде


В Пайтон, у стандартной библиотеки есть набор различных модулей, например json, time и другие
Но так же можно устанавливать сторонние пакеты, которые не входят в стандартную библиотеку
В Пайтон есть установщик пакетов pip - который управляет зависимостями, которых нет в стандартной библиотеке
Установка сторонних пакетов осуществляется в Терминале
Для установки сторонних библиотек, на ПК должна быть активирована среда, где установлен Пайтон
Активировать среду можно командой source venv/bin/activate для Linux, MacOS и venv/Scripts/activate для Windows
Если это не получилось сделать, нужно убедится что интерпретатор установлен из вашей папки:
File > Settings > Project > Python Interpreter > путь к папке с интерпретатором
Можно добавить новый Add Interpreter > Add Local Interpreter > Location > указать путь к локальной папке с интрепретатором

Скачать и установить сторонний пакет можно командой pip install и название нужного пакета - pip install requests
Удалить - pip unistall название библиотеки
Так же, установить или удалить библиотеку можно перейдя в:
File > Settings > Project > Python Interpreter > клик на кнопку плюс (Install) > в поиске ввести название библиотеки > выбрать и нажать Instal Package
Затем установленую библиотеку можно импортировать в пространство имен текущего модуля

API - это интерфейс для взаимодействия между различными программами
В Пайнтон, использовать API можно установив пакет requests
В пакете requests, у аттрибута response есть встроенный метод json, для работы с этим форматом передачи данных
url = "https://api.binance.com/api/v3/ticker/price" # Ссылка для API запросов
response = requests.get(url, params={'symbol': 'BTCUSDT'}) # Выполняется GET запрос по ссылке, параметры заданы разработчиками ресурса на который отправляется запрос
# Ответ записывается в переменную response
print(response) # <Response [200]>
print(type(response)) # <class 'requests.models.Response'>
content = response.content
print(content) # b'{"symbol":"BTCUSDT","price":"58965.21000000"}' - то что вернул запрос
print(type(content)) # <class 'bytes'>
content_unpack = response.json() # преобразование json в соответствующий тип данных Пайтон
print(content_unpack) # {"symbol":"BTCUSDT","price":"58965.21000000"}
print(type(content_unpack)) # <class 'dict'>
price = float(content_unpack['price']) # После конвертации json в dict, с ним можно взаимодействовать как со словарем
print(price) # 58937.64

ООП (обьектно ориентированное программирование) - методология, стиль программирования, где программа представляется как совокупность обьектов, каждый из которых является экземпляром определенного класса
Класс - это каркас, на основе которого можно создавать неограниченное количество его обьектов
print(type('Hi')) # class str - строка является обьектом класса str
print(type([1, 2, 3]) # class list
print(type(str)) # class type - класс str является обьектом класса type (в Пайтон все является обьектами, в том числе классы)

В Пайтон, класс обьявляется при помощи ключевого слова class, затем идет его название (с большой буквы) и двоеточие
class Warrior:

Метод __init__ магический метод класса, дандер-метод (double underscore), который создает, инициализирует его обьект
Этот метод исполняется каждый раз при создании обьекта определенного класса
В большинстве случаев, он ничего не возвращает (тоесть возвращает None), а только создает новый обьект
def __init__(self):

Ключевое слово self - указатель/ссылка на текущий обьект класса, на самого себя
Так как мы не знает как будет называтся обьект класса после его создания, это ключевое слово означает его при обьявлении класса
После создания обьекта класса, self как бы будет переменной, в которую инициализируется обьект класса
При исполнении аттрибутов/методов обьекта класса, self передавать в них не нужно
def __init__(self, lvl):
    self.level = lvl
Параметры метода __init__ являются агрументами при создании экземпляра класса
class Warrior:
    def __init__(self, lvl):
      # war1.level = lvl # Мы не знаем что обьект класса будет передан переменной war1 при обьявлении класса Warrior
        self.level = lvl

# self не передается
war1 = Warrior(1) # значение для аттрибута level
# Название обьекта класса war1 как бы заменяет self
print(war1.level) # 1
print(type(war1)) # class __main__.Warrior - обьект класса Warrior


Стоит различать переменные, методы Класса и переменные/поля, методы обьекта класса
В методе __init__ указываются аттрибуты/поля/переменные обьекта класса
Переменные класса обьявляются вне метода __init__
Переменные класса будут одинаковыми у всех экземпляров этого класса
class Warrior:
    def __init__(self, lvl):
        self.level = lvl
    
    type = 'Warrior' # аттрибут одинаковый для всех обьектов класса Warrior

war1 = Warrior(1)
print(war1.level) # 1
print(war1.type) # Warrior

war2 = Warrior(5)
print(war2.level) # 5 - аттрибут обьекта класса свой для каждого обьекта класса
print(war2.type) # Warrior - переменная/поле класса Warrior одинаковая у всех обьектов этого класса
Переменная Класса может изменятся отдельно для каждого обьекта класса, после его создания
Изменения переменной класса одного обьекта, в такой способ, применяются только к нему и не затрагивают все другие, уже созданные, обьекты этого класса
war2.type = 'Night warrior'
print(war2.type) # Night warrior
print(war1.type) # Warrior
Так же, доступ к переменным и методам Класса можно получить без обьекта класса, при помощи их полных имен и точечной записи - НазваниеКласса.НазваниеПеременнойЭтогоКласса
print(Warrior.type) # Warrior - обьект класса не используется
Если в методе класса нужно использовать переменную класса, значение которой не было изменено - нужно использовать ее полное имя
Это актуально только для значений неизменяемых типов данных
При изменениях переменных Класса, работают стандартные правила Пайтон для изменяемых и не изменяемых типов данных
Если изменяется неизменяемый тип данных (int, float, bool, str, tuple) - в памяти создается новая переменная с этим значением и обращение уже идет к ней
Если изменяется неизменяемый тип данных, но новое значение идентично предыдущему - новая переменная не создается, а используется уже существующая
Если изменяется изменяемый тип данных (dict, list, set) - изменения вносятся в уже существующую переменную и ее местоположение в памяти - не изменяется
class Warrior:
    def __init__(self, lvl):
        self.level = lvl

    default_type = 'Warrior'  # аттрибут одинаковый для всех обьектов класса Warrior

    def show_default_type1(self):
        return self.default_type  # Обычное имя переменной класса

    def show_default_type2(self):
        return Warrior.default_type  # Полное имя переменной класса

    default_type2 = [1, 2, 3]  # аттрибут одинаковый для всех обьектов класса Warrior

    def show_default_type12(self):
        return self.default_type2  # Обычное имя переменной класса

    def show_default_type22(self):
        return Warrior.default_type2  # Полное имя переменной класса


war1 = Warrior(4)
war2 = Warrior(5)
war1.default_type = 'Skilled warrior'
print(war1.show_default_type1())  # Skilled warrior - измененное значение
print(war2.show_default_type1())  # Warrior
print(war1.show_default_type2())  # Warrior - стандартное значение переменной класса
print(war2.show_default_type2())  # Warrior
war1.default_type2.append('New_value')
print(war1.show_default_type12())  # [1, 2, 3, 'Skilled warrior'] - измененное значение
print(war1.show_default_type22())  # [1, 2, 3, 'Skilled warrior'] - так же измененное значение, потому что тип данных list - изменяемый

Переменные класса являются общими для всех обьектов класса, они являются как бы глобальными переменными для всех них
И значение переменной класса можно изменить для всех обьектов этого класса снаружи класса используя имя обьекта класса, свойство __class__ и название нужной переменной
НазваниеОбьектаКласса.__class__.НазваниеПеременнойКласса
class Warrior:
    def __init__(self, lvl):
        self.level = lvl

    default_type = 80  # аттрибут одинаковый для всех обьектов класса Warrior

    def show_default_type1(self):
        print(id(self.default_type))
        return self.default_type

    def show_default_type2(self):
        print(id(self.default_type))
        return Warrior.default_type

war1 = Warrior(1)
war2 = Warrior(2)
print(war1.default_type)  # 80
print(war2.default_type)  # 80
print(war1.show_default_type1())  # 80
print(war1.show_default_type2())  # 80
print(war2.show_default_type1())  # 80
print(war2.show_default_type2())  # 80
war1.__class__.default_type = 1100
print(Warrior.default_type)  # 1100 - переменная класса изменилась в самом классе
print(war1.default_type)  # 1100
print(war2.default_type)  # 1100 - переменная класса изменилась у уже существующего обьекта класса
print(war1.show_default_type1())  # 1100
print(war1.show_default_type2())  # 1100
print(war2.show_default_type1())  # 1100
print(war2.show_default_type2())  # 1100
new_war = Warrior(5)
print(new_war.default_type)  # 1100
print(new_war.show_default_type1())  # 1100
print(new_war.show_default_type2())  # 1100 - переменная класса имеет новое, измененное значение у новых обьектов этого класса
Но, если до изменения переменной класса при помощи свойства __class__, она была изменена у какого либо из обьектов этого класса, то ее значение у этого обьекта неизменится
class Class2:
    def __init__(self, v):
        self.num = v

    out = 10

    def show1(self):
        return self.num * self.out

    def show2(self):
        return self.num * Class2.out


ob1 = Class2(2)
print(ob1.show1()) # 20
print(ob1.show2()) # 20
ob2 = Class2(2)
print(ob2.show1()) # 20
print(ob2.show2()) # 20 - переменная класса out одинакова у всех обьектов этого класса
ob3 = Class2(11)
print(ob3.show1()) # 110
print(ob3.show2()) # 110
ob1.out = 20 # - изменение переменной класса у обьекта этого класса
ob2.out = 1 # переменная класса у обьекта ob2 теперь равна 1
print(ob1.show1()) # 40 - значение пересчитано в соответствии с новым значением переменной класса out для обьекта ob1
print(ob1.show2()) # 20 - значение осталось без изменений, так как в методе show2 используется переменная класса с изначальным значением - Class2.out
print(ob2.show1()) # 2 - значение пересчитано в соответствии с новым значением переменной класса
print(ob2.show2()) # 20 - значение осталось без изменений
print(ob3.show1()) # 110 - значение осталось без изменений, так как переменная out не изменялась для обьекта ob3
print(ob3.show2()) # 110 - значение осталось без изменений
Значение осталось без изменений, потому что переменная класса out была изменена для конкретных обьектов ob1 и ob2, а не для всего класса
Метод show1 использует переменную класса текущего обьекта класса - self.out
Метод show2 - просто переменную класса - Class2.out

ob1.__class__.out = 500 # Изменение значения переменной класса out для всего класса и всех его обьектов, уже существующих и тех, что будут созданны 
print(Class2.out) # 500
print(ob1.out) # 20 - значение переменной класса out у обьекта ob1 осталось прежним
print(ob2.out) # 1 - значение осталось прежним
print(ob3.out) # 500 - значение переменной класса out у обьекта ob3 изменилось
print(ob1.show1()) # 40 - значение осталось прежним, потому что self.out не изменился
print(ob1.show2()) # 1000 - значение пересчиталось, потому что Class2.out - изменилось
print(ob2.show1()) # 2 - значение осталось прежним
print(ob2.show2()) # 1000 - значение пересчиталось
print(ob3.show1()) # 5500 - значение не изменилось
print(ob3.show2()) # 5500 - значение не изменилось
Значение переменной класса out у обьектов ob1 и ob2 не измеилось, после ее изменения для всех обьектов этого класса при помощи свойства __class__
Потому что, значение этой переменной - неизменяемого типа данных
Когда значение out было изменено ранее, на 20 и 1 соответственно, self.out этих обьектов стал ссылатся, не на переменные out которые у них были после создания.
А на новые переменные, созданные в новых ячейках памяти, после изменения, значения которых 20 и 1
Это происходит всегда при изменении неизменяемых типов данных, изменяются не уже существующие переменные, а создаются новые
Значение переменной out для обьекта ob3, не изменялось ранее и ссылка на нее осталась без изменений
Поэтому, после изменения ее значения для всех обьектов - оно изменилось для этого обьекта класса


Методы Класса обьявляются при помощи декоратора @classmethod и первым параметром у них является cls
cls (по аналогии с self только для класса) - это указатель/ссылка на текущий класс
@classmethod
def sum_pows(cls):
В методах класса получить доступ к переменным этого класса можно при помощи ключевого слова cls - cls.all_objects
Снаружи класса доступ к методам класса осуществляется, как и к переменным, при помощи названия класса, точки и названия метода
MyClass.sum_pows()
class Class1:

    all_objects = []

    def __init__(self, val):
        Class1.all_objects.append(self)
        self.value = val

    def show(self):
        return self.value


    @property
    def show_pr(self):
        return self.value

    @classmethod
    def show_class(cls):
        return 'Hi'

    def pow_num(self):
        return self.value ** 2

    @classmethod
    def sum_pows(cls):
        res = 0
        for o in cls.all_objects:
            print(o)
            res += o.pow_num()  # В данном случае метод pow_num ИДЕ не подсветит, как один из доступных*

        return res

obj4 = Class1(4)
obj5 = Class1(5)
obj6 = Class1(6)
print(obj4.show())  # 4
print(obj4.show_pr)  # 4
print(Class1.show_class())  # Hi
print(Class1.sum_pows())  # 77
obj7 = Class1(1)
print(Class1.sum_pows())  # 78
* Для этого нужно воспользоватся typing hints - импортировать Self из модуля typing
from typing import Self
И изменить обьявление переменной класса all_objects
all_objects: list[Self] = []
Тогда ИДЕ покажет метод pow_num() как доступный для переменной o в цикле for

Обьекты класса смотрят на переменные класса
Изменять переменные класса можно при помощи имени класса, а так же обьектов этого класса
Но, изменение переменных классов при помощи обьектов этого класса - изменит их только для этого конкретного обьекта,
а все остальные, уже созданные и новые, будут смотреть на переменную указаную в определении класса и ее значение
f_p = Person('f_p')
p1 = Person(1)
print('p1', p1.outer) # p1 111
print('P class', Person.outer) # P class 111
p1.outer = 222  # Изменение переменной класса outer через обьект этого класса p1 - не изменит ее внутри класса, а только внутри обьекта p1
print('p1 after change', p1.outer) # p1 after change 222, вместо 111
print('P class', Person.outer)  # P class 111 - в классе значение не изменилось
p2 = Person(2)
print('p2', p2.outer) # p2 111 новый обьект класса смотрит на переменную класса, а ее значение не изменилось и равно 111
print('P class', Person.outer) # P class 111 - переменная класса не изменилась
print(f_p.outer) # 111 значение переменной класса так же не изменилось у обьекта этого класса созданого до изменения

Что бы изменить переменную класса в самом классе и, как следствие, у всех его обьектов, уже созданных и новых, нужно использовать метод класса @classmethod
    @classmethod
    def change(cls, v):
        cls.outer = v
Его можно вызывать как от обьекта класса так и от его имени, потому что первый аргумент указывает на класс (а не на обьект self)
f_p = Person('f_p')
print(f_p.outer) # 111
p11 = Person(1)
print(p11.outer) # 111
p11.change(22) # Вызов метода класса от обьекта изменит переменную класса
# Person.change(22) # Вызов метода класса от имени класса так же изменит значение переменной в классе и у всех обьектов этого класса
print(p11.outer) # 22

p22 = Person(2)
print(p22.outer) # 22
print(f_p.outer) # 22


Статический метод класса обьявляется при помощи декоратора @staticmethod
Переменную, метод класса и статический метод класса, в отличие от полей и методов обьекта класса, можно вызывать без обьекта класса, а используя имя класса
Но, так же, переменные, методы класса и статические методы можно вызывать при помощи обьекта класса
class Class3:
    def __init__(self, val):
        self.n = val

    out_val = 7

    def show(self):
        return self.n

    @classmethod
    def show_class2(cls):
        return cls.out_val


    @staticmethod
    def show_static():
        return Class3.out_val


print(Class3.show_class2()) # 7 - метод класса вызывается через имя этого класса
print(Class3.show_static()) # 7 - статический метод вызывается через имя класса
o1 = Class3()
print(o1.show_class2()) # 7 - метод класса вызывается через обьекта этого класса
print(o1.show_static()) # 7 - статический метод вызывается через обьект
При помощи статических методов можно обходить отсутствие перегрузки конструктора/метода инициализации обьектов класса в Пайтон
Такие статические методы должны возвращать обьекты класса, с нужными отличиями от обьектов, созданных при помощи стандартного метода __init__
class Class3:
    def __init__(self, val):
        self.n = val

    # Статический метод возвращающий новый обьект класса
    @staticmethod
    # Self cannot be used in the static methods
    # def new_init(value) -> Self:
    def new_init(value) -> 'Class3':
        return Class3(value+1)

o1 = Class3(1)
print(o1.n) # 1
o2 = Class3.new_init(1)
print(o2.n) # 2 - Создан обьект класса Class3 

Что бы метод класса возвращал новый обьект класса, после слова return необходимо указать имя нужного класса и вызвать его конструктор, с помощью двух круглых скобок ()
А в качестве возвращающего типа данных, этого метода, можно указать имя нужного класса, но это не обязательно
class Class4():
    def __init__(self, v):
        self.i = v*10

    @staticmethod
    def new_init(vol) -> Class3: # Возвращаемый тип данных - Class3
        return Class3(vol) # Вызывается конструктор класса Class3, который в результате своего вызова вернет новый обьект класса и его же вернет этот статический метод new_init

o3 = Class3(1)
print(isinstance(o3, Class3)) # True
print(o3.n) 1
o4 = Class4(1)
print(isinstance(o4, Class4))  # True
print(o4.i) # 10
o5 = Class4.new_init(1)
print(isinstance(o5, Class3))  # True
print(o5.n) # 1

Итого, существует 3 типа методов:
1.) Методы экземпляра класса (так же существуют поля экземпляра класса - обьявляются в методе-конструкторе __init__)
2.) Методы класса (так же есть переменные класса- обьявляются вне методов)
3.) Статический метод
class MyClass:
    def __init__(self, value):
        self.start = value

    out = 10

    def instance_method(self):
        return self.start + 1

    @classmethod
    def class_method_like_init(cls, v):
        obj = cls(v)
        print('class method like init, obj start =', obj.start)
        return obj.instance_method()

    @staticmethod
    def static_method(val):
        # Has access to the attributes of the class only by its name
        # Cannot get them in other way
        # return MyClass.out
        return MyClass.class_method_like_init(val)
Обязательно, первым параметром в методе экземпляра класса идет self - ссылка/указатель на текущий обьект класса, тоесть на самого себя
Название self - общепринятое, но не обязательное, можно использовать любое название, главное что б оно стояло на первом месте
Длагодаря self имеют доступ к аттрибутам экземпляра класса и могут менять его поведение
Так же, используя self.__class__ можно получить доступ к переменным и методам самого класса и менять его состояние
Изменение переменных класса приводит к их изменениям для всех обьектов этого класса, как уже существующих так и новых
Метод экземпляра класса вызывается от созданного экземпляра
o1.instance_method()
Так же, может вызыватся и от класса, но тогда в качестве аргумента должен принимать существующий обьект этого класса
MyClass.instance_method(o1)

Метод класса обьявляется при помощи декоратора @classmethod
Обязательно, в качестве первого параметра принимает cls - ссылку/указатель на текущий класс/самого себя
Методы класса привязаны к самому классу, а не его экземплярам
Благодаря cls имеют доступ к переменным и методам класса и могут менять его поведение, что отразится на всех обьектах этого класса
Но не могут изменять конкретный, отдельный обьект класса

Статические методы обьявляются при помощи декоратора @staticmethod
Им не нужен определенный, обязательный первый параметр (как self или cls)
Статические методы прикреплены к классу "для удобства" и не могут изменять поведение ни класса, ни его экземпляров
Эти методы не имеют доступа ни к аттрибутам класса, ни к аттрибутам экземпляра класса
Они могут работать только с теми данными, которые им передаются в качестве параметров
Вызов через точку нужен лишь для удобства. На самом же деле в случае статического метода никакие аргументы (self или cls) методу не передаются

Метод экземпляра класса, метод класса и статический метод можно вызывать от обьекта класса
o1.instance_method()
o1.class_method(1)
o1.static_method(2)
Метод класса и статический метод можно вызывать от класса
MyClass.class_method(1)
MyClass.static_method(2)
Но вызов метода обьекта класса от класса - приведет к ошибке, так как в этот метод не передается обьект этого класса (self - обьект класса)
MyClass.instance_method() # TypeError: MyClassAgain.obj_method() missing 1 required positional argument: 'self'

Метод экземпляра класса имеет доступ к обьекту класса через параметр self и к классу через свойство self.__class__ и может менять их
Метод класса имеет доступ к классу через параметр cls и может его менять, но не имеет доступ к обьектам класса
Этот метод часто используется как генерирующий метод для создания нового обьекта класса, но не обычного, как в методе __init__, а измененного
Статические методы работают как обычные функции, но принадлежат области имён класса.
Они не имеют доступа ни к самому классу, ни к его экземплярам, используются как вспомогательные и работают с данными, которые им передаются


Для создания обьекта класса - указывается название класса и круглые скобки, которые вызывают метод init
Каждый обьект класса получает свое имя - присваивается переменной
war1 = Warrior(3)
print(war1) # <__main__.Warrior object at 0x000001A94F0D5D00> - обьект класса Warrior в ячейке памяти 0x000001A94F0D5D00
print(type(war1)) # <class '__main__.Warrior'> - обьект класса Warrior, тип - Warrior
Доступ к аттрибутам обьекта класса осуществляется с помощью точечной записи
Аттрибуты, которые не являются методами, вызываются без круглых скобок
print(war1.level) # 3
war1.attack() # attack является методом класса
Магические методы определяют как будет вести себя обьект класса с различными конструкциями языка
Например магический метод __str__ отвечает за то, что будет выведено в консоль, когда обьект будет передан в функцию print
print(war1) # <__main__.Warrior object at 0x000001A94F0D5D00> - стандартный магический метод __str__ в классе Warrior
def __str__(self):
    return f"This warrior has level {self.level}"

print(war1) # This warrior has level 3 - после изменения магического метода __str__


Свойства класса (property), указываются при помощи символа @ и слова property
Свойства класса невозможно изменить в самом классе или за его пределами
Доступ к свойствам так же осущевствляется через точечную запись
При использовании свойств круглые скобки не указываются
@property
def defense(self):
    armour = 5
    if self.hp < 30:
        armour *= 3
    return armour

war1.defense = 10 # AttributeError: property 'armour' of 'Warrior' object has no setter - свойство класса defense нельзя изменить вне класса
print(war1.defense) # 5 # Круглые скобки не указываются
В свойствах класса можно производить какие либо расчеты
class Warrior:
    def __init__(self, lvl):
        self.level = lvl
        self.base_hp = 100
        self.hp = self.base_hp * self.level
        self.full_hp = self.base_hp * self.level


    @property
    def heal(self):
	self.defense = 10 # AttributeError: property 'armour' of 'Warrior' object has no setter - свойство класса defense нельзя изменить внутри класса
        if (100 * self.hp) / self.full_hp < 45:
            self.hp += self.hp / 2

war1.hp = 50
print('hp before heal', war1.hp) # 50
war1.heal
print('hp after heal', war1.hp) # 75.0

Свойства класса можно использовать в других расчетах
damage = 10
war1.hp -= damage - war1.defense # 100 - (10 - 5) = 95. Использовано свойство defense

Что бы изменять аттрибуты класса в свойствах - их названия должны отличатся
class Warrior:
    def __init__(self, lvl):
        self.skill = 0

    @property
    def skilled(self):
        self.skill += 123456789

    @property
    def skill(self): # Error
        self.skill += 123456789

    @property
    def skill(self): # Error
        skill += 123456789

    @property
    def skilled(self): # UnboundLocalError: cannot access local variable 'skill' where it is not associated with a value
        skill += 123456789


war1 = Warrior(1)
print(war1.skill) # 0
war2.skilled
print(war1.skill) # 123456789

К свойствам класса @property нужно обращатся, как к полям (переменным), тоесть без использования круглых скобок
class MyClass:
    def __init__(self, mark, model, year, power):
        self.mark = mark
        self.model = model
        self.year = year
        self.power = power

    def minus1(self):
        return self.year - self.power


    @property
    def minus2(self):
        return self.year - self.power

obj1 = MyClass('BMW', 'X5', 2024, 500)
print(obj1.minus1()) # 1524 # Обращение к методу экземпляра класса требует 2 круглых скобок ()
print(obj1.minus2()) # TypeError: 'int' object is not callable
print(obj1.minus2) # 1524 # Обращение к property/свойству экземпляра класса происходит как к полю - без круглых скобок
print(obj1.minus3)


Часто, доступ к аттрибутам класса должен быть ограничен и в Пайтон это реализовано при помощи сокрытия
Коли ви використовуєте два підкреслення перед ім'ям змінної (як у self.__secret), це означає, що змінна є приватною для класу
Це частина механізму, званого "іменне маніпулювання" (name mangling).
Це означає:
1.) Приватність:
Змінна __secret не повинна бути доступною ззовні класу. Це частина інкапсуляції, яка допомагає захистити дані.
2.) Іменне маніпулювання:
Python автоматично змінює ім'я __secret на _TestClass2__secret, щоб уникнути конфліктів з атрибутами з такими ж іменами в дочірніх класах.
class TestClass2:
    def __init__(self, v):
        self.__secret = v
Ви можете отримати доступ до __secret лише зсередини методів цього класу. Ззовні доступ буде обмежено.
Ви можете змінити значення приватної змінної, але лише зсередини самого класу
Для отримання або зміни значення приватної змінної ззовні - вам потрібно створити відповідні методи в класі.
Наприклад, ви можете створити методи для отримання і зміни значення:
class TestClass2:
    def __init__(self, v):
        self.__secret = v

    def get_secret(self): # Для отримання значення змінної __secret
        return self.__secret

    def set_secret(self, new_value): # Для зміни значення змінної __secret
        self.__secret = new_value

obj = TestClass2(10)
print(obj.get_secret())  # Виведе 10
obj.set_secret(20)
print(obj.get_secret())  # Виведе 20
Таким чином, ви контролюєте доступ до приватної змінної через методи, що забезпечує інкапсуляцію

Но, зная что Пайтон изменяет имена приватных переменных - мы все равно можем получить к ним доступ вне класса без специальных методов, просто использовав их измененные имена
Имена приватных переменных изменяются Пайтон таким способом _НазваниеКласса__НазваниеПеременной
Тоесть __secret будет переименована в _TestClass2__secret
А получить доступ к аттрибутам обьекта класса можно через точечную запись
print(obj1._TestClass2__secret) # 20

Також це можна зробити використовуючи властивості @property та сеттер до них
Сеттер до властивості приймає лише один параметр окрім self
Ім'я методу сеттер повинно відповідати імені властивості, яка в ньому змінюєтся (але помилку це не викликає)
class TestClass:
    def __init__(self, a, b, a1, b1):
        self.start = a
        self.__secret = b
        self.start2 = a1
        self.__secret2 = b1
	# self.__secret *= 10 # Зміна приватного атрибуту класа всередині самого класа

    def show_secret(self):
        return self.__secret

    def change_secret(self, c):
        self.__secret = c

    @property
    def show_secret2(self): # Властивість классу для отримання приватної змінної за межами классу
        return self.__secret2

    @show_secret2.setter # Сеттер властивості @property
    def change_secret2(self, e): # Властивість классу для зміни приватної змінної за межами классу
        self.__secret2 = e

    @show_secret2.setter # Сеттер властивості @property
    def show_secret2(self, e, e1): # Викличе помилку, через другий параметр - е1
        self.__secret2 = e


o1 = TestClass(1, 2, 3, 4)
print('start', o1.start)
# AttributeError: 'TestClass' object has no attribute 'secret'
# print(o1.secret)
# AttributeError: 'TestClass' object has no attribute '__secret'. Did you mean: 'show_secret2'?
# print(o1.__secret)
# AttributeError: 'TestClass' object has no attribute 'secret2'. Did you mean: 'show_secret2'?
# print(o1.secret2)
# AttributeError: 'TestClass' object has no attribute '__secret2'. Did you mean: 'show_secret2'?
# print(o1.__secret2)

o1.secret = 5
print(o1.secret)  # 5 - New attribute secret created
o1.__secret = 8
print(o1.__secret)  # 8 - New attribute __secret created
print(dir(o1))  # ['_TestClass__secret', '__secret', 'secret', ...]
print('show secret before change', o1.show_secret())
o1.change_secret(9)  # The value of the _TestClass__secret private attribute changed to 9
print('show secret after change', o1.show_secret())

print('start2', o1.start2)
o1.secret2 = 'Hi'
print(o1.secret2)  # Hi - New attribute secret created
o1.__secret2 = 'Wow'
print(o1.__secret2)  # Wow - New attribute __secret created
print(o1.show_secret2)
print(dir(o1))  # ['_TestClass__secret2', '__secret2', 'secret2', ...]
o1.change_secret2 = 11
print(o1.show_secret2)

Також getter для приватних змінних може мати такеж ім'я як і сама змінна
І це буде більш правильно, тому що звертаючись до імені цієї змінної можна отримати її значення, а також змінити його
class Driver7:
    def __init__(self, v):
        self.__start = v

    @property
    # def getter_different_name(self):
    def start(self):
        return self.__start

    @start.setter
    # def setter_different_name(self, v): # Інше ім'я для setter
    def start(self, v):
        self.__start = v

driver7 = Driver7(4)
# print(driver7.getter_different_name)
print(driver7.start) # 4 # Звертаючись до імені приватної змінної можна отримати її значенния
# driver7.setter_different_name = 12
driver7.start = 10 # За допомогою імені приватної змінної можно змінити її значення
print(driver7.start) # 10

Поля обьекта класса можно обьявлять и после его создания, однако это считается плохим примером и так делать не стоит
war1.mana = 4500
Все поля нужные обьекту должны быть обьявлены в его классе (в методе init или снаружи), а не в обьекте


Пайтон не поддерживает перегрузку методов - несколько реализаций одного метода (с разным количеством параметров, результатом) с одним и тем же названием
class MyClass:
  def plus(self):
    return 3
    
  def plus(self, a): # В данном примере происходит пепезапись метода plus, а не его перегрузка
    return 2+a
  
    
a = MyClass()
print(a.plus()) # TypeError: plus() missing 1 required positional argument: 'a'

Но в тоже время
class TestClass:
    def __init__(self, a):
        self.__secret = a

    @property
    def show_secret(self):
        return self.__secret

    @show_secret.setter
    def show_secret(self, e):
        self.__secret = e

o1 = TestClass(1)
print(o1.show_secret) # 1 # Свойство для получения приватной переменной
o1.show_secret = 11 # Одноименное свойство для изменения приватной переменной
print(o1.show_secret) # 11 # И оба свойства выполнились верно
Почему, если Пайтон не поддерживает перегрузку методов ? Или он поддерживает перегрузку свойств @property ?
В данном случае у методов одинакоевое имя, но один является геттером, а второй сеттером
У цьому прикладі метод show_secret2 не є перевантаженням у класичному розумінні, оскільки в Python властивості (property) не перевантажуються
Натомість, Python дозволяє створювати властивості з одним і тим самим іменем, але різними доступами до них (getter і setter).
Як це працює:
Коли ви визначаєте метод як властивість за допомогою декоратора @property, ви створюєте getter, який дозволяє отримати значення приватної змінної.
Декоратор @show_secret2.setter створює setter, який дозволяє змінювати значення тієї ж змінної через ту саму властивість.
Це не перевантаження, а скоріше стандартна практика для створення інтерфейсу доступу до приватних змінних через властивості.
class TestClass:
    def __init__(self, a, b, a1, b1):
        self.start = a
        self.__secret = b
        self.start2 = a1
        self.__secret2 = b1

    @property
    def show_secret2(self):
        return self.__secret2  # Getter для отримання значення __secret2

    @show_secret2.setter
    def show_secret2(self, e):
        self.__secret2 = e  # Setter для зміни значення __secret2


@property дозволяє викликати o1.show_secret2 без круглих дужок, як атрибут, хоча це фактично метод для отримання значення.
@show_secret2.setter дозволяє змінювати значення приватної змінної, використовуючи ту ж властивість o1.show_secret2, наприклад, o1.show_secret2 = 11.
Метод show_secret2 не перевантажується, а використовується як властивість з двома доступами: один для отримання значення (getter) і один для його зміни (setter)
Це стандартна концепція у Python для роботи з інкапсуляцією даних через властивості

Для иммитации перегрузки методов можно использовать
1.) Значения аргументов по умолчанию
class MyClass:
    def my_method(self, a=None, b=None):
        if a is not None and b is not None:
            print(f"Two arguments: a = {a}, b = {b}")
        elif a is not None:
            print(f"One argument: a = {a}")
        else:
            print("No arguments")

obj = MyClass()
obj.my_method()       # No arguments
obj.my_method(1)      # One argument: a = 1
obj.my_method(1, 2)   # Two arguments: a = 1, b = 2

2.) Неопределенное количество аргументов - *args (для позиционных аргументов) и *kwargs (для аргументов с ключевыми словами)
class MyClass:
    def my_method(self, *args):
        if len(args) == 1:
            print(f"One argument: {args[0]}")
        elif len(args) == 2:
            print(f"Two arguments: {args[0]}, {args[1]}")
        else:
            print(f"{len(args)} arguments passed")

obj = MyClass()
obj.my_method(1)          # One argument: 1
obj.my_method(1, 2)       # Two arguments: 1, 2
obj.my_method(1, 2, 3)    # 3 arguments passed


1.) Наследование - концепция обьектно-ориентированного программирования, согласно которой, абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа,
способствуя повторному использованию компонентов и расширению имеюшегося функционала
Наследование - это механизм создания объекта или класса на основе другого объекта или класса с сохранением аналогичной реализации
2.) Полиморфизм (многообразие) - понятин, которое позволяет разным сущностям выполнять одни и те же действия
Возможность использовать одни и те же методы для объектов разных классов
Переопределение является полиморфизмом ?
Полиморфизм - это предоставление единого интерфейса для сущностей разных типов или использование одного символа для представления нескольких разных типов
3.) Инкапсуляция - принцип, согласно которому внутреннее устройство сущностей нужно собирать, объединять в специальной «оболочке» и скрывать от вмешательств извне.
Доступ к объектам возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.
Упаковка данных и функций в один компонент (например, класс) и последующий контроль доступа к этому компоненту, создавая тем самым "чёрный ящик" из объекта.
По этой причине, пользователю необходимо знать только интерфейс этого класса (то есть данные и функции, предоставляемые для взаимодействия с классом извне), а не то, как он реализован внутри.
Инкапсуляция реализуется при помощи классов, модулей и модификаторов доступа
Инкапсуляция подразумевает объединение данных с методами, которые работают с этими данными, или ограничение прямого доступа к некоторым компонентам объекта
4.) Абстракция
5.) Сокрытие данных/информации - обычно реализуется с помощью модификаторов доступа, часто путают с инкапсуляцией
В Пайтон существует два типа модификаторов доступа: protected и private
Чтобы обозначить атрибут как защищенный, необходимо поставить одно подчеркивание перед именем атрибута - _protected_variable
Частный аттрибут обьявляется с использованием двойного подчеркивания - __private_variable
Однако Python не гарантирует конфиденциальность, и вы все равно можете получить к ним доступ
Чтобы получить доступ к защищенной переменной, вам нужно поставить одно подчеркивание перед именем атрибута - obj._job_title # 'Software Engineer'
Но чтобы получить доступ к закрытому атрибуту, нужно использовать синтаксис obj._ИмяКласса__ИмяАтрибута - obj._Employee__salary # 3000


1.) Наследование
Одни классы могут наследовать другие, тем самым получая все их аттрибуты и расширяя их своими собственными
Таким образом, в классах наследниках не нужно дублировать аттрибуты класса родителя
Для наследования классов, в Пайтон, родительский класс нужно указать в круглых скобках при обьявлении нового класса
class Parent:
    pass

class Child(Parent): # Класс Child наследует класс Parent
    pass
В классе родителе можно указывать свойства, которые отсутствуют в нем, но есть в классах наследниках
В таком случае, такой код будет корректно выполнятся для обьектов классов наследников, потому что там эти аттрибуты обьявлены
Конечно же, с экземплярами родительского класса - выпадет ошибка, так как в нем они не определены
class Character:
    def __init__(self, lvl):
        self.level = lvl
        self.hp = self.base_hp * self.level # self.base_hp - нет в классе Character, но есть в классе наследнике Elf
        self.attack_points = self.base_attack_points * self.level # self.base_attack_points так же нет в классе Character, но есть в классе наследнике Elf

class Elf(Character):
    character_name = 'Elf'
    base_hp = 50 # base_hp аттрибут определен
    base_attack_points = 15 # base_attack_points аттрибут так же обьявлен
    base_defence = 10

main_char = Character(5) # AttributeError: 'Character' object has no attribute 'base_hp'
elf1 = Elf(5) # обьект класса создан успешно


Если метод-конструктор не указан в классе наследнике, то при создании его обьектов по умолчанию вызывается метод __init__ класса родителя
class Employee:
    def __init__(self, name, id, age):
        self.name = name
        self.id = id
        self.age = age


    def __str__(self):
        return f"The employee's name is {self.name}, id is {self.id} and age is {self.age}"

class Driver2(Employee):
    pass # Метод __init__ не указан в классе наследнике и поэтому будет вызван этот метод из родительского класса

driver2 = Driver2('Max', 2, 23)
print(driver2.name) # Max
print(driver2) # The employee's name is Max, id is 2 and age is 23

Так же проинициализировать все нужные аттрибуты обьекта класса наследника можно вручную в его собственном методе __init__, и в нем же можно добавить новые аттрибуты
class Driver2(Employee):
    def __init__(self, name1, id1, auto_type, age1):
	self.name = name
        self.id = id
        self.age = age
	self.auto_type = auto_type # Добавление нового аттрибута обектам класса наследника. У обьектов класса родителя их не будет
Но это не удобно и не совсем правильно
Правильно это делать - при помощи вызова метода-конструктора __init__ класса родителя в методе __init__ класса наследника
Сделать это можно при помощи метода super()
super() - это метод который указывает на родительский класс и вызывает методы родительского класса
Если в классе наследнике нужно получить доступ к методам родительского класса нужно использовать метод super() (а не ключевое слово self ?)
Так же, в методе-конструкторе __init__ класса наследника можно добавлять новые аттрибуты его обьектам
class Employee:
    def __init__(self, name, id, age):
        self.name = name
        self.id = id
        self.age = age

    parent_out = 11

    def __str__(self):
        return f"The employee's name is {self.name}, id is {self.id} and age is {self.age}"

class Driver2(Employee):
    def __init__(self, name1, id1, auto_type, age1):
	super().__init__(name1, id1, age1) # Вызов метода __init__ класса родителя и передача ему параметров
	self.auto_type = auto_type # Добавление нового аттрибута обектам класса наследника. У обьектов класса родителя их не будет


driver2 = Driver2('Alex', 3, 'SUV', 27)
print(driver2.name) # Alex
print(driver2.auto_type) # SUV
print(driver2) # The employee's name is Alex, id is 3 and age is 27

Все аттрибуты и методы обьекта класса родителя, переменные, методы, статические методы и свойства @property класса родителя доступны обьектам класса наследника при помощи точечной записа
???

В классе наследнике можно получить доступ к:
1.) аттрибутам (обьявляются в методе __init__) и методам обьекта класса родителя
2.) переменным (обьявляются вне метода __init__) и методам класса (@classmethod) родителя
3.) статическим методам (@staticmethod) класса родителя
4.) свойствам @property класса родителя
Все они доступны в методах класса наследника при помощи ключевого слова self

class Employee:
    def __init__(self, name: str, id: int, age: int = 16):
        self.name = name
        self.id = id
        self.age = age

    parent_out = 7

        # AttributeError: 'Employee' object has no attribute 'instance_method1'. Did you mean: 'instance_method'?
        # def instance_method1(self):
        #     return self.name
        #
        # @classmethod
        # def class_method1(cls):
        #     obj = cls('ClassMethod', 888, 999)
        #     return obj.name
        #
        # @staticmethod
        # def static_method1():
        #     return 'This is a static method'
        #
        # @property
        # def prop1(self):
        #     return self.name

    def parent_instance_method(self):
        # return self.name
        return 10

    @classmethod
    def parent_class_method(cls):
        print(f"cls leads to the {cls} class")
        # obj = cls('ClassMethod', 888, 999)
        # return obj.name
        return 11

    @staticmethod
    def parent_static_method():
        # return 'This is a static method'
        return 12

    @property
    def parent_prop(self):
        # return self.name
        return 13

class Driver2(Employee):
    def __init__(self, n, id, a):
        # self.name = n # Избежать обьявления и инициализации наследуемых аттрибутов класса наследника, можно вызвав метод-конструктор __init__ родительского класса при помощи метода super()
        # self.id = id
        # self.age = a
        super().__init__(n, id, a) # Вызов метод-конструктор __init__ родительского класса при помощи метода super()

        if self.age < 18:
            self.id = 0

        self.child_instance_method_res = self.parent_instance_method() * 10 # Все методы обтекта класса родителя доступны в классе наследнике при помощи ключевого слова self
        self.child_class_method_res = self.parent_class_method() * 10
        self.child_static_method_res = self.parent_static_method() * 10
        self.child_prop_res = self.parent_prop * 10
        self.check_parent_out = self.parent_out
        # self.check = super().parent_class_method() # Доступ к методом класса наследника при помощи метода super()
        # self.check2 = self.parent_class_method() # Доступ к методом класса наследника при помощи ключевого слова self

    def child_instance_method(self):
        res = []
        res.append(self.parent_instance_method() * 10) # Все методы обтекта класса родителя доступны в классе наследнике при помощи ключевого слова self
        res.append(self.parent_class_method() * 10)
        res.append(self.parent_static_method() * 10)
        res.append(self.parent_prop * 10)
        res.append(self.parent_out * 10)
        return res

    child_out = 77


driver2 = Driver2('Alexander', 3, 7)
print(driver2.age) # 7
print(driver2.id) # 0 Because age < 18
print(driver2.child_instance_method_res) # 100
print(driver2.child_class_method_res) # 110
print(driver2.child_static_method_res) # 120
print(driver2.child_prop_res) # 130
print(driver2.child_parent_out) # 7
print(driver2.child_out) # 77
print(driver2.child_instance_method()) # cls leads to the <class '__main__.Driver2'> class (declared in the parent_class_method) # [100, 110, 120, 130, 70]
print(driver2.parent_out) # 7 - Обьект класса наследника имеет доступ к методам класса родителя
print(driver2.parent_instance_method()) # 10 - Обьект класса наследника имеет доступ к методам класса родителя
# print(driver2.check)
# print(driver2.check2)


Доступ к переменным и свойствам @property класса родителя в классе наследнике при помощи метода super()
Но лучше использовать ключевое слово self
В классе наследнике можно получить доступ к свойствам @property родительского класса в свойствах класса наследника, с помощью встроенной функции super()
Доступ возможен только внутри свойств класса наследника @property и только к свойствам @property и тем, что обьявлены вне функции __init__, в родительском классе
super().parent_property
class Cl1:
    def __init__(self, a):
        self.start = a - недоступно в классе наследнике нигде

    out = 10 - доступно в классе наследнике, только в @property

    @property - доступно в классе наследнике, только в @property
    def check1(self):
        return self.start

class Cl2(Cl1):
    # The access to the attributes of the parent class in the __init__ method is absent with the super() method
    # RuntimeError: super(): no arguments
    # cl2_start = super().start - свойство родительского класса из метода __init__, недоступно в классе наследнике

    # RuntimeError: super(): no arguments
    # cl2_start = super().check1 - доступно только внутри @property

    # RuntimeError: super(): no arguments
    # cl2_start = super().out - доступно только внутри @property

    # The access is absent even in the property of the child class
    # @property
    # def change_start(self):
    #     return super().start - свойство родительского класса из метода __init__, недоступно в классе наследнике

    @property
    def change_start(self):
        return super().check1 * 10 - доступно только внутри @property

    @property
    def change_out(self):
        return super().out * 10 - доступно только внутри @property

    def show_self(self): # Лучше использовать ключевое слово self, оно дает доступ к данным класса родителя внутри методов класса наследника
        return [self.check1 * 10, self.out * 10]

class2 = Cl2(1)
print(class2.start) # 1
print(class2.change_start) # 10
print(class2.change_out) # 100
print(class2.show_self()) # [10, 100] - те же значения


@property - это стандартный декоратор Пайтон
Декоратор - это функция, которая принимает как аргумент - другую функцию, обогощает/увеличивает/изменяет ее поведение, результат ее выполнения и возвращает дополненную копию этой функции
Внутри себя декоратор определяет функцию-"обертку" (wrapper)
Она будет обернута вокруг исходной функции, предоставленной в качестве аргумента (декорируемой), позволяя выполнять произвольный код до и/или после нее, как в примере ниже
Она должна иметь параметры, если функция, переданная декоратору, имеет параметры
Внутри функции-обертки - вызывается переданная декоратору функция (декорируемая)
Декоратор возвращает свою внутреннюю функцию-обертку
Для вызова декоратора - он указывается с символом @ над обьявлением функции, которую нужно модернизировать 
def my_decorator(func): # Обьявление декоратора
    print('my_decorator')
    # def wrapper(*args, **kwargs): - пример из курса
    def wrapper(j, k):
        print('wrapper')
        if k == 0:
            return "Cannot divide by zero"
        return func(j, k)
    return wrapper

def divide1(a, b): # Функция без декоратора
    return a / b

print(divide1(10, 0)) # Будет выброшена ошибка

@my_decorator # Вызов декоратора
def divide2(a, b): # Функция, поведение которой нужно модернизировать, для которой вызывается декоратор
    return a / b

print(divide2(10, 0)) # Cannot divide by zero - Будет выведена строка, указанная в декораторе, вместо ошибки

Декорируемую функцию можно переопределить с использованием декоратора
divide1 = my_decorator(divide1) # my_decorator() возвращает wrapper, внутри которого вызывается функция, переданная как аргумент - divide1
Теперь переменная divide1 проинициализированна функцией wrapper внутри которой вызывается ее собственный код и divide1
divide1(10, 0) # Cannot divide by zero - Будет выведена строка вместо ошибки

Декораторы могут быть вложенными
Порядок вложенных декораторов важен, потому что он формирует очередность их вызовов
Сначала вызывается декоратор указанный первым, а затем другие, по очереди
def sugar(f):
    def wrapper():
        return f'{f()} + sugar'
    return wrapper
    
def milk(fn):
    def wrapp():
        return '{} + hot milk'.format(fn())
    return wrapp
    

@sugar
@milk
def coffee(v='arabica'):
    return v
    
print(coffee()) # arabica + hot milk + sugar
Если изменить порядок декораторов, измениться очередность их вызовов и результат
@milk
@sugar
def coffee(v='arabica'):
    return v
    
print(coffee()) # arabica + sugar + hot milk
Пример без синтаксиса декораторов, с вызовом функции-обертки
print(milk(sugar(coffee))()) # hot milk + sugar + arabica
Переопределение функции оберткой из декоратора
coffee = milk(sugar(coffee))
print(coffee()) # hot milk + sugar + arabica

Так же аргументы самого декоратора, а не декорируемой функции, можно передавать в декоратор
Для этого, декоратор нужно обернуть дополнительной функцией
Аргументы декоратора доступны в функции декоратора и функции-обертки
Аргументы передаются декоратору в месте его вызова
def decorator_maker(c, d):
    print('inside decorator maker', c, d)

    def my_decorator(func):
        print('my_decorator')
        print('inside decorator', c, d)

        def wrapper(e, f):
            print('wrapper')
            print('inside wrapper', c, d)
            if f == 0:
                return "Cannot divide by zero"
            return func(e, f)

        return wrapper
    return my_decorator
    

@decorator_maker(11, 12)
def div(a, b):
    return a / b
    
print(div(1, 0))
# inside decorator maker 11 12
# my_decorator
# inside decorator 11 12
# wrapper
# inside wrapper 11 12
# Cannot divide by zero
При помощи аргументов декоратора можно изменять значение аргументов декорированной функции
def decorator_apply(lambda_func):
    def decor(f):
        def wrapper(a):
            new_arg = lambda_func(a) # Изменение аргумента декорируемой функции в лямбда функции, переданной как аргумент декоратора
            return f(new_arg)
        return wrapper
    return decor

@decorator_apply(lambda user_id: user_id + 1)
def return_user_id(num: int) ->int:
    return num

print(return_user_id(42)) # 43

Декоратор можно использовать для сохранения значений между вызовами декорированных функций
Например для сохранения количества вызовов декорированной функции
Для этого нужна переменная в функции декоратора, а доступ к ней осуществляется из функции-обертки, при помощи оператора nonlocal (иначе будет выброшена ошибка)
def call_counter(origin_function):
    count = 0

    def wrapper(func_arg):
        nonlocal count
        count += 1
        print(f'call number is {count}')
        
        return origin_function(func_arg)

    return wrapper

@call_counter
def say_hello(guest_name):
    print(f'Hello, {guest_name}')

Каждый раз, при вызове функци переменная count увеличивается на единицу
print(say_hello('John Doe'))
# call number is 1
# Hello, John Doe
print(say_hello('Marilyn Monroe'))
# call number is 2
# Hello, Marilyn Monroe

Декоратор является синтаксическим сахаром - тоесть конструкцией языка которая ускоряет написание кода
Так как декоратор - это синтаксический сахар, тоесть конструкция языка, которая ускоряет написание кода, то вызвать его можно и следующим образом, такой вызов будет эквиваентным
print(my_decorator(divide1)(10, 0)) # Cannot divide by zero
В результате вызова декоратора - будет возвращена функция-обертка
Затем она будет вызвана с аргументами 10 и 2
Внутри нее - будет вызвана функция divide1 с теми же аргументами и возвращен результат ее выполнения
Если второй аргумент будет 0 - будет возвращена строка Cannot divide by zero


В классах наследниках доступно переопределение методов - изменение поведения методов родительского класса
Для этого в классах наследниках обьявляется метод с таким же названием как и метод в родительском класса, но изменяется его функционал
class Employee:
    def __init__(self, name: str, id: int, age: int = 16):
        self.name = name
        self.id = id
        self.age = age
    def parent_method_for_change_in_child(self):
        return self.age + self.id

class Driver4(Employee):
    def __init__(self, name: str, id: int):
        super().__init__(name, id)

    def parent_method_for_change_in_child(self): # Переопределение метода родительского класса
        return (super().parent_method_for_change_in_child() * 12) # Вызов метода parent_method_for_change_in_child родительского класса с помощью функции super()

driver4 = Driver4('Vins', 14)
print(driver4.parent_method_for_change_in_child()) # 360 # (14 + 16) * 20


class Driver5(Employee):
    def __init__(self, name: str, id: int):
        super().__init__(name, id)

    def parent_method_for_change_in_child(self): # Переопределение метода родительского класса
        return self.id * 19

driver5 = Driver5('Won', 15)
print(driver5.parent_method_for_change_in_child()) # 285 # 15 * 19


Тип переменных можно указывать при их обьявлении
check_list: list[int] = [1, 2, 3]
print(check_list) # [1, 2, 3]


Класс называется абстрактным потому что он содержит не реализованные методы, которые должны быть имплементированны в классах наследниках и это может быть сделано в них совершенно по разному
Тоесть такой класс является не четко определенным, а абстракцией, которая может быть реализована разными способами
Абстрактный класс - это класс, обьект которого не может быть создан и который содержит хотя бы 1 не реализованный метод
Реализация "пустых" методов должна быть выполнена в классах, которые наследуются от него
В теле нереализованных методов можно использовать слово-заглушку pass или троеточие ...
В Пайтон, абстрактный класс реализуется при помощи модуля abc, из которого импортируется класс ABC и декоратор abstractmethod
from abc import ABC, abstractmethod
Абстрактный класс наследуется от класса ABC, а абстрактный метод использует декоратор abstractmethod
class AbstractClass(ABC): # Наследование от класса ABC

    @abstractmethod # Декоратор для не реализованного/абстрактного метода
    def abcmethod(self):
	pass


Так же можно реализовать функционал обязательной реализации "пустых" методов родительского класса в производных классах при помощи вызова NotImplemented - raise NotImplemented('The error message')/NotImplementedError('The error message')
Но в таком случае - можно создавать обьект "абстрактного", родительского класса, что противоречит концепции
class ParentClass:
    def empty_method(self): # "Пустой" метод
	raise NotImplemented('Error message - Need to implement the method - empty_method')

ob1 = ParentClass() # Создание обьекта "абстрактного", родительского класса - не вызовет ошибку
ob1.empty_method() # TypeError: 'NotImplementedType' object is not callable

class ChildClass(ParentClass):
    def empty_method(self): # Реализация пустого метода "абстрактного", родительского класса
        print('Implemented empty method')

ob2 = ChildClass()
ob2.empty_method() # Implemented empty method

Переопределение к родительскому классу реализует сокрытие функционала классов наследников и инкапсуляцию
isinstance


В Пайтон возможно множественное наследование классов от обычных и абстрактных классов, а так же от интерфейсов
У множинному наслідуванні може виникнути ситуація, коли різні батьківські класи мають однакові методи або атрибути
Завдяки MRO, Python намагається зменшити кількість конфліктів, але іноді може бути важко керувати складними залежностями
Алгоритм C3-лінеаризації (MRO)
Python використовує C3-лінеаризацію (Method Resolution Order, MRO), щоб визначити порядок, у якому будуть викликатися методи при множинному наслідуванні
Ти можеш переглянути цей порядок, використовуючи:
print(C.mro()) # [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
class Base:
   def call(self):
     print("Base Class")
     
class Left(Base):
   def call(self):
     print("Left Class")
   
class Right(Base):
   def call(self):
     print("Right Class")
     
class Child(Left, Right):
   pass

obj = Child()
obj.call() # "Left Class" - метод call Left класса
Если производный класс наследуется от нескольких классов, то при вызове метода дочернего класса, этот метод, согласно MRO, Python будет искать в текущем классе
Если он не найден там, Python будет искать его в родительских классах. Родительские классы ищутся слева направо, и каждый класс ищется один раз
Тоесть, поиск метода происходит по цепочке - Child, Left, Right, Base, Object
В Python как встроенные, так и определяемые пользователем классы наследуются от Object класса. И все объекты являются экземплярами Object класса


Композиція — це принцип об’єктно-орієнтованого програмування, який дозволяє будувати складні об'єкти шляхом включення інших об'єктів як атрибутів, замість наслідування від них
Це часто вважається кращим підходом, ніж множинне наслідування, оскільки допомагає уникати складнощів, пов'язаних із MRO та конфліктами методів

Композиція vs. Наслідування
Наслідування: Один клас успадковує поведінку іншого класу. Це створює жорсткий зв'язок між класами.
Композиція: Один клас містить інший клас як атрибут і викликає його методи при потребі. Це дає більшу гнучкість, оскільки об'єкти можна легко комбінувати.
Принцип композиції можна описати як "Має" (has-a) на відміну від "Є" (is-a) для наслідування. Наприклад, машина має двигун — це композиція, а собака є твариною — це наслідування.
Переваги композиції:
Гнучкість: Можна легко замінити один компонент іншим (наприклад, додати інший тип двигуна).
Менша залежність: Клас не має тісного зв’язку з батьківським класом, що спрощує підтримку та модифікацію коду.
Уникає проблем із множинним наслідуванням: Немає конфліктів методів або складного MRO.

Композиція — це принцип об’єктно-орієнтованого програмування, який дозволяє будувати складні об'єкти шляхом включення інших об'єктів як атрибутів, замість наслідування від них. Це часто вважається кращим підходом, ніж множинне наслідування, оскільки допомагає уникати складнощів, пов'язаних із MRO та конфліктами методів.

Композиція vs. Наслідування
Наслідування: Один клас успадковує поведінку іншого класу. Це створює жорсткий зв'язок між класами.
Композиція: Один клас містить інший клас як атрибут і викликає його методи при потребі. Це дає більшу гнучкість, оскільки об'єкти можна легко комбінувати.
Принцип композиції можна описати як "Має" (has-a) на відміну від "Є" (is-a) для наслідування. Наприклад, машина має двигун — це композиція, а собака є твариною — це наслідування.

Переваги композиції:
Гнучкість: Можна легко замінити один компонент іншим (наприклад, додати інший тип двигуна).
Менша залежність: Клас не має тісного зв’язку з батьківським класом, що спрощує підтримку та модифікацію коду.
Уникає проблем із множинним наслідуванням: Немає конфліктів методів або складного MRO.

Композиція чи наслідування? Коли що вибирати?
Наслідування добре підходить, якщо новий клас є специфічною версією батьківського класу (наприклад, Dog – це підтип Animal).
Композиція краще підходить, коли потрібно створити об'єкти з різними властивостями та поведінками, або коли один об'єкт містить інші (наприклад, машина має двигун).
class Engine:
    def start(self):
        return "Engine starts."

    def stop(self):
        return "Engine stops."

class ElectricEngine:
    def start(self):
        return "Electric engine starts silently."

    def stop(self):
        return "Electric engine stops."

class Car:
    def __init__(self, engine):
        self.engine = engine  # Передаємо двигун як параметр

    def start(self):
        return self.engine.start()

    def stop(self):
        return self.engine.stop()

# Використання з різними двигунами
electric_car = Car(ElectricEngine())
print(electric_car.start())  # Виведе: Electric engine starts silently.
gas_car = Car(Engine())
print(gas_car.start())  # Виведе: Engine starts.

Пояснення:
Engine – клас для звичайного (бензинового) двигуна.
ElectricEngine – клас для електричного двигуна.
Car приймає будь-який двигун як параметр у конструкторі. Це приклад композиції: машина містить двигун, але не залежить від його конкретної реалізації.


https://habr.com/ru/articles/667630/
Асинхронность - это возможность выполнять новое действие не ожидая завершения предыдущего
Главная идея асинхронности - выполнять действия не одновременно, а строго последовательно, но координировать эту последовательность действий так, что бы сократить время ожидания
Одновременность выполнения действий достигается благодаря многопоточности, многопроцессорности. Когда каждый отдельный поток выполняет 1 действие
И таким образом, 2 потока могут выполнять 2 действия одновременно, потому что они не зависят друг от друга, а являются отдельными/независимыми
2 фактора влияющие на возможность использования асинхронности:
1.) Существование ожидания
2.) Построение цепочки асинхронных действий. Если начали работать асинхронно, то нужно продолжать работать асинхронно до конца
В Пайтон, основной способ добится асинхронности - с помощью функций
Оператор async - преобразовывает обычную функцию в асинхронную
async def test_async_function():
Для того что бы дождаться завершения выполнения асинхронной функции нужно использовать оператор await
await можно использовать только внутри асинхронных функций
async def fun1(x):
    print(x**2)
    await asyncio.sleep(3)
    print('fun1 завершена')


async def fun2(x):
    print(x**0.5)
    await asyncio.sleep(3)
    print('fun2 завершена')


async def main():
    task1 = asyncio.create_task(fun1(4))
    task2 = asyncio.create_task(fun2(4))

    await task1
    await task2


print(time.strftime('%X'))
asyncio.run(main())
print(time.strftime('%X'))
# 16
# 2.0
# fun1 завершена
# fun2 завершена
Выполнилась быстрая часть функции fun1
fun1 сказала интерпретатору "иди дальше, я посплю 3 секунды"
Выполнилась быстрая часть функции fun2
fun2 сказала интерпретатору "иди дальше, я посплю 3 секунды"
Интерпретатору дальше делать нечего, поэтому он ждет пока ему маякнет первая "проснувшаяся" функция
На доли миллисекунды раньше проснулась fun1 (она ведь и уснула чуть раньше) и отрапортовала нам об успешном завершении
То же самое сделала функция fun2

Как правило, все "медленные" операции, связаны с вводом выводом: получение результата http-запроса, файловые операции, обращение к базе данных.
Однако следует четко понимать: для эффективного использования с asyncio любой медленный интерфейс должен поддерживать асинхронные функции.
Иначе никакого выигрыша в производительности вы не получите. Попробуйте использовать в примере 2.2 time.sleep вместо asyncio.sleep и вы поймете о чем я.
Что касается http-запросов, то здесь есть великолепная библиотека aiohttp, честно реализующая асинхронный доступ к веб-серверу
Для ее использования - ее нужно скачать и установить: pip install aiohttp

print(type(fun1)) # <class 'function'>
print(type(fun1(4))) # <class 'coroutine'>
Корутина — это то, что возвращает функция с await, результат работы асинхронной функции
Асинхронную функцию еще называют корутинной
Корутина дает возможность интерпретатору возобновить работу асинхронной функции, которая была приостановлена, в месте размещения ключевого слова await

print(type(task1)) # <class '_asyncio.Task'>
print(task1.__class__.__bases__) # <class '_asyncio.Future'>
Футура (Future) - это оболочка для некой асинхронной сущности, позволяющая выполнять ее как бы одновременно (асинхронно ?) с другими асинхронными сущностями, переключаясь от одной сущности к другой в точках, обозначенных ключевым словом await
Футура имеет внутреннюю переменную результат - .result(), которая инициализируется через .set_result(value)
Задача (Task) - это частный случай Футуры, предназначенный для оборачивания Корутин
Задача, как подвид Футуры, позволяет выполнять несколько Корутин асинхронно, переключаясь между ними в местах, где указано ключевое слово await
Корутину асинхронной функции fun1 обернули задачей task1
Корутину асинхронной функции fun2 обернули задачей task2
В асинхронной функции main обозначили точку переключения к задаче task1
В асинхронной функции main обозначили точку переключения к задаче task2
Корутину асинхронной функции main передали в функцию asyncio.run
Создается задача при помощи метода create_task() модуля asyncio, а в качестве аргумента принимает Корутину - вызов асинхронной функции
task = asyncio.create_task(fun1(4))

asyncio.run() - единственная рекомендованная точка входа в асинхронное приложение за пределами асинхронности
Передавать в asyncio.run() нужно только асинхронную функцию, которая содержит await-ы на Задачи, а не на Корутины
Если передать асинхронную функцию, которая содержит ожидания на Корутины - код будет выполнятся последовательно, а не асинхронно, так как именно Задачи позволяют переключатся между Корутинами в момент появления ожиданий
async def main():
    task1 = asyncio.create_task(fun1(4)) # Создание первой задачи, оборачивание Корутины в Задачу
    task2 = asyncio.create_task(fun2(4)) # Создание второй задачи

    await task1 # Ожидание завершения выполнения Задачи1, а не Корутинной функции
    await task2 # Ожидание завершения выполнения Задачи2


asyncio.run(main()) # Функция main асинхронная и содержит ожидания на Задачи

Для запуска нескольких задач, можно использовать метод gather модуля asyncio
Его нужно использовать с ключевым словом await
await asyncio.gather(task1, task2)
Если задачи возвращают какой либо результат, то каждый из них будет записан в список который вернет метод gather
Вне зависимости от того, какая задача будет выполнена раньше, их результаты будут записаны в соответствии с порядком задач в методе gather
result = await asyncio.gather(task1, task2)
print(result) # [16, 2.0] # Всегда первый элемент - результат task1, второй - task2

async def check():
    print('start')
    await asyncio.sleep(2)  # Чекає 2 секунди
    print('finish')

async def main():
    task = asyncio.create_task(check())  # Запускаємо check(), вона повертає Корутину, її огортаємо в Задачу та додаємо у Цикл подій
    print('Doing other things...')  # Цей код виконається, поки Задача додається у Цикл подій, це дуже швидко, але все ж таки це очікування

asyncio.run(main())
# Doing other things...
# 'start'
# 'finish' не будет выведено, так как в main нет ожидания задачи с функцией check() и main не дожидается завершения ее выполнения и вывода кода после ожидания - finish

Порядок виконання:
1. Створення завдання
Коли викликається task = asyncio.create_task(check()), функція check() фактично не починає виконуватись одразу
asyncio.create_task() тільки реєструє завдання в циклі подій, але не запускає його до того моменту, поки цикл подій не отримує контроль.
2. Виконання коду який йде далі - print('Doing other things...'):
Час, необхідний для додавання задачі в чергу задач циклу подій, є дуже малим і зазвичай не перевищує мікросекунди, але це все ж таки очікування і код не чекає на його завершення, а йде далі
Після створення завдання check(), наступний рядок у функції main() - print('Doing other things...')
Оскільки check() ще не почала виконуватися (вона лише зареєстрована), цей рядок виводиться у консоль відразу, першим
3. Запуск check():
Після того, як Doing other things... було виведено, іншого коду та коду без очікування немає, тож - цикл подій продовжує виконання і переходить до виконання завдання check()
В результаті, виводиться start

task = asyncio.create_task(check())
Це відбувається майже миттєво, оскільки asyncio.create_task() просто додає завдання в чергу завдань циклу подій, не виконуючи його
Порядок виконання:
1. Запуск корутини
Викликається функція check(), яка є асинхронною (async).
check() створює та повертає Корутину
2. Створення завдання
asyncio.create_task() перетворює цю корутину на асинхронне завдання (task), але не запускає її
Це завдання буде виконуватися в циклі подій (event loop) асинхронно.
3. Додавання до циклу подій
Завдання, створене за допомогою asyncio.create_task(), автоматично додається у Цикл подій (event loop), який виконує асинхронний код
Це означає, що воно готове до виконання, і цикл подій почне його виконувати, коли з'явиться така можливість
Час, необхідний для реєстрації задачі в циклі подій, є дуже малим і зазвичай не перевищує мікросекунди, але все ж таки це очікування
4. Повернення об’єкта Task
asyncio.create_task() повертає об'єкт типу Task, який є специфічним для asyncio об'єктом, що представляє собою асинхронну операцію
Цей об'єкт зберігає інформацію про стан завдання, а також надає методи для взаємодії з ним, такі як cancel() для скасування завдання або result() для отримання результату після його завершення.
5. Цикл подій переходить до виконання інших завдань або коду, поки не буде досягнуто точки, де потрібно виконати асинхронне завдання (наприклад, при досягненні await).

task = asyncio.create_task(check()) - цикл подій запускає виконання Завдання з Корутиною функції check()
Але якщо немає await task - очікування на завершення цього виконання, то воно не буде завершено і результат не буде отримано
async def check1():
    print('start')
    await asyncio.sleep(2)
    print('finish')


async def main():
    task1 = asyncio.create_task(check1()) # Створення задачі, але очікування завершення її роботи немає


asyncio.run(main()) # Буде виведено лише start - початок роботи, бо немає очікування на завершення роботи Корутинної функції

asyncio.run(main()) запускає цикл подій і викликає main().

Так, метод .cancel() використовується в Python для скасування асинхронних завдань (tasks) в бібліотеці asyncio
Коли ти викликаєш .cancel() на корутині (завданні), це надсилає сигнал про скасування, що ініціює процес завершення корутини.
Сигнал про скасування:
Коли ти викликаєш task.cancel(), це не зупиняє виконання корутини миттєво. Натомість, воно лише надсилає сигнал про скасування.
Якщо корутина перебуває в стані очікування на await, вона завершить цей блок коду (наприклад, дочекається завершення await asyncio.sleep()).
Виняток asyncio.CancelledError:
Після завершення поточного await в корутині, піднімається виняток asyncio.CancelledError.
Це дозволяє корутині обробити скасування в блоці except, якщо там є відповідна логіка.
Невиконані частини коду:
Якщо скасування сталося, код після блоку await в корутині не буде виконуватись
Це означає, що, якщо корутина знаходиться у циклі, як у прикладі з print_hi(), то нові ітерації не відбудуться.


При выполнении, асинхронная функция генерирует специальный обьек - task, задачу, ожидает завершения его выполнения и возвращает результат
Во время ожидания выполнения этого task, можно выполнять другие действия в основной программе, она не останавливает свое выполнение на время ожидания
Корутина (coroutine) - это тип данных, это асинхронная функция которая была запущена
Или это результат который возвращает асинхронная функция ?
Запуск асинхронной функции сразу не возвращает никакого результата, так как task, который она генерирует еще выполняется и не готов, нужно дождатся пока он завершит свое выполнение и вернет результат
Для того что бы дождаться завершения выполнения task/работы асинхронной функции нужно использовать оператор await
await можно использовать только внутри асинхронных функций
async def check():
    print('check')
    return 1

print(type(check())) # <class 'coroutine'> - результат, который возвращает корутина, когда она не дождалась выполнения своего task
res = check() # sys:1: RuntimeWarning: coroutine 'check' was never awaited - результат корутины check никогда не ожидался
print(res) # <coroutine object check at 0x0000018E95159900>
print(type(res)) # <class 'coroutine'>
Так как корутина check не завершила свое выполнение, в переменной res находится корутина, а не результат выполнения check - 1
async def check():
    print('The check function started')
    return 1


async def temp_fn():
    print('Starting a temp_fn')
    res = await check() # Ожидается пока функция check завершит свое выполнение
    print('The result of the check function is ready')
    print(res)


asyncio.run(temp_fn())
# Temp_fn 1 - Функция temp_fn начинает свою работу
# Check - Вызывается функция check
# Temp_fn 2 - Функция check завершила свое выполнение и после этого дальше продолжает выполнятся функция temp_fn
# 1 - Выводится результат выполнения функции check

Для вызова асинхронных функций, за пределами асинхронных функций, используется метод run модуля asyncio
asyncio - это модуль отвечающий за работу с циклом событий, который умеет правильно координировать работу асинхронных функций
import asyncio # Импорт этого модуля
asyncio.run(temp_fn()) # Вызов асинхронной функции temp_fn за пределами асинхронных функций/внутри синхронной функции (main ?)
Так же, в переменную можно записывать результат выполнения асинхронной функции, переданной методу run
res = asyncio.run(temp_fn())
print(res) # Результат который возвращает асинхронная функция temp_fn, после завершения ожидания в ней/выполнения ее задачи/task

Метод gather модуля asyncio позволяет асинхронно выполнять несколько разных асинхронных функций/корутин/tasks
Нужные функции передаются в метод gather в качестве аргументов
В этом методе происходит координация работы разных корутин, в моменты возникновения ожиданий
Когда в первой корутине возникает ожидание - управление передается второй и она начинает свою работу
Когда во второй корутине возникает ожидание и ожидание в первой еще не закончилось - управление передается третьей
Когда в третей корутине возникает ожидание - управление передается первой или второй, в зависимости от того, чье ожидание уже завершилось
Если заврешилось ожидание обоих - управление передается первой
Если ожидание первой еще идет, а второй завершилось - управление передается второй
А далее первой или третьей, в зависимости от состоянии их ожиданий
Этот метод так же является асинхронным, поэтому для ожидания завершения выполнения всех корутин, которые были ему переданы, нужно использовать оператор await
Метод sleep в модуле asyncio используется для иммитации ожидания - функция в которой он вызывается останавливает свою работу на определенное время, переданное ему в секундах как аргумент
async def fn1():
    print(1)
    await asyncio.sleep(1)
    print(2)
    return 1

async def fn2():
    print(3)
    await asyncio.sleep(2)
    print(4)
    return 2

async def fn3():
    print(5)
    await asyncio.sleep(3)
    print(6)
    return 3

async def temp_fn(): # Функция для асинхронного вызова несколькох асинхронных функций/корутин
    task1 = fn1()
    task2 = fn2()
    task3 = fn3()

    res = await asyncio.gather(task1, task2, task3)
    print('res = ', res)


asyncio.run(temp_fn())
# 1 - Начинает выполнятся функция fn1
Внутри нее возникает ожидание asyncio.sleep(1) и поэтому управление передается следующей корутине в методе gather
# 3 - Начинает работу функция fn2
Внутри нее так же возникает ожидание и управление передается дальше
# 5 - Выполняется функция fn3
В ней возникает ожидание
Так как ожидание в функции fn1 в этот момент завершилось, управление передается этой функции и она продолжает свою работу
# 2 - код идущий после ожидания в функции fn1
Результат функции fn1 записывается как первый элемент в список res, потому что эта функция передана первой в метод gather
Далее ожидание заканчивается у функции fn2 и она продолжает выполнятся
# 4
Ее результат записывается в переменную res, как второй элемент
И завершается ожидание в функции fn3
# 6
Результат ее выполнения записывается в список res
Метод gather завершает свое выполнение, оператор await ожидал пока он полностью исполнится
И выполняется код следующий после него - вывод переменной res в консоль
# res =  [1, 2, 3]

async def get_one_response(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            print('start')
            if url == 'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?valcode=eur&date=20241209&json':
                print('if')
                await asyncio.sleep(5)
            data = await response.json()
            print('data', data[0]['cc'], data[0]['rate'])
            return {data[0]['cc']: data[0]['rate']}

async def async_main2(urls):
    tasks = []
    for l in urls:
        task = asyncio.create_task(get_one_response(l))
        tasks.append(task)

    # Чекаємо на завершення всіх задач і виводимо результат
    for t in asyncio.as_completed(tasks):
        result = await t
        print(result)

links = [
    'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?valcode=USD&date=20241209&json',
    'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?valcode=eur&date=20241209&json',
    'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?valcode=gbp&date=20241209&json'
]

asyncio.run(async_main2(links))
Швидко буде виведено - {'USD': 41.4446}
Потім розпочнеться виконання функції get_one_response для 2-го посилання, але запит для другого посилання (eur) чекає 5 секунд, але під час цього затримка не блокує інші запити, і вони продовжують працювати
Тому задача переключиться на наступну - для 3-го посилання
Третє посилання виконується швидше, ніж друге, але це не означає, що результат буде виведений раніше, оскільки await t в циклі for t in tasks чекає завершення кожної задачі по черзі
Задачі будуть виводитися в тому порядку, в якому ви їх чекатимете, а не в тому, як швидко вони завершуються
Тобто швидко буде повернуто значення 1-го посилання, а через 5 секунд 2-го та 3-го, незважаючи на те, що запит на 3-тє посилання був оброблений і повернув значення раніше за 2-ий
Коли ви використовуєте await t в циклі, ви чекаєте на завершення кожної окремої задачі по черзі
Тобто, навіть якщо якась із наступних задач завершилася раніше, ви все одно чекаєте завершення кожної попередньої задачі в черзі
Щоб вивести результати в порядку завершення кожного запиту, незалежно від порядку їх створення, можна використати asyncio.as_completed, який дозволяє обробляти задачі у порядку їх завершення, а не у порядку того, як ви їх створюєте
В результаті, навіть якщо одна задача завершується швидше, її результат буде виведений відразу після її завершення, і програма не буде чекати завершення інших задач
Тепер, якщо третє посилання (gbp) завершиться швидше за друге (eur), результат для третього посилання буде виведений раніше, ніж результат для другого
    for t in asyncio.as_completed(tasks):
        print(await t)
Цикл for t in tasks замінено на for t in asyncio.as_completed(tasks) - це дозволяє виводити результати задач у міру їх завершення, а не за порядком їх створення
Тепер третє посилання, яке обробляється швидше, буде виведене раніше за друге (яке має затримку)
Але в реальних прикладах це важко використовувати, бо потрібні результати всіх трьох запитів, а як відокремити швидкі від повільних, що б спочатку використовувати результати швидких, а потім повільних ?


Если в проекте уже есть блокирующие операции (ввода-вывода) и их нужно адаптировать, использовать в асинхронном коде asyncio - придется использовать механизм многопоточности
В python есть модуль threading для работы с потоками
Это еще одна модель конкурентности, позволяющая распараллелить операции ввода вывода
в python встроен механизм, который позволяет "распихивать" задачи asyncio, содержащие блокирующие функции ввода вывода, по разным потокам и работать с ними при помощи стандартного asyncio.gather, не особенно заморачиваясь, как оно там все внутри устроено
Механизм этот называется пул потоков
from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor() as pool:
Задачи, созданные при помощи пула потоков ведут себя точно так же, как и обычные задачи asyncio, несмотря на то, что не содержат асинхронных функций
Но важно понимать, что многопоточность в python позволяют обойти GIL только для операций ввода-вывода
Если вы применяете операции, загружающие процессор ("программы-числодробилки"), то никакого выигрыша от применения пула потоков в асинхронных приложениях (как, впрочем, и в традиционных), вы не получите
Что же делать в тех редких случаях, когда нам кровь из носу нужно использовать "числодробилку" в асинхронном приложении? На помощь приходит пул процессов!
Он реализован в модуле multiprocessing и является, пожалуй самым затратным с точки зрения вычислительных ресурсов
Суть мультипроцессности в том, что каждый конкурентный участок кода выполняется на отдельном ядре процессора
Пока свободных ядер хватает, достигается эффект истинной параллельности. Как таковой GIL никуда не девается, только у каждого процесса интерпретатор свой собственный, независимый от других
А что если ядер процессора перестает хватать? Ну, тогда "лишним" процессам приходится немного подождать


В Пайтон 3 механизма реализации конкурентности:
1. асинхронность - async, await
2. мультипоточность (пул потоков) - from concurrent.futures import ThreadPoolExecutor
Когда для каждой задачи создается свой отдельный поток
3. мультипроцессность (пул процессов) - from concurrent.futures import ThreadPoolExecutor
Когда каждая задача выполняется на отдельном ядре процессора (в отдельном интерпретаторе)


При работе с асинхронностью, все действия должны быть асинхронными
В том числе менеджер контекста with - async with и даже преобразование из json - await json(), так как это занимает время и появляется ожидание
Если упустить этот момент, программа перестанет выполнятся асинхронно


Менеджер контекста - обеспечивает удобный и безопасный способ работы с ресурсами, такими как базы данных, файлы и потоки, упрощая управление и гарантируя корректное освобождение ресурсов после использования
Он используется когда есть 2 парные операции, например открыть и закрыть файл, и тут можно забыть закрыть файл когда работа с ним будет закончена
Менеджер контекста гарантирует, что, после завершения работы с файлом (любым другим ресурсом) - он будет закрыт
К таким операциям так же относится установка соединения с БД и завершение его
file = open("file.txt", "r")
try:
    # Действия с файлом
    content = file.read()
    print(content)
finally:
    file.close() # Обязательная операция иначе файл так и останется открытым

with open("file.txt", "r") as file: # Оператор with гарантирует закрытие файла, после завершения работы с ним
    content = file.read()
    print(content)


aiohttp - библиотека Пайтон реализующая асинхронный доступ к веб-серверу
requests - библиотека для доступа к веб-серверу не поддерживающая асинхронность, из-за чего работа с ней происходит последовательно
Для того, что бы осуществлять запросы к веб-серверу с помощью aiohttp, необходимо создать сессию при помощи ее встроенного метода ClientSession()
import aiohttp
async with aiohttp.ClientSession() as session
from aiohttp import ClientSession
async with ClientSession() as session
А уже эта сессия имеет доступ к различным типам запросов get, post, put, patch, update, delete
async with session.get(url)
async with session.get(url='http://api.openweathermap.org/data/2.5/weather', params={'q': city, 'APPID': '2a4ff86f9aaa70041ec8e82db64abf56'})
async with session.post(url='https://libretranslate.de/translate', json={'q': text, 'source': source, 'target': target, 'format': 'text'})
В POST запросе, как известно, данные передаются в теле запроса и в виде определенной структуры: json, xml...
Цикл событий (event loop) - это ядро asyncio, своего рода шина данных, которая организует переключение между задачами, когда возникает ожидание, следит за событиями, обрабатывает исключения и тд
Цикл событий создается неявно каждый раз при вызове asyncio.run()
Разработчику не нужно беспокоиться о его создании вручную, как это делалось в старых версиях python.
Цикл событий работает до тех пор, пока в нем есть хотя бы одна незавершенная задача. Если все задачи завершились - цикл так же завершит свою работу
На практиче часто приходится организовывать бесконечный цикл в одной из задач цикла событий, чтобы не дать завершиться хотя бы одной задаче, а вместе с ней и циклу событий asyncio
Это может быть веб-сервер или CLI или что-то в этом духе.
Простой пример асинхронного веб-сервера
import asyncio

async def get_message():
    await asyncio.sleep(2)  # имитация ожидания сообщения от клиента
# Неблокирующее ожидание, но код на следующей строке не начнет выполняться, так как в точках await цикл может переключатся только между задачами
# Тоесть после await asyncio.sleep(2) может начать выполнение задача, следующая в очереди в цикле событий, но не код на следующей строке
    print('Привет сервер!')

async def listen_port():
    while True:
        await asyncio.sleep(5)  # имитация ожидания запроса на соединение от клиента
        print('Получен запрос на соединение, ждем сообщения')
        asyncio.create_task(get_message()) # Нет ключевого слова await
# Это значит что цикл событий начнет выполение этой задачи, но не будет ожидать ее завершения
# В таком случае после нее сразу начнет выполнение следующая задача - await asyncio.sleep(5), а эта будет завершена по истечении 2 секунд - await asyncio.sleep(2)
# Так как бесконечный цикл while True не дает завершится циклу событий, эта задача точно завершится
# Но если бы бесконечного цикла небыло, цикл событий мог бы завершится раньше, чем эта задача и ее результат не был бы получен
# Цикл событий ожидает завершения выполнения только задач с ключевым словом await

async def main():
    await asyncio.create_task(listen_port())

asyncio.run(main())
Поскольку сервер должен быть всегда в ожидании клиентов, нам пришлось вручную организовать бесконечный цикл, чтобы не дать завершиться задаче listen_port, а вместе с ней и циклу событий asyncio
Подобным образом организована работа настоящих веб-серверов.
Главный поток нашей программы передает управление циклу событий asyncio в момент вызова asyncio.run
Далее запускается задача listen_port
В точке await asyncio.sleep(5) цикл событий отдает управление таймеру операционной системы, а сам продолжает крутиться, ведь других задач у него пока нет
По истечении 5 секунд операционная система вывешивает флаг о событии "5 секунд истекли" и цикл событий при очередном проходе возобновляет выполнение задачи listen_port с оператора print('Получен запрос на соединение, ждем сообщения')
Далее создается новая задача get_message, в которой цикл событий снова передает управление операционной системе в точке await asyncio.sleep(2)
Обратите внимание, в этот момент в цикле событий имеются две незавершенные задачи: listen_port, крутящаяся в бесконечном цикле, и get_message, ожидающая события операционной системы
По истечении 2 секунд операционная система вывешивает флаг о событии "2 секунды истекли" и цикл событий при очередном проходе возобновляет выполнение задачи get_message с оператора print('Привет сервер!')
После этого задача get_message завершается и в цикле событий остается только задача listen_port. И т. д.


Аннотация - это указание типа данных, который используется для обьявленных переменных, параметров и результата возвращаемого функцией
Аннотация не является обязательной, а так же, если вместо указанного в аннотации типа данных передается другой - ошибки не будет, редактор кода только покажет предупреждение
После имени переменной, параметра ставится двоеточие и указывается нужный тип данных
a: int = 3
Для результата функции - между закрывающей скобкой и двоеточием ставится стрелка и нужный тип данных
Если функция ничего не возвращает - указывает тип None
def test(a: int, b: int) -> int:
    return a + b
Проверить аннотации функции можно вызвав ее магический аттрибут __annotations__
print(test.__annotations__) # {'arr': list[str], 'return': None}

Для аннотации элементов последовательностей нужно использовать эти типы данных (последовательности) из модуля typing
Такие типы данных указываются с большой буквы
Аннтация элементов последовательностей обязательно указывается в квадратных скобках - List[int], Dict['str', int] (ключи в словаре всегда типа str, а их значения типа int)
from typing import List
def test2(arr: List[str]):
    for s in arr:
	print(s.upper())

test2(['Hi', 'Hola', 'Hello']) # HI, HOLA, HELLO

В модуле typing есть 3 полезные фичи: Optional, Any, Union
Optional - используется когда переменная может иметь значение определенного типа или None
Тип значения указывается в квадратных скобках после ключевого слова Optional
a: Optional[int] = None - переменная а может иметь значение типа int, но на данной строке оно None
Optional часто используется для результата функции, когда она может возвращать, а может и не возвращать значение, тоесть вернет None (функция которая ничего не возвращает, по умолчанию возвращает None)
def show(a: int) -> Optional[int]: # Результат функции может быть типа int или None
    if a > 0:
	return a ** 2

print(show(2)) # 4
print(show(0)) # None
Так же используется для параметров функции, длязначения по умолчанию
# def show3(a: int, b: int = None) -> int: - переменная b может принимать значения типа int и None, поэтому здесь можно использовать Optional
def show2(a: int, b: Optional[int] = None) -> int:
    if b:
        return b

    return a

print(show2(21)) # 22
print(show2(21, 22)) # None

Any - используется, когда переменная может иметь значение любого типа данных
b: Any = 'Wow'
Union - используется, когда переменная может иметь значение нескольких типов данных
c: Union[int, float, None] = 2
В Пайтон версии выше 3.10, вместо Union можно использовать короткую запись - символ вертикальной черты
d: int | float | True = 4
Так же, с помощью Union можно расширять допустимые типы в Optional
e: Optional[Union[int, float]] = None # Expected types: int | float | None

Если аннотация очень длинная, сложная, содержит несколько вложенностей, можно использовать type alias
type alias - это описание нужного типа путем присвоения его переменной
def check(a: list[dict[tuple[int, str], str]], b: list[dict[tuple[int, str], str]]) -> list[dict[tuple[int, str], str]]:
    temp = deepcopy(a)
    temp.extend(b)
    return temp

Key = tuple[int, str] # Type alias
Elem = dict[Key, str]
myType = list[Elem]
def check(a: myType, b: myType) -> myType:
    temp = deepcopy(a)
    temp.extend(b)
    return temp

Так же, в аннотации, можно использовать пользовательские классы
car1 = Car('BMW', 'X5', 2025)

Типы данных можно создавать при помощи ключевого слова type (?)
type t = list[int]
test1: t = [1, 2, 3]
print(test1) # [1, 2, 3]

mypy - статический анализ кода, модуль, который проверяет соответсвуют ли переданные типы данных ожидаемым, без запуска/выполнения кода
pip install mypy - загрузка и установка модуля mypy
mypy main.py - проверка файла main.py анализатором mypy

Генератор - обьект класса generator используется в выражениях и функциях генераторах
Выражение генератор - возвращает новый генератор
Обьявляется как list comprehensions, но в отличии от него - скобки должны быть круглыми
a = (x**2 for x in range(5))
print(a) # <generator object <genexpr> at 0x7fde74649ff0>
Генератор - это итератор, элементы которого можно итерировать/обойти только 1 раз
Итератор - это обьект который поддерживает функцию next
Она всегда возвращает следующий элемент в итераторе, коллекции и запоминает какой элемент будет следующим в случае нового вызова фукции next
Итерируемый обьект - это обьект, который предоставляет возможность обойти поочередно все свои элементы
Итерируемый обьект может быть преобразован к итератору при помощи метода iter
Таким обьектом является list, tuple, str
l = [1, 2, 3]
next(l) # list не поддерживает функцию next, так как он не является итератором
iter_l = iter(l) # преобразование итерируемого обьекта в итератор
next(iter_l) # 1 - iter_l является итератором и поддерживает функцию next
Первый вызов функции next вернет 1-ый элемент в итераторе
next(iter_l) # 2 - Каждый новый вызов функции next будет возвращать следующий элемент итератора
next(iter_l) # 3
next(iter_l) # StopIteration - когда все элементы итератора уже были вызваны, после вызова функции next - будет выброшена ошибка
Генератор является итератором и поэтому поддерживает функцию next
a = (x**2 for x in range(5))
next(a) # 1
next(a) # 4
Генератор можно итерировать только 1 раз. Это можно сделать в цикле или вызвав функцию next столько раз, сколько элементов в генераторе
При использовании цикла for он сам будет вызывать функцию next переданного генератора
for v in a: # Под капотом цикл for вызывает функцию next генератора а
    print(v) # 1, 4, 9, 16, 25
Если итерировать тот же генератор второй раз - ничего не будет выведено (потому что функция next сохраняет положение на последнем элементе итератора, а после него ничего нет)
for v in a:
    print(v) # Ничего не будет выведено v = 25, next(25) - нет
Итерация так же происходит при использовании метода sum и преобразования обьекта генератора в список - list, так как они перебирают каждый элемент генератора и возвращают их сумму или записывают их в новый список
a = (x**2 for x in range(5))
print(list(a)) # [1, 4, 9, 16, 25]
print(list(a)) # []
Это происходит потому что элементы генератора не хранятся в памяти все вместе, а формируются "на лету"
При каждом обращение к функции next возвращается следующий элемент
Это полезно когда нужно работать с очень большим количеством данных или вычислений и поэтому в этих случаях лучше использовать генератор
c = list(range(100000000)) # MemoryError - Пайтон не хватает памяти, что б сохранить такое количество элементов в списке
Тоже самое будет если формировать список при помощи list comprehensions c = [x for x in range(100000000)]
Но, при использовании генератора этой ошибки не будет, так как он не хранит все элементы в памяти, а генерирует каждое отдельное значение при переходе к следующему элементу
c = (x for x in range(100000000))
for val in c:
    print(val) # Будут выводится значение элементов генератора и ошибки не будет
Потому что переменная, генератор с не хранит в себе все 100000000 элементов, а получает по 1 элементу (каждый раз - следующий)
К генератору нельзя применить функцию len, так как он не хранит все элементы и не знает их количество
И, по этой же причине, к элементам генератора нельзя обращатся по индексу c[3]

Функция генератор обьявляется как и обычная функция, однако вместо ключевого слова return используется ключевое слово yield
def gen_f():
    for i in range(5):
	yield i

res = gen_f() # Функция генератор вернет генератор в переменную res
print(next(res)) # 0 - генератор поддерживает метод next, а первым его элементом является 0
print(list(gen_f()) # [0, 1, 2, 3, 4]
Эта функция возвращает значения по одному, всегда помнит какое значение она вернула при помощи инструкции yield и какое значение нужно вернуть следующим
При достижении ключевого слова yield функция замораживается, сохраняет значения всех своих локальных переменных и ожидает до момента следующего вызова функции next
def gen_f():
    for i in range(5):
	yield i
	print('Hi')

res = gen_f()
print(next(res)) # 0 - функция вернула значение, приостановилась на строке с ключевым слово yield и ожидает следующего вызова метода next
print(next(res)) # Hi, 1 - функция продолжила свою работу со строки следующей после строки со словом yield
print(next(res)) # Hi, 2
Преимуществом такой функции, как и выражения генератора, является то, что если нужно вернуть очень большое количество данных, которое требует большого количетсва памяти для хранения, это можно делать по 1 элементу и экономить память
Так же, функция генератор позволяет избежать создания локальной переменной, последовательности для записи в нее значений/результатов, которая будет возвращена ею
def check():
    for i in range(5):
	yield i  

a = check() # Функция возвращает генератор
print(next(a)) # Генератор содержит только один элемент 0 ? Так как функция генератор возвращает значения по одному
print(list(check())) # Генератор содержит все элементы
Результат функции генератора можно обойти при помощи цикла for
for r in gen_f():
# for r in res: - если результат функции был присвоен переменной
    print(r) # 0, 1, 2, 3, 4, 5

Функции list, set, sum, max, min и другие могут напрямую работать с итераторами и генераторами
a = (x for x in range(5)) # Создан генератор
print(sum(a)) # 10 - В функцию sum передан генератор а
max(x ** 2 for x in range(5)) # 16 - Генератор обьявлен прямо в функции max

Классификации языков программирования:
1. По уровню абстрации:
low-level - отправляют прямые вызовы ОС и представлены в формах 0 или 1. Они имеют мало или вообще не имеют абстракции. Низкоуровневые программы работают быстро и потребляют очень мало памяти (Машинный код, aссемблер)
high-level - отправляют косвенные вызовы ОС, используя уровень абстракции. Такие программы не зависят от оборудования и требуют компилятора или интерпретатора для их трансляции в ОС (JS, Python, Java ...)
2. Парадигма программирования:
Деларативная - описывает результат, неучитывая как его достить (HTML, SQL)
Императивная - описывает процесс достижения результата (JS, Java, Python)
3. Типы программирования:
функциональное - является примером декларативного программирования, в котором программы выполняются как цепочка вызовов функций. Такая цепочка образует рекурсию: функции принимают входные данные и возвращают выходные данные, которые могут использоваться в качестве входных данных последовательными функциями
ООП -  это форма императивного программирования, программа взаимодействует с набором объектов , созданных из классов . Классы имеют атрибуты (данные, хранящиеся в классах) и методы (код для управления данными)
процедурное - это еще одна форма императивного программирования. Она требует группировки последовательностей инструкций в процедуры. Процедура может хранить данные, доступ к которым осуществляется только изнутри процедуры. Вы можете вызвать любую процедуру в любой части кода.
4. Выполнение:
компилируемые -  это процесс перевода исходного кода с языка программирования высокого уровня на язык более низкого уровня (например, ассемблерный код, объектный код или машинный код) для создания исполняемой программы
Скомпилированный код зависит от платформы компиляции (C, Go, Pascal)
интерпритируемые - преобразует исходный код в байт-код (промежуточный язык представления), который затем выполняется интерпретатором шаг за шагом. Интерпретируемые языки являются кроссплатформенными, но выполняются дольше, чем компилируемые языки
Исходный код программы сначала компилируется в промежуточный формат, называемый байт-кодом. Затем эта низкоуровневая инструкция выполняется на виртуальной машине Python (PVM)
PVM — это программное обеспечение для преобразования байт-кода построчно в машинный код, чтобы компьютер мог выполнить инструкции и отобразить конечный вывод
5. Типизация
5.1 динамическая - код проверяется во время выполнения, и нет необходимости указывать тип данных каждой переменной
В динамических языках переменные могут хранить любой тип данных, и вы можете изменить его в любое время во время выполнения программы (Python, Javascript)
Это ускоряет разработку, поскольку вы можете повторно использовать существующие переменные для хранения новых значений
5.2 статическая - проверки типизации выполняются без запуска программы, поэтому все детали переменных и типов данных должны быть известны до компиляции
Это означает, что вы можете справиться с большинством ошибок в коде во время компиляции
Переменным задается тип данных во время их обьявления и он не может изменяться (C, Java) 
5.3 сильная - допускают смешивание типов в выражениях и не применяют различные неявные приведения типов (Python)
5.4 слабая - применяют неявные приведения типов. В результате вывод некоторых выражений может оказаться неожиданным (Javascript)

In Python, a variable is a name attached to a particular object in memory
A variable or better to say - a linked object
a = 1
b = 'GTM+3'
Names
		  	a       b
Objects in memory	|	|
			1    'GTM+3'

A random module
choice(sequence) - returns a random element of a non-empty sequence.
randrange(start, stop, step) - returns a randomly selected number from a sequence.
random() – returns a random number from 0 to 1.
seed([a], version=2) – the initialization of the random number generator. If a is not specified, the system time is used.
shuffle(sequence, [rand]) - shuffles the sequence (changes the sequence itself). Therefore, the function does not work for immutable objects.
uniform(x, y) – returns a random floating-point number from x to y


table_cursor.execute('SELECT id, name FROM items')  # Виконати запит
Виконується сам SQL-запит до бази даних. Це повідомляє базі даних, щоб вона повернула стовпці id та name з таблиці items
result = table_cursor.fetchall() # Отримати всі результати запиту як список кортежів
Після виконання запиту метод fetchall() отримує всі рядки результату, які повернула база даних, і зберігає їх у вигляді списку кортежів
Кожен кортеж містить значення для кожного стовпця, який був вибраний у запиті (у нашому випадку id і name).
execute() - лише виконує SQL-запит, але не повертає результат. Він лише надсилає запит до бази даних
fetchall() - отримує всі результати, які повернуто запитом, і повертає їх у вигляді списку
Між execute та fetchall можуть бути інші рядки коду, але головке - щоб вони не змінювали стан курсору
Курсор — це об'єкт, який використовують для роботи з результатами SQL-запитів (як правило, це таблиці або набори рядків, що повертаються базою даних): отримувати, переміщуватися по даним і виконувати інші операції з базою даних