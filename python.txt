Перевірити чи встановленний Пайтон на ПК:
Open the command line or PowerShell and type in: python --version
Якщо Пайтон встановленний на ПК - буде показана його версія, якщо ні - нічего

Перейти в інтерпритатор Пайтон в Командній строці або PowerShell:
Open the command line or PowerShell and type in: python
cls - to clear the cmd or PowerShell (not the Python interpreter)

PyCharm - інтегрована середа розробки (IDE) для Пайтон

В Пайтон все сущности - обьекты (даже число и строка - экземпляры классов)
Обьект - это экземпляр определенного класса
Класс - это шаблон, каркас для создания обьектов
Аттрибут обьекта, значение которого функция - метод

Типы данных в Пайтон:
int - целые числа (3, 0, -1)
str - строки ('Hi')
bool - логические значения (только true и false)
list (список) - набор данных (могут быть разных типов) через запятую в квардратных скобках ([1, 2, 3, 'Hi', true])
dict (словарь) - набор элементов, которые состоях из пары: ключ, значение, в фигурных скобках ({'min': 1, 'max': 3})

name = 'Bogdan'
name - переменная значение которой строка (str)
name - обьект типа строка, обьект класса строка (str)

Что бы вызвать функцию к ее названию нужно добавить пару круглых скобок - myFn()
Методы обьектов вызываются с помощью точечной записи - name.upper()
Метод dir возвращает имена/названия/ключи всех аттрибутов обьекта

Встроенные (built-in) методы Пайтон:
print, input, dir, ...

Для выполнения кода Пайтон в терминале с использованием интерпретатора Пайтон - python3 main.py
Вместо 3 можно ввести любую другую нужную версию Пайтон
В JS - node main.js

Для разделения блоков кода во многих ЯП используются фигурные скобки {}
В Пайтон для этого используют отступы (4 пробела)
Работает и с 1-3 пробелами, но это не соответствует PEP8 (общепринятым правилам в Пайтон)
def show(text):
    print(text)


show('Hello from PyCharm')

Некоторые выдержки из PEP8:
Функции и классы должны быть отделены от других строк кода 2 пустыми строками
Файл с кодом должен заканчиваться 1 пустой строкой
Импорт каждого модуля должен быть на отдельной строке
Для отступов использовать 4 пробела, а не Tab
Длина строк должна быть менее 79 символов

Formatting Python code in the VS Code
Отфарматировать код под условия PEP8:
Ctrl+Shift+P
Fill in the appeared input field with "Format" word
Select "Format Document With..."
Select "Python"
Instal the Formatter "autopep8" if it's not installed yet

Set necessary formatter by default:
Ctrl+Shift+P
Select "Format Document With..."
Click on the "Configure Default Formatter..."
Choose "Python"

Automatically formatting of the file after saving the file:
Ctrl+,
Fill in the appeared input field with "Format on save" text
Activate a checkbox in the "Editor: Format On Save" block
The Formatter "autopep8" should be installed before

Комментарии игнорируются интерпретатором Пайтон
Комментарии добавляются при помощи знака решетки #
Многострочные комментарии можно сделать с использованием тройных одиранрых или двойных кавычек

Функции в Пайтон определяются при помощи ключевого слова def
После def идет название функции и круглые скобоки, а затем ставиться двоеточие, после которого идет блок кода функции
Тело функции, как и другие отдельные блоки кода, отделено от остального кода 4 пробелами слева
Параметр функции (name) - это переменная, которая указывается в круглых скобках, после названия функции, при ее обьявлении
Аргумент функции ('Bogdan') - это значение, которым инициализируется параметр функции
Параметру присваивается значение агрумента в момент вызова функции
def hello(name):
    print('Hi', name)
    print("How are you ?")


hello('Bogdan')


return - ключевое слово, инструкция, которая используется в функциях для возвращения значения из них
По умолчанию, в Пайтон, любая функция без ключевого слова return, возвращает None
print(print('Bogdan'))
# Bogdan - результат вызова print('Bogdan')
# None - результат вызова функции print аргументом которой является значение, которое вернула print('Bogdan'), а она ничего не возвращает (нет return)
Как только функция доходит до слова return - она возвращает значение (если оно указано) и далее не выполняется, прекращает свою работу
Код, который находится после ключевого слова return, не будет выполнен

Выражение (expression) всегда возвращает значение
Функция - возвращает результат работы функции либо None,
5+4 - возвращает 9,
'Hello ' + 'World!' - возвращает новую строку "Hello World",
a>b - возвращает True или False
Все это выражения, так как они возвращают какое-то значение
Проверить, является ли часть кода выражением можно используя функцию print
Если блок кода является выражением - его результат будет выведен в консоль, а если нет - произойдет ошибка
print('Hello ' + 'World') > 'Hello World'
print(if True: print('Hi')) > error: expected expression

Инструкция (statements) выполняет действия
Создание/обьявление функции
my_name = 'Bogdan' - создание переменной
if True:
    print ('Hi') - логическая инструкция
import datetime
return result
print(import datetime) > error: expected expression
В JS создание переменной - выражение, которое возвращает undefined

Переменные дают возможность повторного доступа к значениям
snake_case используется для переменных, функций, методов и модулей
UPPER_SNAKE_CASE - для констант
PascalCase - для классов
dash-case - для пакетов
Пакеты - это наборы модулей

В Пайтон, обьявление переменной и присвоение ей значения происходит на 1 строке
name = 'Bogdan'
Эти действия нельзя разделять, это ошибка
name
name = 'Bogdan'
> error: name 'name' is not defined
Если переменная с таким же именем уже была создана ранее, то ее значение просто перезапишется/изменится
name = 'Kirilo'
name = 'Bogdan'
Пайтон - язык с динамической типизацией
Это значит, что одной и то й же переменной могут быть присвоенны значения разных типов (и даже функция)
val = 3
val = 'value'
val = True

В Пайтон отсутствуют примитивные типы данных (как например в JS - number ?)
Все сущности - обьекты
При создании переменной со значением целого числа, в памяти создается обьект класса int, значение которого указанное целое число
В Пайтон типы данных/обьекты делятся на изменяемые (mutable) и неизменяеммые (immutable)
Неизменяемый обьект нельзя изменить, можно только создать новый, с таким же названием и другим значением
Изменяемый тип можно изменять/мутировать (добавлять/удалять элементы, менять значение элементов), так как он сохраняется в памяти
К неизменяемым типам данных относятся: str, int, bool, float, None (имеет единственное значение None), tuple (кортеж), range
Изменяемые: list, dict, set, objects of user-defined classes (экземпляры классов созданных пользователем)

При создании переменной в памяти создается обьект
Переменная содержит/является ссылкой на этот обьект в памяти
Если переменной присвоить другое значение, то будет создан новый обьект, а старый, через некоторое время, будет удален Пайтон
Если переменной присвоить другую, ранее созданную переменную, то новый обьект не будет создаваться. Новая переменная будет проинициализированна ссылкой ранее созданной переменной
date = 09012024 - создается новый обьект в памяти. Переменная date не содержит значение 09012024, она содержит ссылку на обьект в памяти со значением 09012024
my_name = 'Bogdan' - создается обьект в памяти
my_name = 'Kirilo' - создается новый обьект в памяти, а предыдущий будет удален
my_name = 'Bogdan' - создается обьект в памяти
new_name = my_name - переменная new_name проинициализированна ссылкой в переменной my_name, новый обьект не создается
new_name и my_name содержат одну и ту же ссылку на один обьект в памяти со значением 'Bogdan'
Узнать адресс обьекта в памяти можно при помощи встроенной в Пайтон функции id, которая в качестве параметра принимает название переменной
my_name = 'Bogdan'
print(id(my_name)) > 140719189080568
my_name = 'Kirilo'
print(id(my_name)) > 140719189080760
Ссылки на разные обьекты в памяти
my_name = 'Bogdan'
new_name = my_name
print(id(my_name)) > 140719189080568
print(id(new_name)) > 140719189080568
Ссылка на 1 обьект в памяти
При каждом запуске программы ссылки могут менятся, так как переменные создаются заново и заново записываются в память, попадая в ее новую область

Строка - это последовательность символов
Строка является экземпляром класса str
Строка - неизменяемым тип данных
Строку в несколько строк можно создать при помощи 3 одинарных или двойных кавычек """/'''
longStr = """multi
rows
string"""
Встроенная функция type - возвращает класс, обьектом которого является переменная переданная в качестве аргумента
print(type(longStr)) > class 'str'
Строка находится в обьекте, который является экземпляром класса str
Если функция type возвращает type (class 'type') - это значит что аргумент, переданный ей, сам является классом
type(str) > class 'str'
len - встроеная функция которая возвращает длину последовательности переданной как аргумент
print(len(longString)) > 17
Строка является упорядоченной последовательностью, а для них можно использовать синтаксис с квадратными скобками
В скобках указываются индексы нужных символов или их последовательностей
longStr[0] = 'm' - первый символ строки начиная с начала
longStr[-1] = 'g' - первый символ строки с конца
longStr[6:11] = 'rows' - набор символов с индекса 6 по 11
longStr[:11] - набор символов с начала, по символ с индексом 11
longStr[3:] - с индекса 3 и до крайнего
longStr[:] - вся строка

Целые числа являются экземпляром класса int
С помощью встроенной функции int можно конвертировать числа в формате строки в тип данных int
int('3') > 3
Для удобства чтения, большые числа, в Пайтон, можно разделять одним нижним подчеркиванием
bigInt = 1_00_0_0_0_0
print(bigInt) > 1000000
print(type(bigInt)) > class 'int'
smallInt = 1_1
print(smallInt) > 11
Если в функцию int будет передана строка, которая содержит не только числа, то будет выброшена ошибка и выполнение кода остановится на строке с этим вызовом int
int('Hi') > error
invalidInt = 1_0_00__0_00_0 > error (разрешено только 1 нижнее подчеркивание)

Числа с десятичной точкой являются экземплярами класса float
val = 10.5
print(type(val)) > class 'float'
Встроенный метод float позволяет конвертировать строки и числа других типов в тип float
str_val = '10.5'
float(str_val) > 10.5
Встроенный метод round округляет числа с десятичной точкой
round(7.5) > 8
round(8.5) > 8, round(val) > 10 ?

Комплексные числа являются экземплярами класса complex
Комплексное число состоят из действийтельной (целое число) и мнимой (число с j) частей
complex_a = 7 + 8j
complex_b = 9 + 7j
Сложение и вычитание комплексных чисел
complex_a + complex_b = 9 + 15j
complex_a - complex_b = 5 + 1j
Умножение комплексных числел более сложное
complex_a * complex_b = (7 + 8j)*(9 + 7j) = 7*9 + 7*7j + 8j*9 + 8j*7j = 63 + 49j + 72j + 56j^2
Мнимая часть в квадрате равна -1
56*j^2 = 56 * -1 = -56
63 + 49j + 72j - 56 = 7 + 121j

Логические значения являются экземпляром класса bool
Логический тип имеет всего 2 значения: True, False
type(True) # class 'bool'
Логический тип часто используется для проверки правдивости выражений: больше, меньше, сравнивания
print("Long string" > 'Short') # False - строки сравниваются посимвольно, а не их длина
print("Long string" > 'Long') # True - так как первый и 3 последующих символа совпадают
print("Long string" > 'long string') # False - L не соответствует l
print([1, 2, 3] == [1, 2, 3]) # True (в JS, Java - это 2 разных обьекта и поэтомму будет возвращено False)
При помощи встроенной функции bool любое значение можно конвертировать в тип bool
print(bool('Hi')) # True
print(bool(-1)) # True
print(bool(0)) # False
print(bool('')) # False
print(bool([])) # False (true в JS)
print(bool({})) # False (true в JS)
print(bool(None)) # False
print(9 > 2) # True - тут не используется конвертация в тип bool при помощи встроенной функции bool, потому что логический тип является результатом такого выражения (сравнения)

Пайтон не выполняет неявную конвертацию типов значений
В JS это доступно для строк и чисел: '1'+1 > '11', 8+(+'1') > 9
Если тип значения нужно конвертировать в другой, вы должны это сделать сами/явно, используя соответствующие встроенный функции
int(), str(), float(), list(), tuple(), set()
При операциях с некоторыми разными типами, в Пайтон, ошибка не выкидывается
int_num = 2
float_num = 1.9
int_num + float_num # 3.9
Под капотом, знак + заменяется на магический метод __add__ класса int
int_num.__add__(float_num)
В результате возвращается строка Not implemented, которая означает, что в классе int не реализована возможность сложения целого числа и дроби
После этого операнды меняются местами, вызывается метод __radd__ класса float и возвращается результат - 3.9
float_num.__radd__(int_num) # 3.9
Методы __add__ и __radd__ есть в обоих классах int и float, однако в каждом классе они работают по разному
В классе int, __add__ принимает в качестве аргумента только значения типа int, а в классе float, метод __radd__ значения типа float
В методе __radd__ класса float значения типа int конвертируются в тип float путем добавления точки и нулевой дробной части - .0

True + 2 # 3 - bool + int = int
True - 1, False - 0

str_val = 'abc'
int_num = 50
int_num * str_val # строка в которой 'abc' повторяется 50 раз
str_val * int_num # так же строка в которой 'abc' повторяется 50 раз
Это из-за того, что оба метода __mul__, __rmul__ в классе str, в качестве аргумента принимают целое число
str_val.__mul__(int_num) # строка в которой 'abc' повторяется 50 раз
int_num.__mul__(str_val) # Not implemented
str_val.__rmul__(int_num) # строка в которой 'abc' повторяется 50 раз
str_val.__rmul__('Hi') и str_val.__mul__('Hi') - вернут ошибки, так как в качестве аргумента передана строка, а не целое число

Методы имена которых начинаются и заканчиваются на 2 нижних подчеркивания ( __ ) называются магическими
Магические методы являются внутренними методами классов и вызываются неявно/под капотом, при использовании различных операторов (+, -, *, /)
[1, 2, 3].__eq__([1, 2, 3]) # True
В данном примере вызывается магический метод __eq__ класса list
Узнать, как работает магический метод можно при использовании функции help
help(list.__eq__) # описание метода __eq__ класса list
Многие магические методы определены сразу в нескольких классах, например метод __add__ есть в классах int, float, str

Список - упорядоченная последовательность элементов
Порядок элементов в списке имеет значение
Элементы в списке могут быть различных типов
post_ids = [155, 254, 762, 859]
post_ids2 = [254, 155, 762, 859]
post_ids == post_ids2 # False
Каждый элемент в списке имеет свой уникальный индекс, и начинается от с 0
Получить элемент с помощью его индекса можно используя его в квадратных скобках
makes_list[3] # 859
Если в квадратных скобках указывать индексы со знаком минус - будут выводится элементы начиная с конца списка
makes_list[-1] # 'Toyota'
Список относится к изменяемым типам данных
Изменять значения элементов можно при помощи индекса в квадратных скобках
post_ids[0] = 189
post_ids # [189, 254, 762, 859]
При изменении значения элемента списка не создается новый список, а мутируется текущий
Это можно проверить при помощи встроенной функции id
id(post_ids) # 2925927848128
post_ids[1] = 555
id(post_ids) # 2925927848128
Для удаление определенного элемента списка используется ОПЕРАТОР del
del post_ids[2]
post_ids # [189, 254, 859]
del post_ids[-1] - удаление последнего элемента списка при помощи отрицательного индекса
post_ids # [189, 254]
Элементы в список можно добавлять при помощи уже имеющихся переменных
post1_id = 36
post2_id = 87
post3_id = 111
new_posts_ids = [post1_id, post2_id, post3_id]
new_posts_ids # 36, 87, 111
Пайтон подставит значения переменных в соответствующие места в списке
Для доступа к значению словаря в квадратные скобки передается ключ в его исходном формате. Строка - строка, bool - bool и тд
vals_list = [{'one': 1, 'two': 2, 'three': 3, True: 'Hi'}, [1, 2, 3], True]
vals_list[0]['three'] # 3 - получить доступ к значению словаря, с ключем типа строка, внутри списка
vals_list[0][True] # 'Hi'
В JS это так же можно делать при помощи точечной записи, так как все ключи в обьектах являются строками - vals_list[0].three
При обращении к элементу за пределами списка, по ключу, который больше длины списка - будет выброшена ошибка индекса
vals_list[10] # IndexError: list index out of range - индекс 10 находится за границами списка, так как его длинна 3