Перевірити чи встановленний Пайтон на ПК:
Open the command line or PowerShell and type in: python --version
Якщо Пайтон встановленний на ПК - буде показана його версія, якщо ні - нічего

Перейти в інтерпритатор Пайтон в Командній строці або PowerShell:
Open the command line or PowerShell and type in: python
cls - to clear the cmd or PowerShell (not the Python interpreter)

PyCharm - інтегрована середа розробки (IDE) для Пайтон

В Пайтон все сущности - обьекты (даже число и строка - экземпляры классов)
Обьект - это экземпляр определенного класса
Класс - это шаблон, каркас для создания обьектов
Аттрибут обьекта, значение которого функция - метод

Типы данных в Пайтон:
int - целые числа (3, 0, -1)
str - строки ('Hi')
bool - логические значения (только true и false)
list (список) - набор данных (могут быть разных типов) через запятую в квардратных скобках ([1, 2, 3, 'Hi', true])
dict (словарь) - набор элементов, которые состоях из пары: ключ, значение, в фигурных скобках ({'min': 1, 'max': 3})

name = 'Bogdan'
name - переменная значение которой строка (str)
name - обьект типа строка, обьект класса строка (str)

Что бы вызвать функцию, к ее названию нужно добавить пару круглых скобок - myFn()
Методы обьектов вызываются с помощью точечной записи - name.upper()
Метод dir возвращает имена/названия/ключи всех аттрибутов обьекта

Встроенные (built-in) методы Пайтон:
print, input, dir, ...

Для выполнения кода Пайтон в терминале с использованием интерпретатора Пайтон - python3 main.py
Вместо 3 можно ввести любую другую нужную версию Пайтон
В JS - node main.js

Для разделения блоков кода во многих ЯП используются фигурные скобки {}
В Пайтон для этого используют отступы (4 пробела)
Работает и с 1-3 пробелами, но это не соответствует PEP8 (общепринятым правилам в Пайтон)
def show(text):
    print(text)


show('Hello from PyCharm')

Некоторые выдержки из PEP8:
Функции и классы должны быть отделены от других строк кода 2 пустыми строками
Файл с кодом должен заканчиваться 1 пустой строкой
Импорт каждого модуля должен быть на отдельной строке
Для отступов использовать 4 пробела, а не Tab
Длина строк должна быть менее 79 символов

Formatting Python code in the VS Code
Отфарматировать код под условия PEP8:
Ctrl+Shift+P
Fill in the appeared input field with "Format" word
Select "Format Document With..."
Select "Python"
Instal the Formatter "autopep8" if it's not installed yet

Set necessary formatter by default:
Ctrl+Shift+P
Select "Format Document With..."
Click on the "Configure Default Formatter..."
Choose "Python"

Automatically formatting of the file after saving the file:
Ctrl+,
Fill in the appeared input field with "Format on save" text
Activate a checkbox in the "Editor: Format On Save" block
The Formatter "autopep8" should be installed before

Комментарии игнорируются интерпретатором Пайтон
Комментарии добавляются при помощи знака решетки #
Многострочные комментарии можно сделать с использованием тройных одиранрых или двойных кавычек

Функции в Пайтон определяются при помощи ключевого слова def
После def идет название функции и круглые скобоки, а затем ставиться двоеточие, после которого идет блок кода функции
Тело функции, как и другие отдельные блоки кода, отделено от остального кода 4 пробелами слева
Параметр функции (name) - это переменная, которая указывается в круглых скобках, после названия функции, при ее обьявлении
Аргумент функции ('Bogdan') - это значение, которым инициализируется параметр функции
Параметру присваивается значение агрумента в момент вызова функции
def hello(name):
    print('Hi', name)
    print("How are you ?")


hello('Bogdan')


return - ключевое слово, инструкция, которая используется в функциях для возвращения значения из них
По умолчанию, в Пайтон, любая функция без ключевого слова return, возвращает None (в JS - undefined)
print(print('Bogdan'))
# Bogdan - результат вызова print('Bogdan')
# None - результат вызова функции print аргументом которой является значение, которое вернула print('Bogdan'), а она ничего не возвращает (нет return)
Как только функция доходит до слова return - она возвращает значение (если оно указано) и далее не выполняется, прекращает свою работу
Код, который находится после ключевого слова return, не будет выполнен

Выражение (expression) всегда возвращает значение
Функция - возвращает результат работы функции либо None,
5+4 - возвращает 9,
'Hello ' + 'World!' - возвращает новую строку "Hello World",
a>b - возвращает True или False
Все это выражения, так как они возвращают какое-то значение
Проверить, является ли часть кода выражением можно используя функцию print
Если блок кода является выражением - его результат будет выведен в консоль, а если нет - произойдет ошибка
print('Hello ' + 'World') > 'Hello World'
print(if True: print('Hi')) > error: expected expression

Инструкция (statements) выполняет действия
Создание/обьявление функции
my_name = 'Bogdan' - создание переменной
if True:
    print ('Hi') - логическая инструкция
import datetime
return result
print(import datetime) > error: expected expression
В JS создание переменной - выражение, которое возвращает undefined

Переменные дают возможность повторного доступа к значениям
snake_case используется для переменных, функций, методов и модулей
UPPER_SNAKE_CASE - для констант
PascalCase - для классов
dash-case - для пакетов
Пакеты - это наборы модулей

В Пайтон, обьявление переменной и присвоение ей значения происходит на 1 строке
name = 'Bogdan'
Эти действия нельзя разделять, это ошибка
name
name = 'Bogdan'
> error: name 'name' is not defined
Если переменная с таким же именем уже была создана ранее, то ее значение просто перезапишется/изменится
name = 'Kirilo'
name = 'Bogdan'
Пайтон - язык с динамической типизацией
Это значит, что одной и то й же переменной могут быть присвоенны значения разных типов (и даже функция)
val = 3
val = 'value'
val = True

В Пайтон отсутствуют примитивные типы данных (как например в JS - number ?)
Все сущности - обьекты
При создании переменной со значением целого числа, в памяти создается обьект класса int, значение которого указанное целое число
В Пайтон типы данных/обьекты делятся на изменяемые (mutable) и неизменяеммые (immutable)
Неизменяемый обьект нельзя изменить, можно только создать новый, с таким же названием и другим значением
Изменяемый тип можно изменять/мутировать (добавлять/удалять элементы, менять значение элементов), так как он сохраняется в памяти
К неизменяемым типам данных относятся: str, int, bool, float, None (имеет единственное значение None), tuple (кортеж), range
Изменяемые: list, dict, set, objects of user-defined classes (экземпляры классов созданных пользователем)

При создании переменной в памяти создается обьект
Переменная содержит/является ссылкой на этот обьект в памяти
Если переменной присвоить другое значение, то будет создан новый обьект, а старый, через некоторое время, будет удален Пайтон
Если переменной присвоить другую, ранее созданную переменную, то новый обьект не будет создаваться. Новая переменная будет проинициализированна ссылкой ранее созданной переменной
date = 09012024 - создается новый обьект в памяти. Переменная date не содержит значение 09012024, она содержит ссылку на обьект в памяти со значением 09012024
my_name = 'Bogdan' - создается обьект в памяти
my_name = 'Kirilo' - создается новый обьект в памяти, а предыдущий будет удален
my_name = 'Bogdan' - создается обьект в памяти
new_name = my_name - переменная new_name проинициализированна ссылкой в переменной my_name, новый обьект не создается
new_name и my_name содержат одну и ту же ссылку на один обьект в памяти со значением 'Bogdan'
Узнать адресс обьекта в памяти можно при помощи встроенной в Пайтон функции id, которая в качестве параметра принимает название переменной
my_name = 'Bogdan'
print(id(my_name)) > 140719189080568
my_name = 'Kirilo'
print(id(my_name)) > 140719189080760
Ссылки на разные обьекты в памяти
my_name = 'Bogdan'
new_name = my_name
print(id(my_name)) > 140719189080568
print(id(new_name)) > 140719189080568
Ссылка на 1 обьект в памяти
При каждом запуске программы ссылки могут менятся, так как переменные создаются заново и заново записываются в память, попадая в ее новую область

Строка - это последовательность символов
Строка является экземпляром класса str
Строка - неизменяемым тип данных
Строку в несколько строк можно создать при помощи 3 одинарных или двойных кавычек """/'''
longStr = """multi
rows
string"""
Встроенная функция type - возвращает класс, обьектом которого является переменная переданная в качестве аргумента
print(type(longStr)) > class 'str'
Строка находится в обьекте, который является экземпляром класса str
Если функция type возвращает type (class 'type') - это значит что аргумент, переданный ей, сам является классом
type(str) > class 'str'
len - встроеная функция которая возвращает длину последовательности переданной как аргумент
print(len(longString)) > 17
Строка является упорядоченной последовательностью, а для них можно использовать синтаксис с квадратными скобками
В скобках указываются индексы нужных символов или их последовательностей
longStr[0] = 'm' - первый символ строки начиная с начала
longStr[-1] = 'g' - первый символ строки с конца
longStr[6:11] = 'rows' - набор символов с индекса 6 по 11
longStr[:11] - набор символов с начала, по символ с индексом 11
longStr[3:] - с индекса 3 и до крайнего
longStr[:] - вся строка

Целые числа являются экземпляром класса int
С помощью встроенной функции int можно конвертировать числа в формате строки в тип данных int
int('3') > 3
Для удобства чтения, большые числа, в Пайтон, можно разделять одним нижним подчеркиванием
bigInt = 1_00_0_0_0_0
print(bigInt) > 1000000
print(type(bigInt)) > class 'int'
smallInt = 1_1
print(smallInt) > 11
Если в функцию int будет передана строка, которая содержит не только числа, то будет выброшена ошибка и выполнение кода остановится на строке с этим вызовом int
int('Hi') > error
invalidInt = 1_0_00__0_00_0 > error (разрешено только 1 нижнее подчеркивание)

Числа с десятичной точкой являются экземплярами класса float
val = 10.5
print(type(val)) > class 'float'
Встроенный метод float позволяет конвертировать строки и числа других типов в тип float
str_val = '10.5'
float(str_val) > 10.5
Встроенный метод round округляет числа с десятичной точкой
round(7.5) > 8
round(8.5) > 8, round(val) > 10 ?

Комплексные числа являются экземплярами класса complex
Комплексное число состоят из действийтельной (целое число) и мнимой (число с j) частей
complex_a = 7 + 8j
complex_b = 9 + 7j
Сложение и вычитание комплексных чисел
complex_a + complex_b = 9 + 15j
complex_a - complex_b = 5 + 1j
Умножение комплексных числел более сложное
complex_a * complex_b = (7 + 8j)*(9 + 7j) = 7*9 + 7*7j + 8j*9 + 8j*7j = 63 + 49j + 72j + 56j^2
Мнимая часть в квадрате равна -1
56*j^2 = 56 * -1 = -56
63 + 49j + 72j - 56 = 7 + 121j

Логические значения являются экземпляром класса bool
Логический тип имеет всего 2 значения: True, False
type(True) # class 'bool'
Логический тип часто используется для проверки правдивости выражений: больше, меньше, сравнивания
print("Long string" > 'Short') # False - строки сравниваются посимвольно, а не их длина
print("Long string" > 'Long') # True - так как первый и 3 последующих символа совпадают
print("Long string" > 'long string') # False - L не соответствует l
print([1, 2, 3] == [1, 2, 3]) # True (в JS, Java - это 2 разных обьекта и поэтомму будет возвращено False)
При помощи встроенной функции bool любое значение можно конвертировать в тип bool
print(bool('Hi')) # True
print(bool(-1)) # True
print(bool(0)) # False
print(bool('')) # False
print(bool([])) # False (true в JS)
print(bool({})) # False (true в JS)
print(bool(None)) # False
print(9 > 2) # True - тут не используется конвертация в тип bool при помощи встроенной функции bool, потому что логический тип является результатом такого выражения (сравнения)

Пайтон не выполняет неявную конвертацию типов значений
В JS это доступно для строк и чисел: '1'+1 > '11', 8+(+'1') > 9
Если тип значения нужно конвертировать в другой, вы должны это сделать сами/явно, используя соответствующие встроенный функции
int(), str(), float(), list(), tuple(), set()
При операциях с некоторыми разными типами, в Пайтон, ошибка не выкидывается
int_num = 2
float_num = 1.9
int_num + float_num # 3.9
Под капотом, знак + заменяется на магический метод __add__ класса int
int_num.__add__(float_num)
В результате возвращается строка Not implemented, которая означает, что в классе int не реализована возможность сложения целого числа и дроби
После этого операнды меняются местами, вызывается метод __radd__ класса float и возвращается результат - 3.9
float_num.__radd__(int_num) # 3.9
Методы __add__ и __radd__ есть в обоих классах int и float, однако в каждом классе они работают по разному
В классе int, __add__ принимает в качестве аргумента только значения типа int, а в классе float, метод __radd__ значения типа float
В методе __radd__ класса float значения типа int конвертируются в тип float путем добавления точки и нулевой дробной части - .0

True + 2 # 3 - bool + int = int
True - 1, False - 0

str_val = 'abc'
int_num = 50
int_num * str_val # строка в которой 'abc' повторяется 50 раз
str_val * int_num # так же строка в которой 'abc' повторяется 50 раз
Это из-за того, что оба метода __mul__, __rmul__ в классе str, в качестве аргумента принимают целое число
str_val.__mul__(int_num) # строка в которой 'abc' повторяется 50 раз
int_num.__mul__(str_val) # Not implemented
str_val.__rmul__(int_num) # строка в которой 'abc' повторяется 50 раз
str_val.__rmul__('Hi') и str_val.__mul__('Hi') - вернут ошибки, так как в качестве аргумента передана строка, а не целое число

Методы имена которых начинаются и заканчиваются на 2 нижних подчеркивания ( __ ) называются магическими
Магические методы являются внутренними методами классов и вызываются неявно/под капотом, при использовании различных операторов (+, -, *, /)
[1, 2, 3].__eq__([1, 2, 3]) # True
В данном примере вызывается магический метод __eq__ класса list
Узнать, как работает магический метод можно при использовании функции help
help(list.__eq__) # описание метода __eq__ класса list
Многие магические методы определены сразу в нескольких классах, например метод __add__ есть в классах int, float, str

Список - упорядоченная последовательность элементов
Порядок элементов в списке имеет значение
Элементы в списке могут быть различных типов
post_ids = [155, 254, 762, 859]
post_ids2 = [254, 155, 762, 859]
post_ids == post_ids2 # False
Каждый элемент в списке имеет свой уникальный индекс, и начинается от с 0
Получить элемент с помощью его индекса можно используя его в квадратных скобках
makes_list[3] # 859
Если в квадратных скобках указывать индексы со знаком минус - будут выводится элементы начиная с конца списка
makes_list[-1] # 'Toyota'
Список относится к изменяемым типам данных
Изменять значения элементов можно при помощи индекса в квадратных скобках
post_ids[0] = 189
post_ids # [189, 254, 762, 859]
При изменении значения элемента списка не создается новый список, а мутируется текущий
Это можно проверить при помощи встроенной функции id
id(post_ids) # 2925927848128
post_ids[1] = 555
id(post_ids) # 2925927848128
Для удаление определенного элемента списка используется ОПЕРАТОР del
del post_ids[2]
post_ids # [189, 254, 859]
del post_ids[-1] - удаление последнего элемента списка при помощи отрицательного индекса
post_ids # [189, 254]
Элементы в список можно добавлять при помощи уже имеющихся переменных
post1_id = 36
post2_id = 87
post3_id = 111
new_posts_ids = [post1_id, post2_id, post3_id]
new_posts_ids # 36, 87, 111
Пайтон подставит значения переменных в соответствующие места в списке
Для доступа к значению словаря в квадратные скобки передается ключ в его исходном формате. Строка - строка, bool - bool и тд
vals_list = [{'one': 1, 'two': 2, 'three': 3, True: 'Hi'}, [1, 2, 3], True]
vals_list[0]['three'] # 3 - получить доступ к значению словаря, с ключем типа строка, внутри списка
vals_list[0][True] # 'Hi'
В JS это так же можно делать при помощи точечной записи, так как все ключи в обьектах являются строками - vals_list[0].three
При обращении к элементу за пределами списка, по ключу, который больше длины списка - будет выброшена ошибка индекса
vals_list[10] # IndexError: list index out of range - индекс 10 находится за границами списка, так как его длинна 3
Методы списков:
1.) append - добавляет переданный параметр в конец списка,
2.) insert - принимает 2 параметра, 1ый - это индекс в списке, а 2ой - значение, которое нужно вставить в список по указанному индексу
Элементы списка, которые находятся после указанного индекса сдвигаются вправо на 1
3.) pop - удаляет элемент из списка
Может вызыватся с параметром и без
Если параметр не указан - удаляет последний элемент списка, если параметр передается - он используется в качестве индекса по которому удаляется элемент списка
Метод pop возвращает удаленный элемент, поэтому он может быть присвоен переменной
post_ids = [189, 254, 387, 543, 859]
removed_val = post_ids.pop()
removed_val # 859
post_ids # [189, 254, 387, 543]
post_ids(0) # 189
post_ids # [254, , 387, 543]
4.) sort - может быть вызван с именованным параметром и его значением и без парметра
Если вызывается без параметра - список сортируется по возростанию
Если передан именованный параметр reverse и значение True - сортируется по убыванию
post_ids = [859, 254, 387, 189, 543]
post_ids.sort() # [189, 254, 387, 543, 859]
post_ids.sort(reverse=True) # [859, 543, 387, 254, 189]
5.) insert - вставляет элемент в список
Принимает 2 параметра: 1-ый - индекс элемента в списке, перед которым нужно вставить значение, переданное как 2-ой параметр
arr = [1, 2, 3, 5, 8, 9, 11]
arr.insert(3, 4)
arr # [1, 2, 3, 4, 5, 8, 9, 11]
В список (list) можно конвертировать другие последовательности (строки, словари) при помощи встроенного метода list
greetings = 'Hello all'
list(greetings) # ['H', 'e', 'l', 'l', 'o', ' ', 'a', 'l', 'l']
При конвертации словаря в список, добавляются только ключи, а значения теряются
vals_dict = {a: 3, b: 5, c: 7, d: 8, e:9, f: 11}
list(vals_dict) # [a, b, c, d, e, f]
Для арифметических операций со списками используются методы min, max, sum
post_ids = [189, 254, 387, 543, 859]
max(post_ids) # 859
Соеденить несколько списков в один можно при помощи оператора +
Это возможно благодаря тому, что под капотом, оператор + заменяется на вызов магического метода __add__ класса list, который умеет соединять списки
post_ids = [189, 254, 387, 543, 859]
keys = [a, b, c, d, e, f]
post_ids + keys # [189, 254, 387, 543, 859, a, b, c, d, e, f]
Добавить список в конец другого списка можна так же используя метод extend()
first_list = [1, 2, 3, 4, 5]
second_list = [6, 7, 8, 9, 10, 11]
first_list.extend(second_list)
first_list # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Часть списка можно получить указав в квадратных скобках, разделив двоеточием, индекс нужного первого элемента и индекс, до которого, нужны элементы
post_ids = [189, 254, 387, 543, 859]
post_ids[1:3] # [254, 387]
post_ids[-3:5] # [387, 543, 859]
post_ids[1:-1] # [254, 387, 543]
Скопировать список, как отдельный обьект, можно 3 способами:
newarr = arr.copy()
newarr = list(arr)
newarr = arr[:]
Копирование путем присвоения 1 списка другому приводит к копированию ссылки в новую переменную, а не созданию нового, отдельного обьекта
newarr = arr
id(newarr) == id(arr) # True

Словарь - обьект класса dict, это не упорядоченная последовательность элементов, где каждый элемент состоит из пары: ключ, значение
Ключ отделяется от значения двоеточием, а элементы разделены запятыми
Ключ должен быть типа str, тоесть в кавычках
Ключи в словарях - уникальны и не могут повторятся
Если добавить пару ключ-значение, у которой ключ уже есть в словаре - в таком случае его текущее значение просто перезапишется на новое
Значение может быть любого типа: другой словарь, список, функция и тд
my_car = {
	'make': 'BMW',
	'model': 5,
	'fast': True
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'}
}
Порядок элементов в списке - не важен (в отличии от строк и списков)
my_car_again = {
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'},
	'make': 'BMW',
	'fast': True,
	'model': 5,
}
my_car == my_car_again # True - порядок ключей разный, но их названия, количество и значения - одинаковые
В Пайтон сравнить 2 разных обьекта можно при помощи оператора сравнения ==
not_my_car = {
	'make': 'BMW',
	'model': 5,
	'fast': False
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'}
}
my_car == not_my_car # False - значения у одного из ключей разные
Для доступа к значениям ключей используются квадратные скобки и нужный ключ внутри них. Ключ передается как строка
my_car['make'] # 'BMW'
Синтаксис с точечной записью не доступен для ключей списков в Пайтон, (доступен в JS), так как они не являются аттрибутами, а данный синтаксис работает только с ними
my_car.make # NameError
То, что ключи словаря не являются аттрибутами можно подтвердить при помощи метода dir
dir(my_car) # будут выведены аттрибуты, обычные и магические методы класса dict, а make, model, fast и specs - отсутствуют
Этот же синтаксис используется для:
изменения значений существующих ключей в словарях
my_car['model'] = 'X5'
добавления новых
my_car['price'] = 70000
и удаления ключей и, соответственно, их значений
Но для этого необходим оператор del
del my_car['fast']
Переменные можно использовать для:
1.) создания словарей
make = 'brand'
model = 'model'
cost = 'price'
my_car = {
    make: 'BMW',
    model: 'X5',
    cost: 90000
}
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 90000}
2.) добавления новых ключей в словарь
painted = 'color'
wheels = 'tires'
my_car[painted] = 'black'
my_car[wheels] = 21
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 90000, 'color': 'black', 'tires': 21}
3.) добавления новых значений
is_fast = True
year = 2024
my_car['fast'] = is_fast
my_car['produced'] = year
{'brand': 'BMW', 'model': 'X5', 'price': 90000, 'color': 'black', 'tires': 21, 'fast': True, 'produced': 2024}
4.) или изменения значений, если такой ключ уже есть в словаре
price = 85000
my_car['price'] = price
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 85000, 'color': 'black', 'tires': 21, 'fast': True, 'produced': 2024}
Количество элементов в словаре можно получить при помощи встроенной функции len
len(my_car) # 7
Если попытаться использовать ключ, которого нет в словаре - будет выброшена ошибка ключа и выполнение кода остановится
my_car['engine_volume'] # KeyError
Если вы не уверены, что ключ есть в словаре, можно использовать метод словарей get.
Если ключа нет в словаре - он вернет None, если есть - его значение. Тоесть в любом случае ошибки не будет и выполнение кода не будет остановлено
my_car.get('engine_volume') # None
В случае, когда ключ отсутсвует, значение по умолчанию None можно заменить на любое другое, указав его после названия ключа и запятой, в вызове метода get
my_car.get('engine_volume', 'Absent) # 'Absent'
Создавать словари можно при помощи встроенной функции-конструктора dict
Если она вызывается без аргументов - будет создан пустой словарь
empty_dict = dict() # {}
В качестве аргументов можно передавать пары ключ-значение, через запятую, в таком формате
new_dict = dict(one=1, two='two', three=True)
new_dict # {'one': 1, 'two': 'two', 'three': True}
Как итерируемый список, с таким ситаксисом
new_dict2 = dict([('first', 'one'), ('second', 'two'), ('third', 3)])
new_dict2 # {'first': 'one', 'second': 'two', 'third': 3}
my_dict = {'first': 'one', 'second': 'two', 'third': 3}

Методы словарей:
1.) my_dict.keys() - возвращает обьект класса dict_keys, который содержит список из ключей словаря my_dict
# dict_keys(['first', 'second', 'third'])
2.) my_dict.values() - возвращает обьект класса dict_values, к	оторый содержит кортеж из значений словаря my_dict
# dict_values(['one', 'two', 3])
3.) my_dict.items() - возвращает обьект класса dict_items, который содержит список кортежей, каждый из которых содержит пару ключ и значение словаря my_dict
# dict_items([('second', 'two'), ('first', 'one'), ('third', 3)])
Для создания нового словаря на основе другого (копирования) используеться метод copy
new_dict = my_dict.copy()
Созданный словарь в результате вызова метода copy является новым, отдельным обьектом
id(my_dict) == id(new_dict) # False
Создать новый словарь можно на основе последовательности, в которой есть 2 значения, они будут интерпретированы как ключ и значение
1.) Списка списков
dict1 = dict([['first', 1], ['second', 'two'], ['third', True]])
2.) Списка кортежей
dict2 = dict([('first', 1), ('second', 'two'), ('third', True)])
3.) Кортежа кортежей
dict3 = dict((('first', 1), ('second', 'two'), ('third', True)))
4.) Списка в котором есть списки и кортежи
dict4 = dict([('first', 1), ['second', 'two'], ['third', True]])
5.) Кортежа в котором есть списки и кортежи
dict5 = dict((['first', 1], ('second', 'two'), ('third', True)))
Все 5 списков - {'first': 1, 'second': 'two', 'third': True}
Для создания словаря из 1 пары ключ, значение, с помощью кортежа кортежей, нужно после 1-го элемента поставить запятую
tuple1 = (('first', 1))
dict6 = dict(tuple1) # Error
tuple1 = (('first', 1),)
dict7 = dict(tuple1) # {'first': 1}

Кортеж (tuple) - обьект класса tuple - это упорядоченная последовательность элементов
Порядок элементов в кортеже важен
tuple1 = (1, 2, 3, 5)
tuple2 = (3, 1, 2, 5)
tuple1 == tuple2 # False - элементы одинаковые, но их последовательность - разная
Кортеж является не изменяемым типом данных, тоесть в него нельзя добавить или удалить новые элементы
tuple[4] = 7 # TypeError
del tuple[1] # TypeError
Изменять элементы кортежа можно только в том случае, если их тип данных - изменяемый
tuple1[3] = 'Three' # TypeError - тип данных int - не изменяемый, поэтому выпадает ошибка
tuple3 = ([1, 2, 3], [5, 7, 8], [9, 11, 18])
tuple3[0][2] = 'Three'
tuple3 # ([1, 2, 'Three'], [5, 7, 8], [9, 11, 18]) - list, как и dict, set - изменяемые типы данных, поэтому их в Кортеже можно изменить и ошибки не будет
Функция len доступна и для Кортежей и возвращает их длину
Обьеденять кортежи можно при помощи оператора +
В такой способ соединять кортежи и списки нельзя
У Кортежа 2 метода:
1.) count - возвращает количество раз сколько переданный аргумент встречается в Кортеже
2.) index - возвращает индекс переданного аргумента
Может принимать 1 или 2 аргумента, где 1-ый - элемент индекс которого ищем, 2-ой - индекс с которого начинать поиск этого элемента
tuple1 = (1, 2, 3, 4, 5, 3, 8, 9, 11)
tuple1.index(3, 4) # 5 - ищем индекс элемента 3 начиная с индекса 4
tuple1[5] # 3
Если аргумент встречается в Кортеже несколько раз - будет возвращен индекс первого такого элемента
Если такого аргумента нет в Кортеже - будет выброшена ошибка
Метода get Кортежей нет
Последовательность элементов можно конвертировать в Кортеж используя встроенную функцию tuple()
list1 = [1, 2, 3]
tuple1 = tuple(list1)
type(tuple1) # tuple
Если Кортеж нужно изменить, его можно конвертировать в список, при помощи функции list, изменить, а затем конвертировать обратно в Кортеж используя функцию tuple
При конвертации словаря в Кортеж добавляются только ключи, а значения теряются
vals_dict = {a: 3, b: 5, c: 7, d: 8, e:9, f: 11}
tuple(vals_dict) # (a, b, c, d, e, f)
