 Перевірити чи встановленний Пайтон на ПК:
Open the command line or PowerShell and type in: python --version
Якщо Пайтон встановленний на ПК - буде показана його версія, якщо ні - нічего

Перейти в інтерпритатор Пайтон в Командній строці або PowerShell:
Open the command line or PowerShell and type in: python
cls - to clear the cmd or PowerShell (not the Python interpreter)

PyCharm - інтегрована середа розробки (IDE) для Пайтон

В Пайтон все сущности - обьекты (даже число и строка - экземпляры классов)
Обьект - это экземпляр определенного класса
Класс - это шаблон, каркас для создания обьектов
Аттрибут обьекта, значение которого функция - метод

Типы данных в Пайтон:
int - целые числа (3, 0, -1)
str - строки ('Hi')
bool - логические значения (только true и false)
list (список) - набор данных (могут быть разных типов) через запятую в квардратных скобках ([1, 2, 3, 'Hi', true])
dict (словарь) - набор элементов, которые состоях из пары: ключ, значение, в фигурных скобках ({'min': 1, 'max': 3})

name = 'Bogdan'
name - переменная значение которой строка (str)
name - обьект типа строка, обьект класса строка (str)

Что бы вызвать функцию, к ее названию нужно добавить пару круглых скобок - myFn()
Методы обьектов вызываются с помощью точечной записи - name.upper()
Метод dir возвращает имена/названия/ключи всех аттрибутов обьекта

Встроенные (built-in) методы Пайтон:
print, input, dir, ...

Для выполнения кода Пайтон в терминале с использованием интерпретатора Пайтон - python3 main.py
Вместо 3 можно ввести любую другую нужную версию Пайтон
В JS - node main.js

Для разделения блоков кода во многих ЯП используются фигурные скобки {}
В Пайтон для этого используют отступы (4 пробела)
Работает и с 1-3 пробелами, но это не соответствует PEP8 (общепринятым правилам в Пайтон)
def show(text):
    print(text)


show('Hello from PyCharm')

Некоторые выдержки из PEP8:
Функции и классы должны быть отделены от других строк кода 2 пустыми строками
Файл с кодом должен заканчиваться 1 пустой строкой
Импорт каждого модуля должен быть на отдельной строке
Для отступов использовать 4 пробела, а не Tab
Длина строк должна быть менее 79 символов

Formatting Python code in the VS Code
Отфарматировать код под условия PEP8:
Ctrl+Shift+P
Fill in the appeared input field with "Format" word
Select "Format Document With..."
Select "Python"
Instal the Formatter "autopep8" if it's not installed yet

Set necessary formatter by default:
Ctrl+Shift+P
Select "Format Document With..."
Click on the "Configure Default Formatter..."
Choose "Python"

Automatically formatting of the file after saving the file:
Ctrl+,
Fill in the appeared input field with "Format on save" text
Activate a checkbox in the "Editor: Format On Save" block
The Formatter "autopep8" should be installed before

Комментарии игнорируются интерпретатором Пайтон
Комментарии добавляются при помощи знака решетки #
Многострочные комментарии можно сделать с использованием тройных одиранрых или двойных кавычек

Функции в Пайтон определяются при помощи ключевого слова def
После def идет название функции и круглые скобоки, а затем ставиться двоеточие, после которого идет блок кода функции
Тело функции, как и другие отдельные блоки кода, отделено от остального кода 4 пробелами слева
Параметр функции (name) - это переменная, которая указывается в круглых скобках, после названия функции, при ее обьявлении
Аргумент функции ('Bogdan') - это значение, которым инициализируется параметр функции
Параметру присваивается значение агрумента в момент вызова функции
def hello(name):
    print('Hi', name)
    print("How are you ?")


hello('Bogdan')


return - ключевое слово, инструкция, которая используется в функциях для возвращения значения из них
По умолчанию, в Пайтон, любая функция без ключевого слова return, возвращает None (в JS - undefined)
print(print('Bogdan'))
# Bogdan - результат вызова print('Bogdan')
# None - результат вызова функции print аргументом которой является значение, которое вернула print('Bogdan'), а она ничего не возвращает (нет return)
Как только функция доходит до слова return - она возвращает значение (если оно указано) и далее не выполняется, прекращает свою работу
Код, который находится после ключевого слова return, не будет выполнен

Выражение (expression) всегда возвращает значение
Функция - возвращает результат работы функции либо None,
5+4 - возвращает 9,
'Hello ' + 'World!' - возвращает новую строку "Hello World",
a>b - возвращает True или False
Все это выражения, так как они возвращают какое-то значение
Проверить, является ли часть кода выражением можно используя функцию print
Если блок кода является выражением - его результат будет выведен в консоль, а если нет - произойдет ошибка
print('Hello ' + 'World') > 'Hello World'
print(if True: print('Hi')) > error: expected expression

Инструкция (statements) выполняет действия
Создание/обьявление функции
my_name = 'Bogdan' - создание переменной
if True:
    print ('Hi') - логическая инструкция
import datetime
return result
print(import datetime) > error: expected expression
В JS создание переменной - выражение, которое возвращает undefined

Переменные дают возможность повторного доступа к значениям
snake_case используется для переменных, функций, методов и модулей
UPPER_SNAKE_CASE - для констант
PascalCase - для классов
dash-case - для пакетов
Пакеты - это наборы модулей

В Пайтон, обьявление переменной и присвоение ей значения происходит на 1 строке
name = 'Bogdan'
Эти действия нельзя разделять, это ошибка
name
name = 'Bogdan'
> error: name 'name' is not defined
Если переменная с таким же именем уже была создана ранее, то ее значение просто перезапишется/изменится
name = 'Kirilo'
name = 'Bogdan'
Пайтон - язык с динамической типизацией
Это значит, что одной и то й же переменной могут быть присвоенны значения разных типов (и даже функция)
val = 3
val = 'value'
val = True

В Пайтон отсутствуют примитивные типы данных (как например в JS - number ?)
Все сущности - обьекты
При создании переменной со значением целого числа, в памяти создается обьект класса int, значение которого указанное целое число
В Пайтон типы данных/обьекты делятся на изменяемые (mutable) и неизменяеммые (immutable)
Неизменяемый обьект нельзя изменить, можно только создать новый, с таким же названием и другим значением
Изменяемый тип можно изменять/мутировать (добавлять/удалять элементы, менять значение элементов), так как он сохраняется в памяти
К неизменяемым типам данных относятся: str, int, bool, float, None (имеет единственное значение None), tuple (кортеж), range
Изменяемые: list, dict, set, objects of user-defined classes (экземпляры классов созданных пользователем)

При создании переменной в памяти создается обьект
Переменная содержит/является ссылкой на этот обьект в памяти
Если переменной присвоить другое значение, то будет создан новый обьект, а старый, через некоторое время, будет удален Пайтон
Если переменной присвоить другую, ранее созданную переменную, то новый обьект не будет создаваться. Новая переменная будет проинициализированна ссылкой ранее созданной переменной
date = 09012024 - создается новый обьект в памяти. Переменная date не содержит значение 09012024, она содержит ссылку на обьект в памяти со значением 09012024
my_name = 'Bogdan' - создается обьект в памяти
my_name = 'Kirilo' - создается новый обьект в памяти, а предыдущий будет удален
my_name = 'Bogdan' - создается обьект в памяти
new_name = my_name - переменная new_name проинициализированна ссылкой в переменной my_name, новый обьект не создается
new_name и my_name содержат одну и ту же ссылку на один обьект в памяти со значением 'Bogdan'
Узнать адресс обьекта в памяти можно при помощи встроенной в Пайтон функции id, которая в качестве параметра принимает название переменной
my_name = 'Bogdan'
print(id(my_name)) > 140719189080568
my_name = 'Kirilo'
print(id(my_name)) > 140719189080760
Ссылки на разные обьекты в памяти
my_name = 'Bogdan'
new_name = my_name
print(id(my_name)) > 140719189080568
print(id(new_name)) > 140719189080568
Ссылка на 1 обьект в памяти
При каждом запуске программы ссылки могут менятся, так как переменные создаются заново и заново записываются в память, попадая в ее новую область

Строка - это последовательность символов
Строка является экземпляром класса str
Строка - неизменяемым тип данных
Строку в несколько строк можно создать при помощи 3 одинарных или двойных кавычек """/'''
longStr = """multi
rows
string"""
Встроенная функция type - возвращает класс, обьектом которого является переменная переданная в качестве аргумента
print(type(longStr)) > class 'str'
Строка находится в обьекте, который является экземпляром класса str
Если функция type возвращает type (class 'type') - это значит что аргумент, переданный ей, сам является классом
type(str) > class 'str'
len - встроеная функция которая возвращает длину последовательности переданной как аргумент
print(len(longString)) > 17
Строка является упорядоченной последовательностью, а для них можно использовать синтаксис с квадратными скобками
В скобках указываются индексы нужных символов или их последовательностей
longStr[0] = 'm' - первый символ строки начиная с начала
longStr[-1] = 'g' - первый символ строки с конца
longStr[6:11] = 'rows' - набор символов с индекса 6 по 11
longStr[:11] - набор символов с начала, по символ с индексом 11
longStr[3:] - с индекса 3 и до крайнего
longStr[:] - вся строка

Целые числа являются экземпляром класса int
С помощью встроенной функции int можно конвертировать числа в формате строки в тип данных int
int('3') > 3
Для удобства чтения, большые числа, в Пайтон, можно разделять одним нижним подчеркиванием
bigInt = 1_00_0_0_0_0
print(bigInt) > 1000000
print(type(bigInt)) > class 'int'
smallInt = 1_1
print(smallInt) > 11
Если в функцию int будет передана строка, которая содержит не только числа, то будет выброшена ошибка и выполнение кода остановится на строке с этим вызовом int
int('Hi') > error
invalidInt = 1_0_00__0_00_0 > error (разрешено только 1 нижнее подчеркивание)

Числа с десятичной точкой являются экземплярами класса float
val = 10.5
print(type(val)) > class 'float'
Встроенный метод float позволяет конвертировать строки и числа других типов в тип float
str_val = '10.5'
float(str_val) > 10.5
Встроенный метод round округляет числа с десятичной точкой
round(7.5) > 8
round(8.5) > 8, round(val) > 10 ?

Комплексные числа являются экземплярами класса complex
Комплексное число состоят из действийтельной (целое число) и мнимой (число с j) частей
complex_a = 7 + 8j
complex_b = 9 + 7j
Сложение и вычитание комплексных чисел
complex_a + complex_b = 9 + 15j
complex_a - complex_b = 5 + 1j
Умножение комплексных числел более сложное
complex_a * complex_b = (7 + 8j)*(9 + 7j) = 7*9 + 7*7j + 8j*9 + 8j*7j = 63 + 49j + 72j + 56j^2
Мнимая часть в квадрате равна -1
56*j^2 = 56 * -1 = -56
63 + 49j + 72j - 56 = 7 + 121j

Логические значения являются экземпляром класса bool
Логический тип имеет всего 2 значения: True, False
type(True) # class 'bool'
Логический тип часто используется для проверки правдивости выражений: больше, меньше, сравнивания
print("Long string" > 'Short') # False - строки сравниваются посимвольно, а не их длина
print("Long string" > 'Long') # True - так как первый и 3 последующих символа совпадают
print("Long string" > 'long string') # False - L не соответствует l
print([1, 2, 3] == [1, 2, 3]) # True (в JS, Java - это 2 разных обьекта и поэтомму будет возвращено False)
При помощи встроенной функции bool любое значение можно конвертировать в тип bool
print(bool('Hi')) # True
print(bool(-1)) # True
print(bool(0)) # False
print(bool('')) # False
print(bool([])) # False (true в JS)
print(bool({})) # False (true в JS)
print(bool(None)) # False
print(9 > 2) # True - тут не используется конвертация в тип bool при помощи встроенной функции bool, потому что логический тип является результатом такого выражения (сравнения)

Пайтон не выполняет неявную конвертацию типов значений
В JS это доступно для строк и чисел: '1'+1 > '11', 8+(+'1') > 9
Если тип значения нужно конвертировать в другой, вы должны это сделать сами/явно, используя соответствующие встроенный функции
int(), str(), float(), list(), tuple(), set()
При операциях с некоторыми разными типами, в Пайтон, ошибка не выкидывается
int_num = 2
float_num = 1.9
int_num + float_num # 3.9
Под капотом, знак + заменяется на магический метод __add__ класса int
int_num.__add__(float_num)
В результате возвращается строка Not implemented, которая означает, что в классе int не реализована возможность сложения целого числа и дроби
После этого операнды меняются местами, вызывается метод __radd__ класса float и возвращается результат - 3.9
float_num.__radd__(int_num) # 3.9
Методы __add__ и __radd__ есть в обоих классах int и float, однако в каждом классе они работают по разному
В классе int, __add__ принимает в качестве аргумента только значения типа int, а в классе float, метод __radd__ значения типа float
В методе __radd__ класса float значения типа int конвертируются в тип float путем добавления точки и нулевой дробной части - .0

True + 2 # 3 - bool + int = int
True - 1, False - 0

str_val = 'abc'
int_num = 50
int_num * str_val # строка в которой 'abc' повторяется 50 раз
str_val * int_num # так же строка в которой 'abc' повторяется 50 раз
Это из-за того, что оба метода __mul__, __rmul__ в классе str, в качестве аргумента принимают целое число
str_val.__mul__(int_num) # строка в которой 'abc' повторяется 50 раз
int_num.__mul__(str_val) # Not implemented
str_val.__rmul__(int_num) # строка в которой 'abc' повторяется 50 раз
str_val.__rmul__('Hi') и str_val.__mul__('Hi') - вернут ошибки, так как в качестве аргумента передана строка, а не целое число

Методы имена которых начинаются и заканчиваются на 2 нижних подчеркивания ( __ ) называются магическими
Магические методы являются внутренними методами классов и вызываются неявно/под капотом, при использовании различных операторов (+, -, *, /)
[1, 2, 3].__eq__([1, 2, 3]) # True
В данном примере вызывается магический метод __eq__ класса list
Узнать, как работает магический метод можно при использовании функции help
help(list.__eq__) # описание метода __eq__ класса list
Многие магические методы определены сразу в нескольких классах, например метод __add__ есть в классах int, float, str

Список - упорядоченная последовательность элементов
Порядок элементов в списке имеет значение
Элементы в списке могут быть различных типов
post_ids = [155, 254, 762, 859]
post_ids2 = [254, 155, 762, 859]
post_ids == post_ids2 # False
Каждый элемент в списке имеет свой уникальный индекс, и начинается от с 0
Получить элемент с помощью его индекса можно используя его в квадратных скобках
makes_list[3] # 859
Если в квадратных скобках указывать индексы со знаком минус - будут выводится элементы начиная с конца списка
makes_list[-1] # 'Toyota'
Список относится к изменяемым типам данных
Изменять значения элементов можно при помощи индекса в квадратных скобках
post_ids[0] = 189
post_ids # [189, 254, 762, 859]
При изменении значения элемента списка не создается новый список, а мутируется текущий
Это можно проверить при помощи встроенной функции id
id(post_ids) # 2925927848128
post_ids[1] = 555
id(post_ids) # 2925927848128
Для удаление определенного элемента списка используется ОПЕРАТОР del
del post_ids[2]
post_ids # [189, 254, 859]
del post_ids[-1] - удаление последнего элемента списка при помощи отрицательного индекса
post_ids # [189, 254]
Элементы в список можно добавлять при помощи уже имеющихся переменных
post1_id = 36
post2_id = 87
post3_id = 111
new_posts_ids = [post1_id, post2_id, post3_id]
new_posts_ids # 36, 87, 111
Пайтон подставит значения переменных в соответствующие места в списке
Для доступа к значению словаря в квадратные скобки передается ключ в его исходном формате. Строка - строка, bool - bool и тд
vals_list = [{'one': 1, 'two': 2, 'three': 3, True: 'Hi'}, [1, 2, 3], True]
vals_list[0]['three'] # 3 - получить доступ к значению словаря, с ключем типа строка, внутри списка
vals_list[0][True] # 'Hi'
В JS это так же можно делать при помощи точечной записи, так как все ключи в обьектах являются строками - vals_list[0].three
При обращении к элементу за пределами списка, по ключу, который больше длины списка - будет выброшена ошибка индекса
vals_list[10] # IndexError: list index out of range - индекс 10 находится за границами списка, так как его длинна 3
Методы списков:
1.) append - добавляет переданный параметр в конец списка,
2.) insert - принимает 2 параметра, 1ый - это индекс в списке, а 2ой - значение, которое нужно вставить в список по указанному индексу
Элементы списка, которые находятся после указанного индекса сдвигаются вправо на 1
3.) pop - удаляет элемент из списка
Может вызыватся с параметром и без
Если параметр не указан - удаляет последний элемент списка, если параметр передается - он используется в качестве индекса по которому удаляется элемент списка
Метод pop возвращает удаленный элемент, поэтому он может быть присвоен переменной
post_ids = [189, 254, 387, 543, 859]
removed_val = post_ids.pop()
removed_val # 859
post_ids # [189, 254, 387, 543]
post_ids(0) # 189
post_ids # [254, , 387, 543]
4.) sort - может быть вызван с именованным параметром и его значением и без парметра
Если вызывается без параметра - список сортируется по возростанию
Если передан именованный параметр reverse и значение True - сортируется по убыванию
post_ids = [859, 254, 387, 189, 543]
post_ids.sort() # [189, 254, 387, 543, 859]
post_ids.sort(reverse=True) # [859, 543, 387, 254, 189]
5.) insert - вставляет элемент в список
Принимает 2 параметра: 1-ый - индекс элемента в списке, перед которым нужно вставить значение, переданное как 2-ой параметр
arr = [1, 2, 3, 5, 8, 9, 11]
arr.insert(3, 4)
arr # [1, 2, 3, 4, 5, 8, 9, 11]
В список (list) можно конвертировать другие последовательности (строки, словари) при помощи встроенного метода list
greetings = 'Hello all'
list(greetings) # ['H', 'e', 'l', 'l', 'o', ' ', 'a', 'l', 'l']
При конвертации словаря в список, добавляются только ключи, а значения теряются
vals_dict = {a: 3, b: 5, c: 7, d: 8, e:9, f: 11}
list(vals_dict) # [a, b, c, d, e, f]
Для арифметических операций со списками используются методы min, max, sum
post_ids = [189, 254, 387, 543, 859]
max(post_ids) # 859
Соеденить несколько списков в один можно при помощи оператора +
Это возможно благодаря тому, что под капотом, оператор + заменяется на вызов магического метода __add__ класса list, который умеет соединять списки
post_ids = [189, 254, 387, 543, 859]
keys = [a, b, c, d, e, f]
post_ids + keys # [189, 254, 387, 543, 859, a, b, c, d, e, f]
Добавить список в конец другого списка можна так же используя метод extend()
first_list = [1, 2, 3, 4, 5]
second_list = [6, 7, 8, 9, 10, 11]
first_list.extend(second_list)
first_list # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Часть списка можно получить указав в квадратных скобках, разделив двоеточием, индекс нужного первого элемента и индекс, до которого, нужны элементы
post_ids = [189, 254, 387, 543, 859]
post_ids[1:3] # [254, 387]
post_ids[-3:5] # [387, 543, 859]
post_ids[1:-1] # [254, 387, 543]
Скопировать список, как отдельный обьект, можно 3 способами:
newarr = arr.copy()
newarr = list(arr)
newarr = arr[:]
Копирование путем присвоения 1 списка другому приводит к копированию ссылки в новую переменную, а не созданию нового, отдельного обьекта
newarr = arr
id(newarr) == id(arr) # True

Словарь - обьект класса dict, это не упорядоченная последовательность элементов, где каждый элемент состоит из пары: ключ, значение
Ключ отделяется от значения двоеточием, а элементы разделены запятыми
Ключ должен быть типа str, тоесть в кавычках
Ключи в словарях - уникальны и не могут повторятся
Если добавить пару ключ-значение, у которой ключ уже есть в словаре - в таком случае его текущее значение просто перезапишется на новое
Значение может быть любого типа: другой словарь, список, функция и тд
my_car = {
	'make': 'BMW',
	'model': 5,
	'fast': True
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'}
}
Порядок элементов в списке - не важен (в отличии от строк и списков)
my_car_again = {
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'},
	'make': 'BMW',
	'fast': True,
	'model': 5,
}
my_car == my_car_again # True - порядок ключей разный, но их названия, количество и значения - одинаковые
В Пайтон сравнить 2 разных обьекта можно при помощи оператора сравнения ==
not_my_car = {
	'make': 'BMW',
	'model': 5,
	'fast': False
	'specs: {'year': 2024, 'engine': 3.5l, 'fuel': 'petrol'}
}
my_car == not_my_car # False - значения у одного из ключей разные
Для доступа к значениям ключей используются квадратные скобки и нужный ключ внутри них. Ключ передается как строка
my_car['make'] # 'BMW'
Синтаксис с точечной записью не доступен для ключей списков в Пайтон, (доступен в JS), так как они не являются аттрибутами, а данный синтаксис работает только с ними
my_car.make # NameError
То, что ключи словаря не являются аттрибутами можно подтвердить при помощи метода dir
dir(my_car) # будут выведены аттрибуты, обычные и магические методы класса dict, а make, model, fast и specs - отсутствуют
Этот же синтаксис используется для:
изменения значений существующих ключей в словарях
my_car['model'] = 'X5'
добавления новых
my_car['price'] = 70000
и удаления ключей и, соответственно, их значений
Но для этого необходим оператор del
del my_car['fast']
Переменные можно использовать для:
1.) создания словарей
make = 'brand'
model = 'model'
cost = 'price'
my_car = {
    make: 'BMW',
    model: 'X5',
    cost: 90000
}
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 90000}
2.) добавления новых ключей в словарь
painted = 'color'
wheels = 'tires'
my_car[painted] = 'black'
my_car[wheels] = 21
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 90000, 'color': 'black', 'tires': 21}
3.) добавления новых значений
is_fast = True
year = 2024
my_car['fast'] = is_fast
my_car['produced'] = year
{'brand': 'BMW', 'model': 'X5', 'price': 90000, 'color': 'black', 'tires': 21, 'fast': True, 'produced': 2024}
4.) или изменения значений, если такой ключ уже есть в словаре
price = 85000
my_car['price'] = price
print(my_car) # {'brand': 'BMW', 'model': 'X5', 'price': 85000, 'color': 'black', 'tires': 21, 'fast': True, 'produced': 2024}
Количество элементов в словаре можно получить при помощи встроенной функции len
len(my_car) # 7
Если попытаться использовать ключ, которого нет в словаре - будет выброшена ошибка ключа и выполнение кода остановится
my_car['engine_volume'] # KeyError
Если вы не уверены, что ключ есть в словаре, можно использовать метод словарей get.
Если ключа нет в словаре - он вернет None, если есть - его значение. Тоесть в любом случае ошибки не будет и выполнение кода не будет остановлено
my_car.get('engine_volume') # None
В случае, когда ключ отсутсвует, значение по умолчанию None можно заменить на любое другое, указав его после названия ключа и запятой, в вызове метода get
my_car.get('engine_volume', 'Absent) # 'Absent'
Создавать словари можно при помощи встроенной функции-конструктора dict
Если она вызывается без аргументов - будет создан пустой словарь
empty_dict = dict() # {}
В качестве аргументов можно передавать пары ключ-значение, через запятую, в таком формате
new_dict = dict(one=1, two='two', three=True)
new_dict # {'one': 1, 'two': 'two', 'three': True}
Как итерируемый список, с таким ситаксисом
new_dict2 = dict([('first', 'one'), ('second', 'two'), ('third', 3)])
new_dict2 # {'first': 'one', 'second': 'two', 'third': 3}
my_dict = {'first': 'one', 'second': 'two', 'third': 3}

Методы словарей:
1.) my_dict.keys() - возвращает обьект класса dict_keys, который содержит список из ключей словаря my_dict
# dict_keys(['first', 'second', 'third'])
2.) my_dict.values() - возвращает обьект класса dict_values, к	оторый содержит кортеж из значений словаря my_dict
# dict_values(['one', 'two', 3])
3.) my_dict.items() - возвращает обьект класса dict_items, который содержит список кортежей, каждый из которых содержит пару ключ и значение словаря my_dict
# dict_items([('second', 'two'), ('first', 'one'), ('third', 3)])
Для создания нового словаря на основе другого (копирования) используеться метод copy
new_dict = my_dict.copy()
Созданный словарь в результате вызова метода copy является новым, отдельным обьектом
id(my_dict) == id(new_dict) # False
Создать новый словарь можно на основе последовательности, в которой есть 2 значения, они будут интерпретированы как ключ и значение
1.) Списка списков
dict1 = dict([['first', 1], ['second', 'two'], ['third', True]])
2.) Списка кортежей
dict2 = dict([('first', 1), ('second', 'two'), ('third', True)])
3.) Кортежа кортежей
dict3 = dict((('first', 1), ('second', 'two'), ('third', True)))
4.) Списка в котором есть списки и кортежи
dict4 = dict([('first', 1), ['second', 'two'], ['third', True]])
5.) Кортежа в котором есть списки и кортежи
dict5 = dict((['first', 1], ('second', 'two'), ('third', True)))
Все 5 списков - {'first': 1, 'second': 'two', 'third': True}
Для создания словаря из 1 пары ключ, значение, с помощью кортежа кортежей, нужно после 1-го элемента поставить запятую
tuple1 = (('first', 1))
dict6 = dict(tuple1) # Error
tuple1 = (('first', 1),)
dict7 = dict(tuple1) # {'first': 1}

Кортеж (tuple) - обьект класса tuple - это упорядоченная последовательность элементов
Порядок элементов в кортеже важен
tuple1 = (1, 2, 3, 5)
tuple2 = (3, 1, 2, 5)
tuple1 == tuple2 # False - элементы одинаковые, но их последовательность - разная
Кортеж является не изменяемым типом данных, тоесть в него нельзя добавить или удалить новые элементы
tuple[4] = 7 # TypeError
del tuple[1] # TypeError
Изменять элементы кортежа можно только в том случае, если их тип данных - изменяемый
tuple1[3] = 'Three' # TypeError - тип данных int - не изменяемый, поэтому выпадает ошибка
tuple3 = ([1, 2, 3], [5, 7, 8], [9, 11, 18])
tuple3[0][2] = 'Three'
tuple3 # ([1, 2, 'Three'], [5, 7, 8], [9, 11, 18]) - list, как и dict, set - изменяемые типы данных, поэтому их в Кортеже можно изменить и ошибки не будет
Функция len доступна и для Кортежей и возвращает их длину
Обьеденять кортежи можно при помощи оператора +
В такой способ соединять кортежи и списки нельзя
У Кортежа 2 метода:
1.) count - возвращает количество раз сколько переданный аргумент встречается в Кортеже
2.) index - возвращает индекс переданного аргумента
Может принимать 1 или 2 аргумента, где 1-ый - элемент индекс которого ищем, 2-ой - индекс с которого начинать поиск этого элемента
tuple1 = (1, 2, 3, 4, 5, 3, 8, 9, 11)
tuple1.index(3, 4) # 5 - ищем индекс элемента 3 начиная с индекса 4
tuple1[5] # 3
Если аргумент встречается в Кортеже несколько раз - будет возвращен индекс первого такого элемента
Если такого аргумента нет в Кортеже - будет выброшена ошибка
Метода get Кортежей нет
Последовательность элементов можно конвертировать в Кортеж используя встроенную функцию tuple()
list1 = [1, 2, 3]
tuple1 = tuple(list1)
type(tuple1) # tuple
Если Кортеж нужно изменить, его можно конвертировать в список, при помощи функции list, изменить, а затем конвертировать обратно в Кортеж используя функцию tuple
При конвертации словаря в Кортеж добавляются только ключи, а значения теряются
vals_dict = {a: 3, b: 5, c: 7, d: 8, e:9, f: 11}
tuple(vals_dict) # (a, b, c, d, e, f)

Набор (set) - неупорядоченная последовательность элементов, экземпляр класса set
Порядок элементов в Наборе не имеет значения и поэтому у элементов нет индексов
Это потому что у класса Set нет магического метода __getItem__
posts = {'Hi', True, 3, 5.5}
posts[0] # Error
Элементы в Наборе - уникальны. При добавлении элемента, который уже есть в набое - он не будет добавлен
Если дубликаты добавлены в Набор во время создания, далее они будут удалены
name = {'Alan', 'Audren', 'Alan', 'Roman', 'Andrey', 'Kirilo', 'Roman'}
print(name) # {'Alan', 'Audren', 'Roman', 'Andrey', 'Kirilo'}
Набор - изменяемый тип данных
Набор не может содержать изменяемые типы данных: list, dict, set, только не изменяемые
posts = {'Hi', True, 3, 5.5}
type(posts) # class 'set'
У Набора есть длина и определить ее можно при помощи встроенной фукнции len
len(posts) # 4
Каждому элементу в наборе, под капотом, генерируется хэш.
При добавлении нового элемента или обьединении нескольких наборов, все хэши сравниваются и если есть 2 и более одинаковых - то их соответствующие элементы удаляются из Набора
new_set1 = {1, True, 10.5, 'Hi', (1, 2, 3)}
new_set2 = {3, (5, 9, 11),'Hi'}
Методы Наборов:
1.) add - добавляет новый элемент в Набор
2.) union - обьеденяет 2 Набора и удаляет все дубликаты
Так же вместо union можно использовать оператор или |
new_set1.union(new_set2)
new_set1 | new_set2
3.) intersection - возвращает Набор, который содержит только те элементы, которые присутствуют в обоих Наборах
Так же можно использовать оператор &
Это симметричный/зеркальный метод, поэтому его можно применять как к Набору 1, так и к Набору 2 и результат будет одинаковый
new_set1.intersection(new_set2)
new_set1 & new_set2
В качестве аргумента метод принимает любое итерируемое значение: строку, список, словарь
При передаче словаря, сравнение будет проводиться с его ключами
4.) issubset - проверяет включен ли 1-ый Набор во 2-ой (являеться ли 1-ый Набор подмножеством 2-го)
Все элементы подмножества должны быть в супермножестве. Если нет хотя бы 1 - метод вернет False
new_set1 = {3, True, 10.5, 'Hi', (1, 2, 3)}
new_set2 = {1, True,'Hi'}
new_set2.issubset(new_set1) # False - значения 1 нет в new_set1
new_set2 = {3, True,'Hi'}
new_set2.issubset(new_set1) # True
5.) issuperset - проверяет включает ли 1-ый Набор в себя 2-ой (являеться ли 1-ый Набор супермножеством 2-го)
6.) difference - возвращает разницу двух множеств, элементы которые не повторяются, уникальны в 2-х множествах
Вместо этого метода, для Наборов, можно использовать оператор минус -
7.) discard - удаляет переданное значение из Набора
Если переданного элемента нет в Наборе - ошибки не будет
8.) remove - удаляет переданное значение из Набора
Работает как и discard, однако, если аргумента нет в Наборе - будет выброшена ошибка
9.) symmetric_difference (симетричная разница) - возвращает уникальные элементы двух Наборов
Элементы которые есть в Наборе 1, но нет в Наборе 2 и элементы которые есть в Наборе 2 и отсуствуют в первом Наборе
set1 = {'a', 'b', 'c', 'd'}
set2 = {'a', 'b', 'c', 'e'}
set1.symmetric_difference(set2) # {'e', 'd'} - 'е' есть в set2, но нет в set1, 'd' есть в set1, но нет в set2
Так же это можно сделать обьеденив 2 Набора в один, а затем отняв от него пересекающиеся элементы (которые есть в 2-х Наборах)
(set1 | set2) - (set1 & set2) # {'d', 'e'}
(set1.union(set2)) - (set1.intersection(set2)) # {'d', 'e'}

Диапазон (range) - упорядоченная неизменяемая последовательность элементов, обьект класса range
Создать диапазон используя только какие либо скобки нельзя, для этого нужно использовать одноименную фукнцию конструктор - range
В качестве аргумента эта функция принимает целое число
Аргументов может быть 1, 2 или 3
Первый аргумент указывает с какого числа начинать итерирование/отсчет
Второй - верхняя не досягаемая граница, число до которого будет произведен отсчет, не включая его
Третий - шаг, число на которое будет увеличиваться каждый элемент диапазона начиная с 1-го, при каждой итерации
Если шаг не указан, по умолчанию, он равен 1
my_range1 = range(3) - итерирование с 0 до 2, потому что верхняя граница не включается, последний элемент такого Диапазона - 2 # 0, 1, 2
my_range2 = range(10, 20) - итерирование с 10 до 19
my_range3 = range(10, 20, 2) - с 10 до 19, увеличивая каждый элемент на 3 # 12, 14, 16, 18
Элемента 20 в таком Диапазоне не будет, так как это уже верхняя граница, а она не включается, инкрементация элементов идет до нее
Диапазон можно конвертировать в список, при помощи встроенной функции list
В таком случае будет произведена итерация, в соответствии с переданными аргументами, и все полученный элементы будут добавлены в список
list(my_range3) # [10, 12, 14, 16, 18]
Обьект класса range часто используют в цикле for
count = range(3, 10)
for i in count:
    print(i)
Для цикла for, шаг с созданием обьекта range можно пропустить и сделать это прямо в цикле
for i in rage(3, 10)
    print(i) # 3, 4, 5, 6, 7, 8, 9
У Диапазонов 2 метода:
count - возвращает 1 если переданный аргумент есть в Диапазоне
index - возвращает индекс переданного аргумента, если он есть в Диапазоне и выбрасывает ошибку если его нет
Что бы не получить ошибку при использовании метода index, перед ним лучше проверить наличие аргумента в Диапазоне при помощи метода count
my_range = range(10, 30, 4)
val = 26
check = my_range.count(val)
# print(my_range.index(val)) ValueError: 19 is not in range
if check:
    print(my_range.index(val))
else:
    print('The element is not in range')

Типы данных в Пайтон:
1.) int
2.) float
3.) str - упорядоченный тип данных
4.) None
5.) bool
6.) dict - изменяемый тип данных
7.) list - изменяемый, упорядоченный
8.) tuple - упорядоченный
9.) set - изменяемый
10.) range - упорядоченный

zip - встроенная функция, которая обьеденяет несколько последовательностей в 1. При этом последовательности могут быть разных типов (list, tuple, str)
В результате использования этой функции будет получет обьект zip, который затем можно конвертировать в другой тип/последовательность (list, tuple, dict)
Длина последовательностей-аргументов может быть разной
Длина результирующей последовательности (обьекта zip) будет равна длине самой короткой последовательности из переданных аргументов
arr = ['BMW', 'Audi', 'Mercedes', 'VW']
kortej = (30, 20, 35) - длина 3
set1 = {'Hi', 'Hello', 'Hola', 'Wazzap'}
zipped1 = zip(arr, kortej, set1)
print(zipped1) # <zip object at 0x000001BD8A84FB00> - обьект zip и его место в памяти
print(list(zipped_list)) # [('BMW', 30, 'Hola'), ('Audi', 20, 'Hello'), ('Mercedes', 35, 'Hi')] - список кортежей длиной 3
Для конвертации zip обьекта в словарь, он должен быть получен на основании только 2-х аргументов
Первый аргумент будет определен как ключи, а второй - значения
zipped2 = zip(arr, kortej)
print(dict(zipped_dict)) # {'BMW': 30, 'Audi': 20, 'Mercedes': 35}
print(dict(zipped1)) # ValueError: dictionary update sequence element #0 has length 3; 2 is required - элементы zip-обьект состоят из 3-х, а не 2-х значений
Конвертировать обьект zip в другой тип можно только 1 раз. Для последующих конвертаций можно использовать результат 1-ой конвертации
zipped3 = zip(arr, set1)
print(dict(zipped3)) # {'BMW': 'Hola', 'Audi': 'Hello', 'Mercedes': 'Wazzap', 'VW': 'Hi'} - первая конвертация успешна
print(list(zipped3)) # [] - можно использовать результат первой конвертации присвоив его переменной

Все переменные в Пайтон хранят ссылку на обьект в памяти
При создании новой переменной значение которой неизменяемого типа, Пайтон проверяет память и если находит обьект с таким же значение, то не создает новый обьект, а присваивает переменной ссылку на уже существующий
val1 = 10
val2 = 10
val3 = 10
print(id(val1)) # 140718936898264
print(id(val2)) # 140718936898264
print(id(val3)) # 140718936898264
print(id(10)) # 140718936898264 - указывает на ранее созданный обьект, так как у них идентичные значения
У val1, val2 и val3 - одинаковые значения не изменяемого типа, поэтому все они ссылаються на 1 и тот же обьект в памяти, а не на разные
Но, при изменении обьекта неизменяемого типа - создаеться новый обьект, а старый остаеться без изменений
val1+=5
print(id(val1)) # 140718936898424 - место в памяти именилось, так как это новый обьект
print(id(val3)) # 140718936898264 - место в памяти не изменилоь, это тот же обьект что и был
val4 = 15
print(id(val4)) # 140718936898424 - val1 и val4 ссылаються на 1 обьект, так как их значения одинаковые

При создании переменных значения которых изменяемого типа - каждый раз создаеться новый обьект в памяти, даже если значения идентичны
arr1 = [1, 2, 3]
arr2 = [1, 2, 3]
print(id(arr1)) # 2801734046080
print(id(arr2)) # 2801734047936 - значения одинаковые, но тип данных - изменяемый, поэтому создаються 2 разных обьекта
Таким образом изменения переменной arr1 не будут отражаться на arr2
arr1.append(4)
arr1 # [1, 2, 3, 4]
arr2 # [1, 2, 3]
При копировании обьектов изменяемых типов используя оператор равно - копируеться ссылка на обьект и обе переменные указывают на 1 обьект
arr3 = arr1
print(id(arr3)) # 2801734046080 - тот же обьект что и у переменной arr1
При таком копировании изменения переменной arr1 будут применены и для arr3
arr1.append(5)
arr1 # [1, 2, 3, 4, 5]
arr3 # [1, 2, 3, 4, 5]
Создать новый, отдельный обьект, на основании уже существующего можно при помощи встроенной функции copy
arr4 = arr3.copy()
print(id(arr3)) # 2801734046080
print(id(arr4)) # 2099065305344 - 2 разных обьекта
Но метод copy не создает новые обьекты для вложенных обьектов, а копирует их ссылку
obj = {	'author': 'Bogdan',
       	'instructor': True,
       	'reviews': [] }
new_obj = obj.copy()
obj['reviews'].append('Python')
print(obj['reviews']) # ['Python']
print(new_obj['reviews']) # ['Python'] - изменения свойста reviews обьекта obj произошли в таком же свойсте в обьекте new_obj, хотя они отдельные, независимые обекты
Это из-за того что метод copy не создает новые обьекты для вложенных свойст, а просто копирует их ссылку. Создает копию верхнего, 1-го уровня, поверхностную (shallow)
Для создания полность новой копии изменяемого обьекта можно использовать метод deepcopy модуля copy, который нужно импортировать в файл программы
from copy import deepcopy
full_new_obj = deepcopy(obj)
obj['reviews'].append('Typescript')
print(obj['reviews']) # ['Python', 'Typescript'] - добавляем к изменяемому обьекту review в обьекте obj новый элемент
print(new_obj['reviews']) # ['Python'] - изменения не применились к вложенному изменяемому обьекту reviews (list) в обьекте full_new_obj
Новый обьект созданный при помощи метода deepcopy являеться отдельным новым обьектом и все его вложенные обьекты так же

Функция - это блок кода который можно вызывать многократно
Обьявление функции в Пайтон начинается с ключевого слова def
Далее следует имя функции (присвоение функции переменной), круглые скобки с параметрами (они опциональны) и двоеточие
def my_func(a, b):
Тело функции отделяеться отступом
Функция, как и все в Пайтон, это обьект и каждая функция являеться экземплятор класса function
Параметры - это переменные доступные только внутри функции, а аргументы - это значения и они могут меняться в каждом вызове функции
Значение параметрам функции передаеться при ее вызове с аргументами. Параметры инициализируються значениями аргументов. Значения аргументов присваиваються параметрам
Ключевое слово pass (заглушка) используеться тогда, когда в блоке кода еще нет строк кода (мы их еще не написали). В таком случает без использования слова pass будет выброшена ошибка
Все переменные в Пайтон (изменяемые и неизменяемые) - это обьекты которые хранят ссылки на соответствующие обьекты в памяти
При вызове функции с аргументами, в качестве аргументов передаються ссылки на эти обьекты в памяти, а не значения
Если аргументы в неизменяемые типы/обьекты - то при их изменении в теле функции создаються новые обьекты (потому что это неизменяемый тип данных)
В таком случае изменить внешнюю переменную невозможно
val1 = 10
print(id(val1)) # 140718564195032 *
def check (a):
	print(id(a)) # 140718564195032 * - все еще обьект val1
	a += 1
	print(id(a)) # 140718564195064 - создался новый обьект
	return a

res = check(val1)
print(res) # 11 - функция вернула измененное значение
print(val1) # 10 - но значение переданного аргумента осталось без изменений, так как это неизменяемый тип данных
print(id(res)) # 140718564195064 - новый обьект, созданный в ходе изменения переданного аргемента
print(id(val1)) # 140718564195032 * - обьект аргумента не изменился

Но, при передаче изменяемых обьектов - изменяеться обьект, ссылка на который передана
Таким образом после вызова функции изменяется внешний обьект, который был обьявлен до функции
def check1(arr):
	print(id(arr)) # 2420286148992 - обьект переданный как аргумент
	arr.append(4)
	print(id(arr)) # 2420286148992 - тот же обьект, переданный как аргумент. Он не изменился, не создался новый, так как это изменяемый тип данных, он может изменяться
	return arr

ar = [1, 2, 3] - внешний обьект
print(id(ar)) # 2420286148992 - тот же обьект, переданный как аргумент
res = check1(ar)
print(res) # [1, 2, 3, 4] - результат вызова функции
print(id(res)) # 2420286148992 - тот же обьект
print(arr) # [1, 2, 3, 4] - значение внешнего обьект изменилось после/в вызова функции
print(id(arr)) # 2420286148992 - обьект не изменился, а его значение изменилось
Что бы измежать изменения внешних обьектов, если они изменяемых типов данных (dict, list, set), внутри функции можно их копировать в новую переменную при помощи функции copy или deepcopy, в зависимости от того, есть ли у обьекта вложенные изменяемые обьекты
Или копировать обьект прямо в вызове функции
check1(ar.copy())
check1(deepcopy(ar))

В вызове функции количество аргументов должно совпадать с количеством параметров этой функции, заданых при ее обьявлении
Что бы функцию можно было вызывать с неопределенным количеством аргументов, при ее обьявлении, возле параметра нужно указать оператор звездочки *
def my_fn(*args):
В таком случае все аргументы будут собраны в Кортеж и с ним можно будет работать
my_fn(1, 2, 3) - не вызовет ошибку, внутри функции будет создан Кортеж (1, 2, 3)
my_fn(1) - Кортеж (1)
my_fn(1, 2, 3, 5, 8, 9, 11) - (1, 2, 3, 5, 8, 9, 11)
Аргументы бывают позиционные и именованные
Позиционными называються аргументы порядок (позиция) которых, при вызове функции, важен. Если изменить их порядок - результат вызова функции измениться
def show_str(a, b):
    print(f"{a} has {b} posts")
show_str('Bogdan', 25) # Bogdan has 25 posts - ожидаемый результат
show_str(25, 'Bogdan') # 25 has 25 Bogdan - из-за неправильного порядка аргументов результат не правильный
Именованные аргументы указываються при вызове функции вместе с соответствующими названиями параметров этой функции и символом равно (=)
Порядок именованных аргументов (аргументов с ключевыми словами) не важен, так как переданные значения будут присвоенны указанным параметрам
show_str(a='Bogdan', b=25) # Bogdan has 25 posts
show_str(b=25, a='Bogdan') # Bogdan has 25 posts - 25 было присвоено параметру b, а строка 'Bogdan' параметру a
Так же позиционные и аргументы с ключевыми словами можно использовать вместе
show_str('Bogdan', b=25) # Bogdan has 25 posts
Но важно не присвоить 2 аргумента одному параметру
show_str('Bogdan', a=25) # TypeError: show_str() got multiple values for argument 'a' - параметру a присваиваеться 2 значения/аргумента
И что бы позиционный аргумент был указан до именованного, а не после
show_str('Bogdan', b=25)
show_str(a='Bogdan', 25) # SyntaxError: positional argument follows keyword argument
Что бы вызывать функцию с неопределенным количеством именованных аргументов их нужно обьеденить, в функции, в словарь при помощи оператора 2 звездочки (**)
def my_func(**args):
    print(args)
    print(type(args)
    print(f"The value of the first key is {args['one']}, "
f"the value of the second key is {args['two']}, "
f"and the value of the third key is {args['three']}") - в таком случае Пайтон произведет конкатенацию строк
my_func(two=2, one='first', three=True)
# {'two': 2, 'one': 'first', 'three': True} - первый ключ two потому что этот аргумент с ключевым словом указан первым в вызове функции
# <class 'dict'>
# The value of the first key is 1, the value of the second key is two, and the value of the third key is True
При использовании оператора 2 звездочки, можно применять только аргументы с ключевыми словами, позиционные приведут к ошибке (для них нет ключей ?)
Значение параметров функции по умолчанию задаеться при обьявлении функции при помощи знака равно = и необходимого значения
Параметр, со значением по умолчанию, делает соответствующий аргумент, при вызове функции, необязательным. Тоесть он может быть, а может и отсутствовать
Если такой аргумент указан, будет использовано его значение для инициализации соответствующего параметра со значением по умолчанию
Если такой аргумент отсутсвует, то для инициализации соответствующего параметра будет использовано значение по умолчанию, указаное при обьявлении функции
def sum(a, b=3)
    return a+b

sum(5, 4) # 9
sum(5) # 8
Так же, в качестве значения по умолчанию, может использоваться результат вызова другой функции
def multi(c, d=sum(9))
    return c*d

multi(3, 3) # 9
multi(3) # 36 - d = (9 + 3) * c = 12

Колбэк функция - это функция, которая вызываеться внутри другой функции и передаеться в нее как аргумент
Передаеться только имя колбэк функции, без круглых скобок (иначе она будет вызвана), как параметр и аргумент
def show_value(value):
    print('The value is', value)

def main_fn(num, callback_fn): - колбэк функция передана без круглых скобок
    callback_fn(num)

main_fn(9, show_value) # 'The value is 9 - колбэк функция как аргумент так же без круглых скобок

docstring - используеться для описания/документирования функций, классов, модулей
Описание указываеться внутри 3 пар одинарных или двойных кавычек
Описывать можно как саму функцию так и ее паргументы
Описание будет выводиться при навередении курсора на название функции или при установлении курсора в круглые скобки
def print_number_info(num):
    """
    Calculates is the number even or odd and then prints the result - описание функции

    Args: - описание аргумента
    num (int): Number to be evaluated
    """
    if num % 2 == 0:
        print('The number is even")
    else:
        print("The number is odd")
Автоматически создавать шаблон для описания можно при помощи расширения autoDocstring

Область видимости определяет границы действия, доступности переменной
Области видимости в Пайтон бывают всего 2 типов: Глобальная и область видимости Функции (Локальная)
Области видимости блока кода, в Пайтон, нет
Если переменная создаеться в логической конструкции if, то она будет создана в области видимости, в которой находится этот if - в Функции или Глобальной
Цепочка областей видимости:
a = 3
def outer_fn():
    def inner_fn():
        print(a)

outer_fn()
Сначала поиск переменной a будет произведен по области видимости функции inner_fn
Переменная там не будет найдена, и поэтому, поиск начнеться во внешней, для функции inner_fn, области видимости - ОВФ outer_fn
Там ее так же нет, поэтому поиск будет совершен по внешней, для этой функции области видимости.
А функция outer_fn обьявлена в Глобальной области видимости, где так же обьявлена переменная а
Эта переменная будет найдена и использована в функции inner_fn
Область видимости функции и переменные обьявленные/созданные в ней, создаються каждый раз при вызове функции (5 вызовов - 5 раз создаеться ОВФ)
Параметры функции являються переменными области видимости функции
При вызове функции создаються все переменные обьявленные в ее области видимости
После того, как функция завершит свою работу/дойдет до своей последней строки кода, все переменные, в ее области видимости, удаляються/область видимости очищается
Но, если функция возвращает переменную, то такая переменная может существовать и после завершения работы функции
В Пайтон нельзя создать переменную без значения. Переменную нужно сразу после обьявления инициализировать значением

При помощи ключевого слова global можно создавать/обьявлять или использовать переменные из Глобальной области видимости в Области видимости функции
Переменные с ключевым словом global не создаются в Области видимости функции, они будут создаватся в ГОВ
Сначала идет строка с ключевым словом global и названием переменной, а на следующей - действия с этой переменной. Обьявление и инициализация на одной строке приведут к ошибке
Глобальная переменная создается/изменяется в момент присвоения значения, а не на строке с ключевым словом global
def my_fn():
    # global a = 9 - SyntaxError: invalid syntax
    global a
    a = 9 - создается переменная а

print(a) - ошибка, переменная a is not defined
Что бы переменная a была создана в Глобальной области видимости используя функцию my_fn - эту функцию нужно вызвать, она выполнит свой код - создаст переменную а в Глобальной области видимости
А затем эту переменную уже можно будет использовать в ГОВ
my_fn() - выполняется тело функции - создается переменная а в ГОВ
print(a) # 9
Если одноименная переменная уже была создана в ГОВ ранее, то такой код перезапишет ее значение на новое, присвоенное в функции
a = 3
print(a) # 3
my_fn()
print(a) # 9
Проверить, что в функции, переменная с ключевым словом global является переменной из ГОВ можно сравнив их идентификаторы
a = 3
def check_id():
    global a
    print(id(a))
    a = 9
    print(id(a))

print(id(a)) # 140712746957304 - переменная из Глобальной области видимости
check_id()
# 140712746957304 - таже переменная из ГОВ внутри функции check_id
# 140712746957496 - новая переменная а со значением 9, созданная в Области видимости функции (int - неизменяемый тип данных, при изменении - создается новая переменная, а не изменяется старая)
print(id(a)) # 140712746957304 - переменная а из ГОВ осталась без изменений

Встроенный метод dir - возвращает список переменных доступных в текущей области видимости
Вызов dir() в Глобальной области видимости вернет массив имен глобальных переменных
Такой же вызов внутри функции - вернет массив имен переменных внутри Области видимости этой функции
dir() # ['a', 'my_fn']
Если в функции есть переменные с ключевым словом global, то вызов dir, в этой функции, их не покажет
Так как они обьявлены или создаются в Глобальной области видимости, а dir вызывается внутри функции
