WebDriver - API для управления поведением браузера
Каждый браузер поддерживается определенной реализацией Драйвера (Chromedriver)
Driver - компонент/сущность отвечающая за делегирование полномочий браузеру
Драйвер обеспечивает обмен данными между Selenium и браузером
Selenium - фреймворк, связывающий все эти части вместе при помощи пользовательского интерфейса - кода на Python, Java и других языках программирования
Позволяет использовать все части браузера, обеспечивая кросс-браузерную и кросс-платформенную автоматизацию действий в браузере

1. Selenium + WebDriver > 2. Driver (Chromedriver) > 3. Browser > 4. Driver > 5. Selenium + Webdriver
1. Описываются действия для управления браузером при помощи языка программирования (открой ссылку, нажми на кнопку и тд)
2. Этот код передается Драйверу
3. Драйвер передает все эти действия Браузеру
Браузер выполняет описанные действия и возвращает результат обратно Драйверу
4. Драйвер получает результат выполненых действий и передает их в Selenium
5. В Селениум выполняются нужные действия

Создаем новый проект
Создает виртуальное окружение: python3 -m venv venv
В результате, в корневой директории проекта появится папка venv
Затем нужно активировать виртуальное окружение: venv/Scripts/activate.ps1 (on Windows), source venv/bin/activate (for MacOS)
После этого, в терминале, в начале строки, появится (venv), это будет означать, что окружение активировано
Далее нужно установить Selenium и WebDriver manager: pip3 install selenium webdriver-manager
Webdriver manager позволяет автоматически скачивать и устанавливать самую новую версию Драйвера для того или иного браузера без скачивания и замены бинарных файлов в проектах
После этого можно создать новый Пайтон файл для написания кода
В него нужно импортировать Вебдрайвер
from selenium import webdriver
Потом из webdriver-manager импортируем необходимый драйвер, в зависимости от нужного браузера (Chrome - chromedriver)
from webdriver_manager.chrome import ChromeDriverManager
Так же нужно импортировать класс Service, который появился в Selenium 4
Он отвечает за установку, открытие и закрытие Драйвера
from selenium.webdriver.chrome.service import Service

В Selenium 4 инициализация Драйвера происходит через обьект класса Service
service = Service(executable_path=ChromeDriverManager().install()) # Обьект класса Service
executable_path - путь к нашему Драйверу, а так как у нас используются не .bin файлы, а DriverManager, указывается путь к его методу install
Это метод установит Драйвер и передаст путь к нему в Service
Затем инициализируется сам Драйвер
driver = webdriver.Chrome(service=service)
Теперь можно запустить программу - будет открыт и закрыт Хром браузер
Закрывается он автоматически благодаря Service, который отвечает за его закрытие, driver.quit() теперь не нужно указывать

Если нужна одна из прошлых версий браузера, ее можно указать при создании обьекта service в ChromeDriverManager
service = Service(executable_path=ChromeDiverManager(version="114.0.5735.90").install())

Драйвер Firefox создается по аналогичной схеме
from selenium import webdriver
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.firefox.service import Service

service = Service(executable_path=GeckoDriverManager().install())
driver = webdriver.Firefox(serivce=service)

Управление кнопками браузера
driver.forward() - кнопка браузера Вперед
driver.back() - кнопка браузера Назад
driver.refresh() - кнопка браузера Перезагрузить страницу

Получение данных страницы
driver.current_url - текущий урл страницы
driver.title - заголовок текущей страницы
driver.page_source - исходный код страницы

Валидировать данные можно при помощи условия assert
После запятой можно указать сообщение, которое будет выведено в случает неудачи
assert url == 'https://www.motorsport.com/', 'Invalid URL'


find.element() - метод для поиска элементов на странице
В качестве аргументов он принимает:
1. метод поиска: по xpath, class name, css селектору, id
2. значение локатора, по которому находится веб-элелемент
driver.find_element('xpath', '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')
Методы поиска: "id", "xpath", "name", "class name", "css selector"

Так же, искать элементы можно при помощи класса By импортируемого из selenium
Но для этого в каждом файле нужно его импортировать, что не очень удобно
from selenium.webdriver.common.by import By
driver.find_element(By.XPATH, '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')

С точки зрения веб-приложения, веб элемент - это любой элемент на странице
В Селениум, веб-элемент - это тип данных, обьект класса WebElement
driver.get('https://rozetka.com.ua/ua/')
button = driver.find_element('xpath', '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')
print(type(button)) # <class 'selenium.webdriver.remote.webelement.WebElement'>

find_elements() - возвращает список элементов у которых одинаковое значение переданного локатора
Так как это список, обращаться к его элементам можно по индексу
Например, если несколько элементов на странице имеют одинаковый class name или id, все их можно получить
titles_list = driver.find_elements('class name', 'title') # [<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.153")>,
<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.154")>, ...,
<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.176")>]
titles_list[1] # <selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.154")>

XPath (XML path language) - язык запросов к элементам XML, HTML документов
В XPath используются символы /, //, а так же теги
XPath всегда начинается с / или //
/ - означает прямого потомка, аналогичен символу > в CSS-селекторах
html, body, div, span, h1 - в такой структуре span - прямой потомок div, div/span
// - означает потомка любого уровня вложенности
// используется для глобального поиска от корня документа или внутри других тегов
html, body, div, span, h1 - в такой структуре путь к span можно указать как: //span (от корня документа) или html//span (глобальный поиск внутри html тега)
//div[5] - div который в структуре находится на 5-ом уровне вложенности
(//div)[5] ???
При использовании глобального поиска, в случае изменения меторасположения веб-элемента в структуре дерева, в большинтсве случаев XPath не сломается

К тегам относятся все HTML теги: head, body, div, span, input, h3 и т.д.
Теги могут иметь аттрибуты, один или несколько
К ним относятся: class, id, type, placeholder
Аттрибуты можно использовать для формирования XPath
В XPath аттрибуты указываются в квадратных скобках после тегов
Перед аттрибутом ставится символ @, после названия аттрибута символ = и значение этого аттрибута в кавычках
button[@class='submit'], button - HTML тег, у которого есть аттрибут class, значение которого submit
Исключением является тег text, он указывается без символа @, но с круглыми скобками () - //span[text()='Супер! Дякую']
Например, если в дереве несколько полей ввода, можно указать аттрибут нужного поля, который уникален для него
//input[@type='email'] - у тега input есть аттрибут type, значение которого email и такого значения у аттрибута type нет у других тегов input

Аттрибуты могут имееть значения, которые содержат несколько названий, например class='style-scope ytd-app', содержит style-scope и ytd-app
Что бы не указывать их все, можно воспользоваться методом contains() и передать ему одно из значений аттрибута
contains() указывается после тега, в квадртаных скобках, как аттрибут, но без символа @ и принимает 2 аргумента: название аттрибута с символом @ и его значение в скобках
//div[contains(@class, 'ytd-app')]

Если нужно найти тег, у которого несколько аттрибутов - они перечисляются с помощью оператора and
Тег a имеет аттрибуты class='ms-item ms-item-hor-d ms-item-hor-t ms-item-hor-m', data-entity-id='10700419', data-entity-type='article'
//a[@data-entity-id='10700419' and @data-entity-type='article']

send_keys() - заполняет поле ввода значением, которое принимает в качестве аргумента
input_field.send_keys('test_email@gmail.com') - введет в поле ввода текст test_email@gmail.com
clear() - очищает поле ввода

get_attribute() - возвращает значение аттрибута веб-элемента к которому применяется
В качестве аргумента принимает название нужного аттрибута:
value - значение/текст в поле ввода
maxlength - максимально допустимая длина текста в поле ввода
input_field.get_attribute("value") # test_email@gmail.com

webdriver.ChromeOptions() - опции браузера (в данном примере Chrome)
К опциям браузера относятся:
incognito - открытие в режиме инкогнито
window-size=1280,780 - с заданными размерами окна
headless - запуск браузера без графического интерфейса (в фоне, что требует меньшего количества ресурсов)
ignore-certificate-errors - игнорирование любых ошибок связанных с SSL-сертификатами (отсутствует, истек и т.д.)
disable_cache - отключение записи кеша
add_argument() - добавить опцию, что бы она выполнялась при запуске тестов
В качестве аргументов передаются названия опций с 2 тире в начале
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument("--incognito")
Для того, что бы опции выполнялись - их нужно передать в Драйвер, при его инициализации, в качестве аргумента
Поэтому создание и добавление опций должно быть указано до строки с созданием Драйвера

Так же можно напрямую импортировать Опции из webdriver
from selenium.webdriver.chrome.options import Options
options = Options()

driver.set_window_size(320, 660) - задать размеры окна браузера
Минус этого варианта в том, что он выполняется уже после инициализации драйвера
Поэтому браузер сначала открывается со стандартными размерами окна, а затем изменяех их на указанные в этом методе

Стратегия загрузки страницы - описывает момент когда Селениум начинает выполнять действия на странице
Возможные варианты: когда на странице загрузились все ресурсы, или когда загрузился только ДОМ, ожидание/отсуствие ожидания загрузки всех картинок
В Селениум есть 3 стратегии загрузки страницы:
normal (используется по умолчанию) - ожидает загрузки всех ресурсов на странице
eager - ожидает загрузки только ДОМ дерева
none - ничего не ожидает ?
Стратегия загрузки страницы задана в Опциях браузера
chrome_options.page_load_strategy = 'eager'

options - стандартные настройки браузера
prefs - специфические настройки: пути, директория для скачивания файлов и другие
Для изменения специфических настроек - их и их значения нужно указать в словаре prefs
А затем добавить словарь prefs со всеми нужными специфическими настройками в options при помощи метода add_experimental_option()
Слово "prefs" в add_experimental_option методе является зарезирвированным
download.default_directory - специфическая настройка браузера, указывает на папку куда нужно загружать файлы
Для указания пути к папке/файлу можно использовать модуль os, его метод getcws() указывает на текущую директорию
prefs = {
    "download.default_directory": f"{os.getcwd()}"
    # "download.default_directory": f"{os.getcwd()}/folder_for_files" # Папка в текущей директории
    # "download.default_directory": f"{os.getcwd()}\\folder_for_files" # Или обратный слеш ?
}
options.add_experimental_option("prefs", prefs)

Веб-элементы для загрузки файлов являются input-полями с type='file'
Поэтому, для того, что бы отправить в них файл - нужно использовать метод send_keys(), а в качестве аргумента передать путь к нужному файлу
upload.field = driver.find_element('xpath', "//input[@type='file']")
upload.field.send_keys(f"{os.getcwd()/files/image_fo_upload.jpg}") # Путь к файлу image_fo_upload.jpg в папке files в текущей директории
Если загрузка файлов реализована на фронтенде через button, то там все равно будет input c type='file' просто он будет скрытым

Ожидания используются для опроса страницы о наличии веб-элемента в течении некоторого времени
Они применяются, в основном, к find_element и find_elements
Ожидания бывают неявные и явные

Неявные ожидания (implicit wait) - это количество времени в течении которого Вебдрайвер будет проверять страницу на наличие веб-элемента при помощи find_element и find_elements
Если элемент будет найден раньше указанного времени - ожидание завершится раньше
Неявное ожидание задается один раз для всего модуля и применяется для каждого find_element и find_elements в нем
driver.implicitly_wait(10) - в качестве аргумента принимает количество времени в секундах

Явное ожидание (explicit wait) ожидает выполнение определенного действия (появления на сранице, изменение цвета и тд), изменения состояния определенного веб-элемента
Оно указывается к конкретному веб-элементу, отдельно для каждого из них
Для использования явного ожидания нужно сделать 2 импорта:
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions
И создать обьект wait, который и отвечает за явное ожидание
Этот обьект является инстантом класса WebDriverWait и принимает 3 аргумента:
1. driver
2. Время, в течении которого Драйвер будет ожидать выполнения явного условия
3. pool_frequency (не обязательный) - частота, с которой проверяется страница на наличие условия
wait = WebDriverWait(driver, 15, poll_frequency=1)
Обьект wait имеет метод until, для ожидания явного условия expected_conditions
Если веб-элемент был найден - этот метод возвращает его

expected_conditions - имеет список доступных условий:
visibility_of_element_located - элемент виден на странице (его высота и ширина больше ноля)
element_to_be_clickable - элемент кликабельный
invisibility_of_element_located - отсутствие єлемента на странице
Эти методы в качестве аргумента принимают кортеж из 2 элементов: метод поиска веб-элемента на странице и его локатор (внутри метода кортеж будет распакован на элементы)
text_to_be_present_in_element_value - проверяет что в элементе находится нужный текст
Данный метод принимает 2 аргумента: кортеж из метода поиска и локатора, а так же текст, с которым будет сравниватся текст в элементе
text_to_be_present_in_element_value(('xpath', "//input[@type='text']"), "Hi"))

Input field has no text attribute ?
Other 2 methods text_to_be_present_in_element

Для удобства, метод поиска и локатор веб-элемента можно записывать в отдельную переменную - VISIBLE_AFTER_BUTTON = ('xpath', "//button[@id='visibleAfter']")
wait.until(expected_conditions.visibility_of_element_located(VISIBLE_AFTER_BUTTON)) # С использованием переменной
wait.until(expected_conditions.visibility_of_element_located(('xpath', "//button[@id='visibleAfter']"))) # Вернет веб-элемент, если найдет его
visible_after_button = wait.until(expected_conditions.visibility_of_element_located(VISIBLE_AFTER_BUTTON))
visible_after_button.click()

Alert - не является веб-элементом, его нет в ДОМ и его нельзя проинспектировать
Алерт на странице в момент времени может быть только один
Для того что бы Селениум мог взаимодействовать с ним, его нужно записать в переменную, а затем переключится на него
alert = wait.until(expected_conditions.alert_is_present())
driver.switch_to.alert
alert.accept() - кликнуть на кнопку Принять/OK в Алерте
alert.dismiss() - кликнуть на кнопку Отклонить в Алерте
alert.text - сообщение отображаемое в Алерте
alert.send_keys() - ввести текст в поле ввода в Алерте, если оно там есть
Текст введенный в поле ввода в Алерте не отображается в браузере Селениум

save_screenshot() - сохранить скриншот текущей страницы в текущую директорию
Название файла передается в качестве аргумента в виде строки - driver.save_screenshot("screenshot.png") - how to use f strings here ?

disable-blink-features=AutomationControlled - опция, которая отключает ВебДрайвер мод, что б приложения не определяли тесты как автоматизированное устройство управления браузером
options.add_argument("--disable-blink-features=AutomationControlled")
Однако часто этого бывает не достаточно, а что бы приложение распознавало автотесты как реального пользователя и не блокировало как бота - нужно использовать User-Agent
User-Agent - это строка, которая содержит информацию о клиенте (название браузера, его версию и тд)
Для веб-приложений это идентификатор, который определяет реального пользователя и даже может подстраивать свое поведение, логику в зависимости от информации в User-Agent
В User-Agent содержится следующая информация:
1. Название и версия браузера
2. Язык
3. ОС и его версия
4. Тип устройства
Список Юзер-Агентов - https://www.useragents.me/
options.add_argument("--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1.1 Safari/605.1.1")

Cookie - текстовые файлы небольшого размера, которые веб-сайты сохраняют на ПК пользователя, когда он их посещает
Сайты хранят в этих файлах информацию о клиенте (токен авторизации, какие товары он добавил в корзину, какую тему, язык на сайте выбрал и тд)
Когда пользователь снова посещает ранее просмотренный веб-сайт, его браузер отправляет Куки на сервер, что бы сайт мог восстановить у себя информацию о клиенте
get_cookies - получить все куки
get_cookie - получить значение определенной куки, название которой передается в виде аргумента
cookie_abtest = driver.get_cookie("abtestv2")
delete_cookies - удалить все куки
delete_cookie - удалить определенное куки, название которой передается в виде аргумента
driver.delete_cookie("abtestv2")
add_cookie - добавить куки, в качестве аргумента передается словарь
driver.add_cookie({"name": "Hi", "value": "123"})
Для изменения куки - ее нужно сохранить в переменную, удалить на сайте, внести изменения в сохраненную, а затем добавить ее на сайт
cookie_abtest = driver.get_cookie("abtestv2")
driver.delete_cookie("abtestv2")
cookie_abtest["value"] = "version"
driver.add_cookie(cookie_abtest)
cookie_abtest_after = driver.get_cookie("abtestv2")
print(cookie_abtest) # {'domain': '.motorsport.com', 'expiry': 1773866707, 'httpOnly': False, 'name': 'abtestv2', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'v8.3'}
driver.add_cookie(cookie_abtest) # {'domain': '.motorsport.com', 'expiry': 1773866707, 'httpOnly': False, 'name': 'abtestv2', 'path': '/', 'sameSite': 'Lax', 'secure': True, 'value': 'version'}
Куки, все или только нужные, можно сохранить в отдельный файл при помощи модуля pickle и его метода dump
В качестве аргументов, этот метод принимает: обьект который нужно скачать и путь к файлу, в который его нужно сохранить
import pickle
1. pickle.dump(driver.get_cookies(), open(os.getcwd()+"/cookies/all_cookies.pkl", "wb"))
2. pickle.dump(driver.get_cookies(), open(os.path.join(os.getcwd(), "cookies", "all_cookies.pkl"), "wb"))
3. with open(os.path.join(os.getcwd(), "cookies", "all_cookie.pkl"), "wb") as f:
       pickle.dump(driver.get_cookies(), f)
Метод open принимает путь к файлу и протокол сериализации (преобразования данных), в котором будет открыт этот файл для записи данных
wb - write binary - файл будет открыт для записи бинарных данных
Данные должны быть записаны именно в бинарном режиме потому, что pickle работает с данными этого типа, а не текстового или другого
Если открыть файл в обычном режиме w, то возможно проблемы с кодировкой или искажение данных
После этого, сохраненные куки можно загрузить на сайт при помощи метода pickle - load
В качестве аргументов он принимает: путь к файлу с куками и протокол
Протокол в этом случае будет rb - read binary
Метод load возвращает данные из прочитанного файла, поэтому результат его вызова нужно присвоить переменной
cookies = pickle.load(open(os.getcwd()+"/cookies/all_cookies.pkl", "rb"))
Куки были сохранены в файл при помощи метода get_cookies, который возвращает массив состоящий из кук
Поэтому, переменная cookies содержит этот массив и что б добавить их все на сайт - нужно использовать цикл для их перебора
for cookie in cookies:
    driver.add_cookie(cookie)
Перед добавлением куки, их нужно удалить, что б они не дублировались - driver.delete_all_cookies()

Checkbox - веб-элемент, взаимодействие с которым происходит через клик
CHECKBOX_1 = ('xpath', "//input[@type='checkbox'][1]")
checkbox1 = driver.find_element(*CHECKBOX_1)
checkbox1.click()
У отмеченного/активного чекбокса есть аттрибут checked, даже если его не видно в HTML, он есть, но скрыт в ДОМ - он нужен для проверки состояния чекбокса
Есть 2 способа проверить состояние чекбокса
Первый - при помощи метода get_attribute
print(checkbox1.get_attribute('checked')) # None - чекбокс не отмечен
print(checkbox1.get_attribute('checked')) # true - чекбокс активен
Метод возвращает строку true, а не булевое значение True, что нужно учитывать при проверке результата
assert checkbox1.get_attribute('checked') is not None
assert checkbox1.get_attribute('checked') == 'true'
Второй - при помощи метода is_selected
print(checkbox1.is_selected()) # True - чекбокс выбран
print(checkbox1.is_selected()) # False - чекбокс не активен
Element click intercepted - ошибка когда элемент в HTML разметке перекрыт другими эелементами (svg, картинками, блоками и тд) и нет возможности на него кликнуть
В таком случае нужно использовать один элемент для клика, а сам input с типом checkbox, для проверки на аттрибут checked
Веб-элемент для клика нужно брать тот, по которому возможен клик, он не перекрыт другими элементами и находится на самом верху
CHECKBOX_1 = ('xpath', "//label[@for='tree-node-home']") # Элемент для клика
CHECK_STATUS = ('xpath', "//input[@id='tree-node-home']") # Сам чекбокс для проверки его аттрибута checked после клика
checkbox1 = driver.find_element(*CHECKBOX_1)
checkbox1.click()
assert driver.find_element(*CHECK_STATUS).is_selected() is True

Если блоки, клик на которые меняет их поведение (цвет, размер и тд), не являются input-полями - метод is_selected для них не работает
В таком случае, у элемента после клика может менятся аттрибут в HTML (active, selected) - это будет точкой для проверки
CHECKBOX1 = ('xpath', "//li[@class='mt-2 list-group-item list-group-item-action'][2]")
checkbox1 = driver.find_element(*CHECKBOX1)
checkbox1_class = checkbox1.get_attribute('class')
print(checkbox1_class) # mt-2 list-group-item list-group-item-action - класс элемента до клика
checkbox1.click()
checkbox1_class_active = checkbox1.get_attribute('class')
print(checkbox1_class_active) # mt-2 list-group-item active list-group-item-action - class элемента изменился после клика на него
assert 'active' in checkbox1_class_active

Radio-button создается так же при помощи input-поля и поэтому, взаимодействие с ним происходит так же через клик
Отличием от чекбокса является то, что в одной форме можно выбрать только одну радио-кнопку, а чекбоксов можно выбрать несколько
Если радио-кнопка перекрыта другими элементами и клик на ее input не возможет, применяется тот же способ что и для чекбоксов - один элемент для клика, а сам input с типом radio, для проверки на то, отмечен ли он (is_selected)
YES_RADIO = ('xpath', "(//label[@class='custom-control-label'])[1]")
YES_RADIO_STATUS = ('xpath', "//input[@id='yesRadio']")
yes_radio = driver.find_element(*YES_RADIO)
yes_radio.click()
assert driver.find_element(*YES_RADIO_STATUS).is_selected() is True

is_enabled - проверить, не находится ли чекбокс, радио/обычная кнопка в статусе disabled
print(yes_radio.is_enabled())

Proxy-server - это посредник между ПК пользователя (или локальной сетью) и интернетом
Используя прокси, весь трафик проходит через этот сервер, прежде чем достигает назначения и обратно
Прокси может скрывать IP-адресс, обходить блокировки и другое
Прокси сервер добавляется в Селениум при помощи Опций браузера
from selenium.webdriver.chrome.options import Options
PROXY_SERVER = "172.104.209.44:1080"
options = Options()
options.add_argument(f"proxy-server={PROXY_SERVER}")
driver = webdriver.Chrome(service=service, options=options)
driver.get('https://whatismyipaddress.com/') # Проверить, изменился ли IP-address и мето нахождения
Если для Прокси сервера нужен логин и пароль - его нужно указать перед его адрессом PROXY_SERVER = "username:password@172.104.209.44:1080"

Если для тестов нужны несколько разных пользователей - можно создать несколько обьектов driver, все они будут независимыми и не будут влиять друг на друга
Обьект Service в данном случае, создается по усмотрению, что бы окно браузера не закрылось раньше нужного времени
from selenium import webdriver
driver1 = webdriver.Chrome()
driver1.get('https://www.motor1.com/')
driver2 = webdriver.Chrome()
driver2.get('https://www.motor1.com/')

Селениум держит фокус на первой открытой вкладке, поэтому, если открывается новая - ему нужно явно указать переключится на нее
Для Вебдрайвера нет разницы между вкладкой и отдельным окном браузера, для него это одно и тоже
Все вкладки и окна работают в рамках одной сессии. Тоесть, если вы авторизовались в одной вкладке и откроете новую или новое окно - в нем вы так же будете авторизованы
Дескриптор - уникальный идентификатор/айди окна или вкладки, который позволяет различать их между собой
current_window_handle - получить дескриптор текущей вкладки/окна
window_handles - получить дескрипторы всех открытых вкладок/окон
window_handles - возвращает список идентификаторов всех открытых вкладок
Для переключения между вкладками нужно обращатся к соответствующему дескриптору при помощи индекса списка
switch_to.window() - метод для переключения между вкладками. В качестве аргумента принимает идентификатор нужной вкладки
tabs = driver.window_handles # Список айди всех открытых вкладок
driver.switch_to.window(tabs[1]) # Переключение во вторую вкладку
switch_to.new_window('tab') - открывает новую вкладку и автоматически переключает фокус Селениум на нее
switch_to.new_window('window') - открывает новое окно и сразу переключет фокус Селениум на него
driver.switch_to.new_window("tab")
driver.get('https://www.autosport.com/') # Ссылка будет открыта в новой вкладке и фокус Селениум будет на ней, в ней сразу можно будет работать

Select - это поле, клик на которое открывает дроп-даун список, из которого можно выбрать айтем
Селекты могут быть реализованы двумя способами:
1. при помощи тега select, а айтемы в списке - при помощи тега option - старая реализация
2. через тег div и input внутри него - современная реализация

1. Для работы с Селектами такого типа, нужно импортировать класс Select и создать его обьект. Этот обьект и будет дроп-даун списком
Создание обьекта класса Select нужно для того, что б можно было работать с его айтемами - option
from selenium.webdriver.support.select import Select
SELECT_LOCATOR = ('xpath', "(//select[@class='ms-result-table-grouping-header__select text-body font-bold uppercase ms-native-select__select'])[2]")
DROP_DOWN = Select(driver.find_element(*SELECT_LOCATOR))
Обьекту класса Select доступны все методы веб-элемента Селект
Взаимодействовать с элементами Селекта можно тремя способами:
select_by_visible_text - через текст
select_by_value - значение (value)
select_by_index - индекс

options - возвращает список всех айтемов/опций в Селекте
Перебор всех опций Селекта можно осуществить при помощи цикла for
Перебор по тексту опций
drop_down_options = DROP_DOWN.options
for o in drop_down_options:
    # DROP_DOWN.select_by_visible_text(o.text.title()) # Если стиль текста преобразуется на фронте
    DROP_DOWN.select_by_visible_text(o.text) # Каждая опция Селекта будет выбрана в нем
По индексу
for o in range(len(drop_down_options)):
    DROP_DOWN.select_by_index(o)
По значению аттрибута value
for o in drop_down_options:
    DROP_DOWN.select_by_value(o.get_attribute("value"))

Модуль Keys используется для иммитации нажатия на кнопки клавиатуры
Ему доступны все кнопки на клавиатуре и их сочетания (ctrl + c, ctrl + v и тд)
from selenium.webdriver import Keys
driver.get("https://the-internet.herokuapp.com/key_presses")
input_field = driver.find_element('xpath', "//input[@id='target']")
input_field.send_keys(Keys.F2)
time.sleep(2)
input_field.send_keys(Keys.CONTROL + "V")
time.sleep(2)

Keys.TAB - так же используется для автоматического завершения части введенного слова
driver.get("https://demoqa.com/select-menu")
multi_select = driver.find_element('xpath', "//input[@id='react-select-4-input']")
multi_select.send_keys("Gre")
time.sleep(2)
multi_select.send_keys(Keys.TAB) # Из дроп-даун списка выберет айтем с текстом Green
time.sleep(2)

2. Современные Селекты реализованы при помощи div и input внутри него
Поэтому работать с ними можно двумя способами:
1. как с input и send_keys для него
2. как с div
В качестве аргумента в send_keys - передать айтем из дроп-даун списка и нажать Enter для его выбора
driver.get("https://demoqa.com/select-menu")
drop_down = driver.find_element('xpath', "//input[@id='react-select-3-input']")
drop_down.send_keys("Mr.")
time.sleep(4)
drop_down.send_keys(Keys.ENTER)
time.sleep(4)

Список дроп-даунов закрывается если с него убрать фокус курсора
Что бы исчезающие элементы не пропадали и были доступны для испектирования - можно использовать функцию setTimeout в Консоли - setTimeout(function() { debugger; }, 5000)
Этот код запускает режим Дебагера и останавливает выполнение JS кода на странице через 5 секунд
Если работать с дроп-даунами как с тегом div, тогда клик нужно делать на нужный div и в появившемся списке кликать на нужный элемент
driver.get("https://demoqa.com/select-menu")
drop_down_btn = driver.find_element('xpath', "(//div[@class='col-md-6 col-sm-12'])[4]")
drop_down_btn.click()
time.sleep(2)
item = driver.find_element('xpath', "//div[@class=' css-1s9izoc']/div/div[2]") # //div[text()='Mr.']
item.click()
time.sleep(2)

Тег iframe - позволяет встраивать HTML страницу в другую HTML страницу
На одной странице может быть несколько айфреймов, поэтому, для работы с элементами iframe - ВебДрайверу нужно явно указать, с какой именно страницей ему работать
Без явного указания ВебДрайвер не найдет элементы внутри айфреймов
switch_to.frame - метод для переключения в Айфрем
Переключится в Айфрейм можно при помощи:
1. самого веб-элемента Айфрейм
IFRAME = ('xpath', "//iframe[@id='sp_message_iframe_1274672']")
# iframe = wait.until(expected_conditions.visibility_of_element_located(IFRAME)) # Если Айфрейм появляется не сразу
iframe = driver.find_element(*IFRAME)
driver.switch_to.frame(iframe)
2. значения его тега id
driver.switch_to.frame('sp_message_iframe_1274672')
3. значения его тега name
4. индекса
driver.switch_to.frame(0) # Переключится в первый по очереди Айфрейм на странице
Что бы после переключения в Айфрейм дальше работать с элементами основной страницы - нужно явно переключится на нее
switch_to.default_content - переключение на основную страницу
Если нужный Айфрейм находится внутри других Айфреймов - нужно переключатся в них в порядке очереди, от внешнего к нужному внутреннему
driver.get('https://demoqa.com/nestedframes')
driver.switch_to.frame('frame1')
text1 = driver.find_element('xpath', "//body").text
print(text1) # Parent frame
driver.switch_to.frame(0)
text2 = driver.find_element('xpath', "//body").text
print(text2) # Child Iframe
Если после работы с Айфреймом, который находится внутри другого Айфрейма, нужно вернутся во внешний - это можно сделать при помощи switch_to.parent_frame
driver.switch_to.parent_frame()
print(driver.find_element('xpath', '//body').text) # Parent frame - ВебДрайвер вернулся во внешний Айфрейм

Такие действия как: двойной клик, клик правой кнопкой мыши, ховер, перетаскивание элементов и другие не входят в базовый набор функций Селениум
Для них существует отдельный API - action chains (цепочки действий)
Его нужно импортировать в модуль и создать его обьект. В качестве аргумента, при создании обьекта, нужно передать созданный ранее driver
from selenium.webdriver.common.action_chains import ActionChains
driver = webdriver.Chrome()
action = ActionChains(driver)
Обьекту action доступны такие методы как:
double_click - двойной клик
click - клик левой кнопкой мыши
context_click - клик правой кнопкой мыши (открывает контекстное меню)
move_to_element - ховер на элемент
pause - пауза на определенное количество секунд, которое передается как аргумент
Все эти методы, в качестве аргумента, принимают веб-элемент, над которым нужно совершить действие
Каждая цепочка действий имеет свое начало - первое действие и должна заканчиватся методом perform() - который обозначает ее завершение и запускает всю цепочку
driver.get('https://testkru.com/Elements/Buttons')
HOVER_BTN = ('xpath', "//button[@name='colorChangeOnHover']")
action.move_to_element(driver.find_element(*HOVER_BTN)).perform() # move_to_element - начало цепочки действий, а perform - ее завершение
Цепочка действий может содержать несколько действий
double_click_btn = driver.find_element(*DOUBLE_CLICK_BTN)
right_click_btn = driver.find_element(*RIGHT_CLICK_BTN)
left_click_btn = driver.find_element(*LEFT_CLICK_BTN)
hover_btn = driver.find_element(*HOVER_BTN)
action.double_click(double_click_btn).context_click(right_click_btn).click(left_click_btn).move_to_element(hover_btn).perform() # 4 действия в одной цепочке
Если цепочка действий получилась довольно длинной, для лучшей читаемости, ее можно разделить на несколько строк. Сделать это можно двумя способами:
1. обернуть ее всю в круглые скобки и разделить пробелами
(action.move_to_element(rally_category).
pause(2).
move_to_element(serie_in_rally).
perform())
2. при помощи обратного слеша и пробела
action.move_to_element(rally_category).\
 pause(2).\
 move_to_element(serie_in_rally).\
 perform()

Есть 2 способа работы с drag-and-drop
Первый - drag_and_drop метод цепочки действий
Он принимает 2 веб-элемента, в качестве аргументов: source - какой блок перетягивать, target - куда перетягивать
BLOCK_A = ('xpath', "//div[@id='column-a']")
BLOCK_B = ('xpath', "//div[@id='column-b']")
driver.get('https://the-internet.herokuapp.com/drag_and_drop')
action.drag_and_drop(driver.find_element(*BLOCK_A), driver.find_element(*BLOCK_B)).perform()
print(driver.find_element('xpath', "//div[@id='column-a']/header").text)
Но этот способ не всегда подходит. Например, когда блок, в который нужно перетянуть, отображается не сразу, а с небольшой задержкой
Второй - при помощи методов click_and_hold - который берет элемент который нужно перетащить, move_to_element - куда нужно перетащить и release
release - отпускает зажатую кнопку мыши
driver.get('https://tympanus.net/Development/DragDropInteractions/sidebar.html')
DRAG_BLOCK = ('xpath', "//div[@class='grid__item'][2]")
DROP_BLOCK = ('xpath', "//div[@class='drop-area__item'][2]")
action.click_and_hold(driver.find_element(*DRAG_BLOCK)).pause(1.5).move_to_element(driver.find_element(*DROP_BLOCK)).release().perform()
changes = driver.find_element('xpath', "//div[@id='drop-area']//div[2]").get_attribute('class')
time.sleep(2)
print(changes)
assert "drop-area__item drop-feedback" == changes

execute_script - позволяет выполнять JS код на странице
driver.execute_script("alert('Hi')")

Скрол на странице можно реализовать 2 способами:
1. scroll_to_element метод цепочки действий
driver.get('https://seiyria.com/bootstrap-slider/')
EXAMPLE2 = ('xpath', "//h3[text()='Example 2: ']")
action.scroll_to_element(driver.find_element(*EXAMPLE2)).perform()
2. при помощи Javascript (метода window.scrollTo), кастомного класса и методов которые его используют
class Scrolls:
    def __init__(self, driver, action):
        self.driver = driver
        self.action = action

    def scroll_by(self, x, y):
        self.driver.execute_script(f"window.scrollTo({x}, {y})")

    def scroll_to_bottom(self):
        self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight)")

    def scroll_to_top(self):
        self.driver.execute_script("window.scrollTo(0, 0)")

    def scroll_to_element(self, element):
        self.action.scroll_to_element(element).perform()
        self.driver.execute_script("""window.scrollTo({top: window.scrollY + 700,});""")

Плавный скролл вниз, вверх, к элементу
class Scrolls:
    def __init__(self, driver, action):
        self.driver = driver
        self.action = action

    def scroll_to_top(self):
        self.driver.execute_script("window.scrollTo({top: 0, behavior: 'smooth'});")
    
    def scroll_to_bottom(self):
        self.driver.execute_script("window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});")

    def scroll_to_elem_with_offset_down(self, elem):
        self.action.scroll_to_element(elem).perform()
        # time.sleep(4) # Just to check
        self.driver.execute_script("window.scrollTo({top: window.scrollY + 700, behavior: 'smooth'});")

# The x can always be 0, to scroll up and down
    def scroll_to_coord(self, x, y):
        self.driver.execute_script(f"window.scrollTo({x}, {y});")

Для установки расширения нужен его файл в формате .crx
После его скачивания в магазине расширений Хром, этот файл очень тяжело найти на ПК и легче его найти и скачать в интернете
Например .crx файл AdBlocker расширения можно скачать тут https://www.crx4chrome.com/crx/31927/
Затем этот файл нужно добавить в директорию с проектом
Добавляются и устанавливаются расширения при помощи options и метода add_extension, который в качестве аргумента принимает путь к .crx файлу расширения
options = webdriver.ChromeOptions()
options.add_extension("adblocker.crx")
driver = webdriver.Chrome(options=options)
driver.get('https://www.motorsport.com/')

Для прохождения базовой авторизации на сайте имя и пароль указывается в ссылке, на которую нужно перейти - https://username:password@domain/path
driver.get('https://m:m@www.s.motorsport.com')

Эмулировать поведение телефона можна используя Опции и add_experimental_option
В add_experimental_option нужно передать строку "mobileEmulation" и словарь с нужными параметрами
mobile_emulation = {"deviceName": "iPhone X"} # Эмулирует Айфон Х
options.add_experimental_option("mobileEmulation", mobile_emulation)
Эмулировать можно стандартные телефоны для браузера. Для Хром это: iPhone X, iPhone 6, Nexus 5, Nexus 6P, Samsung Galaxy S5, Galaxy Note 3
Если нужного телефона нет в списке стандартных для браузера или нужны кастомные настройки, можно использовать deviceMetrics в mobile_emulation словаре
mobile_emulation = {
    "deviceMetrics": {
        "width": 360,   # Ширина экрана
        "height": 640,  # Высота экрана
        "pixelRatio": 3.0  # Плотность пикселей
    },
    "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5 Build/MOB30V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36"
}


1. Создание нового проекта
2. Кнопки браузера (вперед, назад...)
3. Получение данных страницы (тайтл, урл, сорс код)
4. find_elements
5. Contains, and, get_attribute, для аттрибутов, аттрибут text
6. Опции, add_attribute:
размер окна, инкогнито, хедлес мод, оключить кеш
7. Стратегия загрузки страниц
8. Загрузка, скачивание файлов, prefs
9. Явные ожидания, expected conditions
10. Send_keys for input fields
11. Alert
12. Screenshot
13. User Agent
14. Cookie, pickle module
15. Checkbox
16. Radio button
17. Proxy server
18. Для иммитации 2х пользователей - 2 разных драйвера
19. Переключение между вкладками, открытие новой вкладки, окна
20. Select 2х типов (drop-down)
21. Модуль Keys
22. iframe
23. Цепочка действий
24. Drag-and-drop
25. Execute JS script
26. Scroll
27. Установка расширений