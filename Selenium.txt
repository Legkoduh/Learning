WebDriver - API для управления поведением браузера
Каждый браузер поддерживается определенной реализацией Драйвера (Chromedriver)
Driver - компонент/сущность отвечающая за делегирование полномочий браузеру
Драйвер обеспечивает обмен данными между Selenium и браузером
Selenium - фреймворк, связывающий все эти части вместе при помощи пользовательского интерфейса - кода на Python, Java и других языках программирования
Позволяет использовать все части браузера, обеспечивая кросс-браузерную и кросс-платформенную автоматизацию действий в браузере

1. Selenium + WebDriver > 2. Driver (Chromedriver) > 3. Browser > 4. Driver > 5. Selenium + Webdriver
1. Описываются действия для управления браузером при помощи языка программирования (открой ссылку, нажми на кнопку и тд)
2. Этот код передается Драйверу
3. Драйвер передает все эти действия Браузеру
Браузер выполняет описанные действия и возвращает результат обратно Драйверу
4. Драйвер получает результат выполненых действий и передает их в Selenium
5. В Селениум выполняются нужные действия

Создаем новый проект
Создает виртуальное окружение: python3 -m venv venv
В результате, в корневой директории проекта появится папка venv
Затем нужно активировать виртуальное окружение: venv/Scripts/activate.ps1 (on Windows), source venv/bin/activate (for MacOS)
После этого, в терминале, в начале строки, появится (venv), это будет означать, что окружение активировано
Далее нужно установить Selenium и WebDriver manager: pip3 install selenium webdriver-manager
Webdriver manager позволяет автоматически скачивать и устанавливать самую новую версию Драйвера для того или иного браузера без скачивания и замены бинарных файлов в проектах
После этого можно создать новый Пайтон файл для написания кода
В него нужно импортировать Вебдрайвер
from selenium import webdriver
Потом из webdriver-manager импортируем необходимый драйвер, в зависимости от нужного браузера (Chrome - chromedriver)
from webdriver_manager.chrome import ChromeDriverManager
Так же нужно импортировать класс Service, который появился в Selenium 4
Он отвечает за установку, открытие и закрытие Драйвера
from selenium.webdriver.chrome.service import Service

В Selenium 4 инициализация Драйвера происходит через обьект класса Service
service = Service(executable_path=ChromeDriverManager().install()) # Обьект класса Service
executable_path - путь к нашему Драйверу, а так как у нас используются не .bin файлы, а DriverManager, указывается путь к его методу install
Это метод установит Драйвер и передаст путь к нему в Service
Затем инициализируется сам Драйвер
driver = webdriver.Chrome(service=service)
Теперь можно запустить программу - будет открыт и закрыт Хром браузер
Закрывается он автоматически благодаря Service, который отвечает за его закрытие, driver.quit() теперь не нужно указывать

Если нужна одна из прошлых версий браузера, ее можно указать при создании обьекта service в ChromeDriverManager
service = Service(executable_path=ChromeDiverManager(version="114.0.5735.90").install())

Драйвер Firefox создается по аналогичной схеме
from selenium import webdriver
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.firefox.service import Service

service = Service(executable_path=GeckoDriverManager().install())
driver = webdriver.Firefox(serivce=service)

Управление кнопками браузера
driver.forward() - кнопка браузера Вперед
driver.back() - кнопка браузера Назад
driver.refresh() - кнопка браузера Перезагрузить страницу

Получение данных страницы
driver.current_url - текущий урл страницы
driver.title - заголовок текущей страницы
driver.page_source - исходный код страницы

Валидировать данные можно при помощи условия assert
После запятой можно указать сообщение, которое будет выведено в случает неудачи
assert url == 'https://www.motorsport.com/', 'Invalid URL'


find.element() - метод для поиска элементов на странице
В качестве аргументов он принимает:
1. метод поиска: по xpath, class name, css селектору, id
2. значение локатора, по которому находится веб-элелемент
driver.find_element('xpath', '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')
Методы поиска: "id", "xpath", "name", "class name", "css selector"

Так же, искать элементы можно при помощи класса By импортируемого из selenium
Но для этого в каждом файле нужно его импортировать, что не очень удобно
from selenium.webdriver.common.by import By
driver.find_element(By.XPATH, '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')

С точки зрения веб-приложения, веб элемент - это любой элемент на странице
В Селениум, веб-элемент - это тип данных, обьект класса WebElement
driver.get('https://rozetka.com.ua/ua/')
button = driver.find_element('xpath', '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')
print(type(button)) # <class 'selenium.webdriver.remote.webelement.WebElement'>

find_elements() - возвращает список элементов у которых одинаковое значение переданного локатора
Так как это список, обращаться к его элементам можно по индексу
Например, если несколько элементов на странице имеют одинаковый class name или id, все их можно получить
titles_list = driver.find_elements('class name', 'title') # [<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.153")>,
<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.154")>, ...,
<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.176")>]
titles_list[1] # <selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.154")>

XPath (XML path language) - язык запросов к элементам XML, HTML документов
В XPath используются символы /, //, а так же теги
XPath всегда начинается с / или //
/ - означает прямого потомка, аналогичен символу > в CSS-селекторах
html, body, div, span, h1 - в такой структуре span - прямой потомок div, div/span
// - означает потомка любого уровня вложенности
// используется для глобального поиска от корня документа или внутри других тегов
html, body, div, span, h1 - в такой структуре путь к span можно указать как: //span (от корня документа) или html//span (глобальный поиск внутри html тега)
//div[5] - div который в структуре находится на 5-ом уровне вложенности
(//div)[5] ???
При использовании глобального поиска, в случае изменения меторасположения веб-элемента в структуре дерева, в большинтсве случаев XPath не сломается

К тегам относятся все HTML теги: head, body, div, span, input, h3 и т.д.
Теги могут иметь аттрибуты, один или несколько
К ним относятся: class, id, type, placeholder
Аттрибуты можно использовать для формирования XPath
В XPath аттрибуты указываются в квадратных скобках после тегов
Перед аттрибутом ставится символ @, после названия аттрибута символ = и значение этого аттрибута в кавычках
button[@class='submit'], button - HTML тег, у которого есть аттрибут class, значение которого submit
Исключением является тег text, он указывается без символа @, но с круглыми скобками () - //span[text()='Супер! Дякую']
Например, если в дереве несколько полей ввода, можно указать аттрибут нужного поля, который уникален для него
//input[@type='email'] - у тега input есть аттрибут type, значение которого email и такого значения у аттрибута type нет у других тегов input

Аттрибуты могут имееть значения, которые содержат несколько названий, например class='style-scope ytd-app', содержит style-scope и ytd-app
Что бы не указывать их все, можно воспользоваться методом contains() и передать ему одно из значений аттрибута
contains() указывается после тега, в квадртаных скобках, как аттрибут, но без символа @ и принимает 2 аргумента: название аттрибута с символом @ и его значение в скобках
//div[contains(@class, 'ytd-app')]

Если нужно найти тег, у которого несколько аттрибутов - они перечисляются с помощью оператора and
Тег a имеет аттрибуты class='ms-item ms-item-hor-d ms-item-hor-t ms-item-hor-m', data-entity-id='10700419', data-entity-type='article'
//a[@data-entity-id='10700419' and @data-entity-type='article']

send_keys() - заполняет поле ввода значением, которое принимает в качестве аргумента
input_field.send_keys('test_email@gmail.com') - введет в поле ввода текст test_email@gmail.com
clear() - очищает поле ввода

get_attribute() - возвращает аттрибутов веб-элементов к которым применяется
В качестве аргумента принимает название нужного аттрибута:
value - значение/текст в поле ввода
maxlength - максимально допустимая длина текста в поле ввода
input_field.get_attribute("value") # test_email@gmail.com

webdriver.ChromeOptions() - опции браузера (в данном примере Chrome)
К опциям браузера относятся:
incognito - открытие в режиме инкогнито
window-size=1280,780 - с заданными размерами окна
headless - запуск браузера без графического интерфейса (в фоне, что требует меньшего количества ресурсов)
ignore-certificate-errors - игнорирование любых ошибок связанных с SSL-сертификатами (отсутствует, истек и т.д.)
disable_cache - отключение записи кеша
add_argument() - добавить опцию, что бы она выполнялась при запуске тестов
В качестве аргументов передаются названия опций с 2 тире в начале
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument("--incognito")
Для того, что бы опции выполнялись - их нужно передать в Драйвер, при его инициализации, в качестве аргумента
Поэтому создание и добавление опций должно быть указано до строки с созданием Драйвера

Так же можно напрямую импортировать Опции из webdriver
from selenium.webdriver.chrome.options import Options
options = Options()

driver.set_window_size(320, 660) - задать размеры окна браузера
Минус этого варианта в том, что он выполняется уже после инициализации драйвера
Поэтому браузер сначала открывается со стандартными размерами окна, а затем изменяех их на указанные в этом методе

Стратегия загрузки страницы - описывает момент когда Селениум начинает выполнять действия на странице
Возможные варианты: когда на странице загрузились все ресурсы, или когда загрузился только ДОМ, ожидание/отсуствие ожидания загрузки всех картинок
В Селениум есть 3 стратегии загрузки страницы:
normal (используется по умолчанию) - ожидает загрузки всех ресурсов на странице
eager - ожидает загрузки только ДОМ дерева
none - ничего не ожидает ?
Стратегия загрузки страницы задана в Опциях браузера
chrome_options.page_load_strategy = 'eager'

options - стандартные настройки браузера
prefs - специфические настройки: пути, директория для скачивания файлов и другие
Для изменения специфических настроек - их и их значения нужно указать в словаре prefs
А затем добавить словарь prefs со всеми нужными специфическими настройками в options при помощи метода add_experimental_option()
Слово "prefs" в add_experimental_option методе является зарезирвированным
download.default_directory - специфическая настройка браузера, указывает на папку куда нужно загружать файлы
Для указания пути к папке/файлу можно использовать модуль os, его метод getcws() указывает на текущую директорию
prefs = {
    "download.default_directory": f"{os.getcwd()}"
    # "download.default_directory": f"{os.getcwd()}/folder_for_files" # Папка в текущей директории
    # "download.default_directory": f"{os.getcwd()}\\folder_for_files" # Или обратный слеш ?
}
options.add_experimental_option("prefs", prefs)

Веб-элементы для загрузки файлов являются input-полями с type='file'
Поэтому, для того, что бы отправить в них файл - нужно использовать метод send_keys(), а в качестве аргумента передать путь к нужному файлу
upload.field = driver.find_element('xpath', "//input[@type='file']")
upload.field.send_keys(f"{os.getcwd()/files/image_fo_upload.jpg}") # Путь к файлу image_fo_upload.jpg в папке files в текущей директории
Если загрузка файлов реализована на фронтенде через button, то там все равно будет input c type='file' просто он будет скрытым

Ожидания используются для опроса страницы о наличии веб-элемента в течении некоторого времени
Они применяются, в основном, к find_element и find_elements
Ожидания бывают неявные и явные

Неявные ожидания (implicit wait) - это количество времени в течении которого Вебдрайвер будет проверять страницу на наличие веб-элемента при помощи find_element и find_elements
Если элемент будет найден раньше указанного времени - ожидание завершится раньше
Неявное ожидание задается один раз для всего модуля и применяется для каждого find_element и find_elements в нем
driver.implicitly_wait(10) - в качестве аргумента принимает количество времени в секундах

Явное ожидание (explicit wait) ожидает выполнение определенного действия (появления на сранице, изменение цвета и тд), изменения состояния определенного веб-элемента
Оно указывается к конкретному веб-элементу, отдельно для каждого из них
Для использования явного ожидания нужно сделать 2 импорта:
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions
И создать обьект wait, который и отвечает за явное ожидание
Этот обьект является инстантом класса WebDriverWait и принимает 3 аргумента:
1. driver
2. Время, в течении которого Драйвер будет ожидать выполнения явного условия
3. pool_frequency (не обязательный) - частота, с которой проверяется страница на наличие условия
wait = WebDriverWait(driver, 15, poll_frequency=1)
Обьект wait имеет метод until, для ожидания явного условия expected_conditions
Если веб-элемент был найден - этот метод возвращает его

expected_conditions - имеет список доступных условий:
visibility_of_element_located - элемент виден на странице (его высота и ширина больше ноля)
element_to_be_clickable - элемент кликабельный
invisibility_of_element_located - отсутствие єлемента на странице
Эти методы в качестве аргумента принимают кортеж из 2 элементов: метод поиска веб-элемента на странице и его локатор (внутри метода кортеж будет распакован на элементы)
text_to_be_present_in_element_value - проверяет что в элементе находится нужный текст
Данный метод принимает 2 аргумента: кортеж из метода поиска и локатора, а так же текст, с которым будет сравниватся текст в элементе
text_to_be_present_in_element_value(('xpath', "//input[@type='text']"), "Hi"))

Input field has no text attribute ?
Other 2 methods text_to_be_present_in_element

Для удобства, метод поиска и локатор веб-элемента можно записывать в отдельную переменную - VISIBLE_AFTER_BUTTON = ('xpath', "//button[@id='visibleAfter']")
wait.until(expected_conditions.visibility_of_element_located(VISIBLE_AFTER_BUTTON)) # С использованием переменной
wait.until(expected_conditions.visibility_of_element_located(('xpath', "//button[@id='visibleAfter']"))) # Вернет веб-элемент, если найдет его
visible_after_button = wait.until(expected_conditions.visibility_of_element_located(VISIBLE_AFTER_BUTTON))
visible_after_button.click()

Alert - не является веб-элементом, его нет в ДОМ и его нельзя проинспектировать
Алерт на странице в момент времени может быть только один
Для того что бы Селениум мог взаимодействовать с ним, его нужно записать в переменную, а затем переключится на него
alert = wait.until(expected_conditions.alert_is_present())
driver.switch_to.alert
alert.accept() - кликнуть на кнопку Принять/OK в Алерте
alert.dismiss() - кликнуть на кнопку Отклонить в Алерте
alert.text - сообщение отображаемое в Алерте
alert.send_keys() - ввести текст в поле ввода в Алерте, если оно там есть
Текст введенный в поле ввода в Алерте не отображается в браузере Селениум

save_screenshot() - сохранить скриншот текущей страницы в текущую директорию
Название файла передается в качестве аргумента в виде строки - driver.save_screenshot("screenshot.png") - how to use f strings here ?

disable-blink-features=AutomationControlled - опция, которая отключает ВебДрайвер мод, что б приложения не определяли тесты как автоматизированное устройство управления браузером
options.add_argument("--disable-blink-features=AutomationControlled")
Однако часто этого бывает не достаточно, а что бы приложение распознавало автотесты как реального пользователя и не блокировало как бота - нужно использовать User-Agent
User-Agent - это строка, которая содержит информацию о клиенте (название браузера, его версию и тд)
Для веб-приложений это идентификатор, который определяет реального пользователя и даже может подстраивать свое поведение, логику в зависимости от информации в User-Agent
В User-Agent содержится следующая информация:
1. Название и версия браузера
2. Язык
3. ОС и его версия
4. Тип устройства
Список Юзер-Агентов - https://www.useragents.me/
options.add_argument("--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1.1 Safari/605.1.1")

Cookie - текстовые файлы небольшого размера, которые веб-сайты сохраняют на ПК пользователя, когда он их посещает
Сайты хранят в этих файлах информацию о клиенте (токен авторизации, какие товары он добавил в корзину, какую тему, язык на сайте выбрал и тд)
Когда пользователь снова посещает ранее просмотренный веб-сайт, его браузер отправляет Куки на сервер, что бы сайт мог восстановить у себя информацию о клиенте
get_cookies - получить все куки
get_cookie - получить значение определенной куки, название которой передается в виде аргумента
cookie_abtest = driver.get_cookie("abtestv2")
delete_cookies - удалить все куки
delete_cookie - удалить определенное куки, название которой передается в виде аргумента
driver.delete_cookie("abtestv2")
add_cookie - добавить куки, в качестве аргумента передается словарь
driver.add_cookie({"name": "Hi", "value": "123"})
Для изменения куки - ее нужно сохранить в переменную, удалить на сайте, внести изменения в сохраненную, а затем добавить ее на сайт
cookie_abtest = driver.get_cookie("abtestv2")
driver.delete_cookie("abtestv2")
cookie_abtest["value"] = "version"
driver.add_cookie(cookie_abtest)
cookie_abtest_after = driver.get_cookie("abtestv2")
print(cookie_abtest) # {'domain': '.motorsport.com', 'expiry': 1773866707, 'httpOnly': False, 'name': 'abtestv2', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'v8.3'}
driver.add_cookie(cookie_abtest) # {'domain': '.motorsport.com', 'expiry': 1773866707, 'httpOnly': False, 'name': 'abtestv2', 'path': '/', 'sameSite': 'Lax', 'secure': True, 'value': 'version'}
Куки, все или только нужные, можно сохранить в отдельный файл при помощи модуля pickle и его метода dump
В качестве аргументов, этот метод принимает: обьект который нужно скачать и путь к файлу, в который его нужно сохранить
import pickle
1. pickle.dump(driver.get_cookies(), open(os.getcwd()+"/cookies/all_cookies.pkl", "wb"))
2. pickle.dump(driver.get_cookies(), open(os.path.join(os.getcwd(), "cookies", "all_cookies.pkl"), "wb"))
3. with open(os.path.join(os.getcwd(), "cookies", "all_cookie.pkl"), "wb") as f:
       pickle.dump(driver.get_cookies(), f)
Метод open принимает путь к файлу и протокол сериализации (преобразования данных), в котором будет открыт этот файл для записи данных
wb - write binary - файл будет открыт для записи бинарных данных
Данные должны быть записаны именно в бинарном режиме потому, что pickle работает с данными этого типа, а не текстового или другого
Если открыть файл в обычном режиме w, то возможно проблемы с кодировкой или искажение данных
После этого, сохраненные куки можно загрузить на сайт при помощи метода pickle - load
В качестве аргументов он принимает: путь к файлу с куками и протокол
Протокол в этом случае будет rb - read binary
Метод load возвращает данные из прочитанного файла, поэтому результат его вызова нужно присвоить переменной
cookies = pickle.load(open(os.getcwd()+"/cookies/all_cookies.pkl", "rb"))
Куки были сохранены в файл при помощи метода get_cookies, который возвращает массив состоящий из кук
Поэтому, переменная cookies содержит этот массив и что б добавить их все на сайт - нужно использовать цикл для их перебора
for cookie in cookies:
    driver.add_cookie(cookie)
Перед добавлением куки, их нужно удалить, что б они не дублировались - driver.delete_all_cookies()

Checkbox - веб-элемент, взаимодействие с которым происходит через клик
CHECKBOX_1 = ('xpath', "//input[@type='checkbox'][1]")
checkbox1 = driver.find_element(*CHECKBOX_1)
checkbox1.click()
У отмеченного/активного чекбокса есть аттрибут checked, даже если его не видно в HTML, он есть, но скрыт в ДОМ - он нужен для проверки состояния чекбокса
Есть 2 способа проверить состояние чекбокса
Первый - при помощи метода get_attribute
print(checkbox1.get_attribute('checked')) # None - чекбокс не отмечен
print(checkbox1.get_attribute('checked')) # true - чекбокс активен
Метод возвращает строку true, а не булевое значение True, что нужно учитывать при проверке результата
assert checkbox1.get_attribute('checked') is not None
assert checkbox1.get_attribute('checked') == 'true'
Второй - при помощи метода is_selected
print(checkbox1.is_selected()) # True - чекбокс выбран
print(checkbox1.is_selected()) # False - чекбокс не активен
Когда в HTML разметке чекбокс перекрыт другими эелементами (svg, картинки и тп) и нет возможности на него кликнуть - нужно использовать один элемент для клика, а сам input с типом checkbox для проверки на аттрибут checked
CHECKBOX_1 = ('xpath', "//label[@for='tree-node-home']") # Элемент для клика
CHECK_STATUS = ('xpath', "//input[@id='tree-node-home']") # Сам чекбокс для проверки его аттрибута checked после клика
checkbox1 = driver.find_element(*CHECKBOX_1)
checkbox1.click()
assert driver.find_element(*CHECK_STATUS).is_selected() is True

Если блоки, клик на которые меняет их поведение (цвет, размер и тд), не являются input-полями - метод is_selected для них не работает
В таком случае, у элемента после клика может менятся аттрибут в HTML (active, selected) - это будет точкой для проверки
CHECKBOX1 = ('xpath', "//li[@class='mt-2 list-group-item list-group-item-action'][2]")
checkbox1 = driver.find_element(*CHECKBOX1)
checkbox1_class = checkbox1.get_attribute('class')
print(checkbox1_class) # mt-2 list-group-item list-group-item-action - класс элемента до клика
checkbox1.click()
checkbox1_class_active = checkbox1.get_attribute('class')
print(checkbox1_class_active) # mt-2 list-group-item active list-group-item-action - class элемента изменился после клика на него
assert 'active' in checkbox1_class_active
