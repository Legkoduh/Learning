WebDriver - API для управления поведением браузера
Каждый браузер поддерживается определенной реализацией Драйвера (Chromedriver)
Driver - компонент/сущность отвечающая за делегирование полномочий браузеру
Драйвер обеспечивает обмен данными между Selenium и браузером
Selenium - фреймворк, связывающий все эти части вместе при помощи пользовательского интерфейса - кода на Python, Java и других языках программирования
Позволяет использовать все части браузера, обеспечивая кросс-браузерную и кросс-платформенную автоматизацию действий в браузере

1. Selenium + WebDriver > 2. Driver (Chromedriver) > 3. Browser > 4. Driver > 5. Selenium + Webdriver
1. Описываются действия для управления браузером при помощи языка программирования (открой ссылку, нажми на кнопку и тд)
2. Этот код передается Драйверу
3. Драйвер передает все эти действия Браузеру
Браузер выполняет описанные действия и возвращает результат обратно Драйверу
4. Драйвер получает результат выполненых действий и передает их в Selenium
5. В Селениум выполняются нужные действия

Создаем новый проект
1. Создает виртуальное окружение: python3 -m venv venv
В результате, в корневой директории проекта появится папка venv
2. Затем нужно активировать виртуальное окружение
На Windows, в зависимости от того, что используется в качестве встроенного терминала:
powershell - .\venv\Scripts\Activate.ps1
cmd.exe - venv\Scripts\activate.bat или .\venv\Scripts\activate.bat
На MacOS:
bash - source venv/bin/activate
И может быть zsh
Проверить какой используется в данный момент можно в Settings - Tools - Terminal - Shell path
После этого, в терминале, в начале строки, появится (venv), это будет означать, что окружение активировано
3. Далее нужно установить Selenium и WebDriver manager: pip3 install selenium webdriver-manager
Webdriver manager позволяет автоматически скачивать и устанавливать самую новую версию Драйвера для того или иного браузера без скачивания и замены бинарных файлов в проектах
Просмотреть все загруженные и установленные пакеты можно в File > Settings > Project: {project_name} > Python Interpreter
После этого можно создать новый Пайтон файл для написания кода
В него нужно импортировать Вебдрайвер
from selenium import webdriver
Потом из webdriver-manager импортируем необходимый драйвер, в зависимости от нужного браузера (chrome - chromedriver)
from webdriver_manager.chrome import ChromeDriverManager
Так же нужно импортировать класс Service, который появился в Selenium 4
Он отвечает за установку, открытие и закрытие Драйвера
from selenium.webdriver.chrome.service import Service

Проверить, какой Интерпретатор используется можно в Settings - Project: project_name - Python Interpreter

В Selenium 4 инициализация Драйвера происходит через обьект класса Service
service = Service(executable_path=ChromeDriverManager().install()) # Обьект класса Service
executable_path - путь к нашему Драйверу, а так как у нас используются не .bin файлы, а DriverManager, указывается путь к его методу install
Это метод установит Драйвер и передаст путь к нему в Service
Затем инициализируется сам Драйвер
driver = webdriver.Chrome(service=service)
Теперь можно запустить программу - будет открыт и закрыт Хром браузер
Закрывается он автоматически благодаря Service, который отвечает за его закрытие, driver.quit() теперь не нужно указывать

Если нужна одна из прошлых версий браузера, ее можно указать при создании обьекта service в ChromeDriverManager
service = Service(executable_path=ChromeDiverManager(version="114.0.5735.90").install())

Драйвер Firefox создается по аналогичной схеме
from selenium import webdriver
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.firefox.service import Service

service = Service(executable_path=GeckoDriverManager().install())
driver = webdriver.Firefox(serivce=service)

Начиная с Selenium 4.6 (и выше) он сам автоматически скачивает нужный драйвер через встроенный Selenium Manager и webdriver-manager не нужен
webdriver-manager больше не обязателен — Selenium Manager взял его работу на себя
Так же сейчас использовать Service напрямую — необязательно для простых случаев, Selenium Manager сам настроит путь к драйверу за тебя под капотом
Service полезен, когда нужно:

 явный путь к драйверу, 

кастомные логи

, нестандартный порт, 

отладка драйвера


Управление кнопками браузера
driver.forward() - кнопка браузера Вперед
driver.back() - кнопка браузера Назад
driver.refresh() - кнопка браузера Перезагрузить страницу

Получение данных страницы
driver.current_url - текущий урл страницы
driver.title - заголовок текущей страницы
driver.page_source - исходный код страницы

Валидировать данные можно при помощи условия assert
После запятой можно указать сообщение, которое будет выведено в случает неудачи
assert url == 'https://www.motorsport.com/', 'Invalid URL'


find.element() - метод для поиска элементов на странице
В качестве аргументов он принимает:
1. метод поиска: по xpath, class name, css селектору, id
2. значение локатора, по которому находится веб-элелемент
driver.find_element('xpath', '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')
Методы поиска: "id", "xpath", "name", "class name", "css selector"

Так же, искать элементы можно при помощи класса By импортируемого из selenium
Но для этого в каждом файле нужно его импортировать, что не очень удобно
from selenium.webdriver.common.by import By
driver.find_element(By.XPATH, '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')

С точки зрения веб-приложения, веб элемент - это любой элемент на странице
В Селениум, веб-элемент - это тип данных, обьект класса WebElement
driver.get('https://rozetka.com.ua/ua/')
button = driver.find_element('xpath', '/html/body/rz-app-root/div/div[1]/rz-main-header/header/div/div/button[1]')
print(type(button)) # <class 'selenium.webdriver.remote.webelement.WebElement'>

find_elements() - возвращает список элементов у которых одинаковое значение переданного локатора
Так как это список, обращаться к его элементам можно по индексу
Например, если несколько элементов на странице имеют одинаковый class name или id, все их можно получить
titles_list = driver.find_elements('class name', 'title') # [<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.153")>,
<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.154")>, ...,
<selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.176")>]
titles_list[1] # <selenium.webdriver.remote.webelement.WebElement (session="dfb302d11ee9c83fc441db462e5da5b0", element="f.D70249E009AB57F28B2CCACB2B319D5D.d.EC3100381E02A306C64042C8F171B949.e.154")>

XPath (XML path language) - язык запросов к элементам XML, HTML документов
В XPath используются символы /, //, а так же теги
XPath всегда начинается с / или //
/ - означает прямого потомка, аналогичен символу > в CSS-селекторах
html, body, div, span, h1 - в такой структуре span - прямой потомок div, div/span
// - означает потомка любого уровня вложенности
// используется для глобального поиска от корня документа или внутри других тегов
html, body, div, span, h1 - в такой структуре путь к span можно указать как: //span (от корня документа) или html//span (глобальный поиск внутри html тега)
//div[5] - div который в структуре находится на 5-ом уровне вложенности
//a[contains(text(), 'Сканери')] - цей вираз знаходить всі елементи <a>, текст яких містить "Сканери"
Якщо таких елементів кілька, цей вираз повертає список усіх знайдених елементів
(//a[contains(text(), 'Сканери')])[2] - ми огортаємо весь вираз у круглі дужки, щоб спочатку знайти всі елементи, що відповідають умові contains(text(), 'Сканери')
А потім за допомогою індекса [2] вибираємо другий елемент зі списку знайдених елементів
Як працюють круглі дужки:
1. Спочатку виводиться весь список елементів, які відповідають умовам
2. Потім застосовується індексація: [2] вибирає другий елемент з цього списку.
При использовании глобального поиска, в случае изменения меторасположения веб-элемента в структуре дерева, в большинтсве случаев XPath не сломается

К тегам относятся все HTML теги: head, body, div, span, input, h3 и т.д.
Теги могут иметь аттрибуты, один или несколько
К ним относятся: class, id, type, placeholder
Аттрибуты можно использовать для формирования XPath
В XPath аттрибуты указываются в квадратных скобках после тегов
Перед аттрибутом ставится символ @, после названия аттрибута символ = и значение этого аттрибута в кавычках
button[@class='submit'], button - HTML тег, у которого есть аттрибут class, значение которого submit
Исключением является тег text, он указывается без символа @, но с круглыми скобками () - //span[text()='Супер! Дякую']
Например, если в дереве несколько полей ввода, можно указать аттрибут нужного поля, который уникален для него
//input[@type='email'] - у тега input есть аттрибут type, значение которого email и такого значения у аттрибута type нет у других тегов input

Аттрибуты могут имееть значения, которые содержат несколько названий, например class='style-scope ytd-app', содержит style-scope и ytd-app
Что бы не указывать их все, можно воспользоваться методом contains() и передать ему одно из значений аттрибута
contains() указывается после тега, в квадртаных скобках, как аттрибут, но без символа @ и принимает 2 аргумента: название аттрибута с символом @ и его значение в скобках
//div[contains(@class, 'ytd-app')]
Если название аттрибута состоит из 2 и более слов - каждое из них нужно указывать с символом @ и обьеденять при помощи оператора and
<input name="q" required placeholder="Search" class="ms-search-detail-field ms-search-panel__input text-body-xl text-forms-input" type="text" value="bmw">
//input[@required and @placeholder='Search']
//input[@required and @placeholder='Search' and @name='q'] # Использовано 2 аттрибута - required placeholder и name

Если нужно найти тег, у которого несколько аттрибутов - они перечисляются с помощью оператора and
Тег a имеет аттрибуты class='ms-item ms-item-hor-d ms-item-hor-t ms-item-hor-m', data-entity-id='10700419', data-entity-type='article'
//a[@data-entity-id='10700419' and @data-entity-type='article']


Искать веб-элементы также можно по css селекторам:
1. tag - driver.find_element(By.CSS_SELECTOR, 'button')
Найдёт любой <button>
2. class - driver.find_element(By.CSS_SELECTOR, '.login-button')
Найдёт элемент <div class="login-button">
Один класс — одна точка. Несколько классов - 
'.btn.primary.large' # Все три класса одновременно
3. id - driver.find_element(By.CSS_SELECTOR, '#submit-form')
Найдёт <form id="submit-form">.
4. attribute - driver.find_element(By.CSS_SELECTOR, 'input[type="checkbox"]')
Найдёт <input type="checkbox">
Можно и частичное совпадение:



'a[href^="https://"]' # начинается с...

'a[href$=".pdf"]' # заканчивается на...

'a[href*="contact"]' # содержит...

Вложенность:
'div.container > ul > li.active' # Символ > — прямой потомок

'div.container li.active' # Пробел — любой потомок
Комбинации
 - 
'button#login-btn.primary'
 # <button id="login-btn" class="primary">

send_keys() - заполняет поле ввода значением, которое принимает в качестве аргумента
input_field.send_keys('test_email@gmail.com') - введет в поле ввода текст test_email@gmail.com
clear() - очищает поле ввода

get_attribute() - возвращает значение аттрибута веб-элемента к которому применяется
В качестве аргумента принимает название нужного аттрибута:
value - значение/текст в поле ввода
maxlength - максимально допустимая длина текста в поле ввода
input_field.get_attribute("value") # test_email@gmail.com

webdriver.ChromeOptions() - опции браузера (в данном примере Chrome)
К опциям браузера относятся:
incognito - открытие в режиме инкогнито
window-size=1280,780 - с заданными размерами окна
headless - запуск браузера без графического интерфейса (в фоне, что требует меньшего количества ресурсов)
ignore-certificate-errors - игнорирование любых ошибок связанных с SSL-сертификатами (отсутствует, истек и т.д.)
disable_cache - отключение записи кеша
add_argument() - добавить опцию, что бы она выполнялась при запуске тестов
В качестве аргументов передаются названия опций с 2 тире в начале
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument("--incognito")
Для того, что бы опции выполнялись - их нужно передать в Драйвер, при его инициализации, в качестве аргумента
Поэтому создание и добавление опций должно быть указано до строки с созданием Драйвера

Так же можно напрямую импортировать Опции из webdriver
from selenium.webdriver.chrome.options import Options
options = Options()

driver.set_window_size(320, 660) - задать размеры окна браузера
Минус этого варианта в том, что он выполняется уже после инициализации драйвера
Поэтому браузер сначала открывается со стандартными размерами окна, а затем изменяех их на указанные в этом методе

Стратегия загрузки страницы - описывает момент когда Селениум начинает выполнять действия на странице
Возможные варианты: когда на странице загрузились все ресурсы или когда загрузился только ДОМ, ожидание/отсуствие ожидания загрузки всех картинок и тд.
В Селениум есть 3 стратегии загрузки страницы:
normal (используется по умолчанию) - ожидает загрузки всех ресурсов на странице
eager - ожидает загрузки только ДОМ дерева
none - ничего не ожидает ?
Стратегия загрузки страницы задана в Опциях браузера
chrome_options.page_load_strategy = "normal"

options - стандартные настройки браузера
prefs - специфические настройки: пути, директория для скачивания файлов и другие
Для изменения специфических настроек - их и их значения нужно указать в словаре prefs
А затем добавить словарь prefs со всеми нужными специфическими настройками в options при помощи метода add_experimental_option()
Слово "prefs" в add_experimental_option методе является зарезервированным
download.default_directory - специфическая настройка браузера, указывает на папку куда нужно загружать файлы
Для указания пути к папке/файлу можно использовать модуль os, его метод getcws() указывает на текущую директорию
prefs = {
    "download.default_directory": f"{os.getcwd()}"
    # "download.default_directory": f"{os.getcwd()}/folder_for_files" # Папка в текущей директории
    # "download.default_directory": f"{os.getcwd()}\\folder_for_files" # Или обратный слеш ?
}
options.add_experimental_option("prefs", prefs)
https://the-internet.herokuapp.com/download

Веб-элементы для загрузки файлов являются input-полями с type='file'
Поэтому, для того, что бы отправить в них файл - нужно использовать метод send_keys(), а в качестве аргумента передать путь к нужному файлу
upload.field = driver.find_element('xpath', "//input[@type='file']")
upload.field.send_keys(f"{os.getcwd()/files/image_fo_upload.jpg}") # Путь к файлу image_fo_upload.jpg в папке files в текущей директории
Если загрузка файлов реализована на фронтенде через button, то там все равно будет input c type='file' просто он будет скрытым
https://the-internet.herokuapp.com/upload

Ожидания используются для опроса страницы о наличии веб-элемента в течении некоторого времени
Они применяются, в основном, к find_element и find_elements
Ожидания бывают неявные и явные

Неявные ожидания (implicit wait) - это количество времени в течении которого Вебдрайвер будет проверять страницу на наличие веб-элемента при помощи find_element и find_elements
Если элемент будет найден раньше указанного времени - ожидание завершится раньше
Неявное ожидание задается один раз для всего модуля и применяется для каждого find_element и find_elements в нем
driver.implicitly_wait(10) - в качестве аргумента принимает количество времени в секундах

Явное ожидание (explicit wait) ожидает выполнение определенного действия (появления на сранице, изменение цвета и тд), изменения состояния определенного веб-элемента
Оно указывается к конкретному веб-элементу, отдельно для каждого из них
Для использования явного ожидания нужно сделать 2 импорта:
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions
И создать обьект wait, который и отвечает за явное ожидание
Этот обьект является инстантом класса WebDriverWait и принимает 3 аргумента:
1. driver
2. Время, в течении которого Драйвер будет ожидать выполнения явного условия
3. pool_frequency (не обязательный) - частота, с которой проверяется страница на наличие условия
wait = WebDriverWait(driver, 15, poll_frequency=1)
Обьект wait имеет метод until, для ожидания явного условия expected_conditions
Если веб-элемент был найден - этот метод возвращает его

expected_conditions - имеет список доступных условий:
visibility_of_element_located - элемент виден на странице (его высота и ширина больше ноля)
element_to_be_clickable - элемент кликабельный
invisibility_of_element_located - отсутствие элемента на странице
В отличии от find_element, эти методы в качестве аргумента принимают не веб-элемент, так как он еще не появился на странице
Они принимают кортеж из 2 элементов: метод поиска веб-элемента на странице и его локатор (внутри метода кортеж будет распакован на элементы)
text_to_be_present_in_element_value - проверяет что в элементе находится нужный текст
Данный метод принимает 2 аргумента: кортеж из метода поиска и локатора, а так же текст, с которым будет сравниватся текст в элементе
text_to_be_present_in_element_value(('xpath', "//input[@type='text']"), "Hi"))

Input field has no text attribute ?
Other 2 methods text_to_be_present_in_element

Для удобства, метод поиска и локатор веб-элемента можно записывать в отдельную переменную - VISIBLE_AFTER_BUTTON = ('xpath', "//button[@id='visibleAfter']")
wait.until(expected_conditions.visibility_of_element_located(VISIBLE_AFTER_BUTTON)) # С использованием переменной
wait.until(expected_conditions.visibility_of_element_located(('xpath', "//button[@id='visibleAfter']"))) # Вернет веб-элемент, если найдет его
visible_after_button = wait.until(expected_conditions.visibility_of_element_located(VISIBLE_AFTER_BUTTON))
visible_after_button.click()

wait.until(ec.условие) — ожидает состояние элемента, если элемент УЖЕ есть в DOM
Он не ждёт появления элемента в DOM — предполагает, что элемент найден, и только ждёт его видимость, кликабельность и т.д
Если элемента нет в DOM, то ec.visibility_of_element_located (и подобные) выбросят исключение при поиске и wait.until не сможет начать работу
Появление элемента в DOM нужно обрабатывать отдельно
Эти методы ждут появления веб-элементов на странице:
presence_of_element_located(locator)


visibility_of_element_located(locator)


element_to_be_clickable(locator)


presence_of_all_elements_located(locator)


visibility_of_all_elements_located(locator)


frame_to_be_available_and_switch_to_it(locator)
А эти ждут ТОЛЬКО изменение состояния уже найденного элемента
Т.е. элемент уже должен быть найден и передан как объект, они не ищут элемент сами, а только смотрят состояние переданного объекта элемента

visibility_of(element)


element_to_be_selected(element)


element_selection_state_to_be(element, state)


invisibility_of_element(element)


staleness_of(element)


Alert - не является веб-элементом, его нет в ДОМ и его нельзя проинспектировать
Алерт на странице в момент времени может быть только один
Для того что бы Селениум мог взаимодействовать с ним, его нужно записать в переменную, а затем переключится на него
alert = wait.until(expected_conditions.alert_is_present())
driver.switch_to.alert
alert.accept() - кликнуть на кнопку Принять/OK в Алерте
alert.dismiss() - кликнуть на кнопку Отклонить в Алерте
alert.text - сообщение отображаемое в Алерте
alert.send_keys() - ввести текст в поле ввода в Алерте, если оно там есть
Текст введенный в поле ввода в Алерте не отображается в браузере Селениум
https://demoqa.com/alerts/

save_screenshot() - сохранить скриншот текущей страницы в текущую директорию
Название файла передается в качестве аргумента в виде строки - driver.save_screenshot("screenshot.png") - how to use f strings here ?

disable-blink-features=AutomationControlled - опция, которая отключает ВебДрайвер мод, что б приложения не определяли тесты как автоматизированное устройство управления браузером
options.add_argument("--disable-blink-features=AutomationControlled")
Однако часто этого бывает не достаточно, а что бы приложение распознавало автотесты как реального пользователя и не блокировало как бота - нужно использовать User-Agent
User-Agent - это строка, которая содержит информацию о клиенте (название браузера, его версию и тд)
Для веб-приложений это идентификатор, который определяет реального пользователя и даже может подстраивать свое поведение, логику в зависимости от информации в User-Agent
В User-Agent содержится следующая информация:
1. Название и версия браузера
2. Язык
3. ОС и его версия
4. Тип устройства
Список Юзер-Агентов - https://www.useragents.me/
options.add_argument("--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1.1 Safari/605.1.1")

Cookie - текстовые файлы небольшого размера, которые веб-сайты сохраняют на ПК пользователя, когда он их посещает
Сайты хранят в этих файлах информацию о клиенте (токен авторизации, какие товары он добавил в корзину, какую тему, язык выбрал на сайте и тд)
Когда пользователь снова посещает ранее просмотренный веб-сайт, его браузер отправляет Куки на сервер, что бы сайт мог восстановить у себя информацию о клиенте
get_cookies - получить все куки
get_cookie - получить значение определенной куки, название которой передается в виде аргумента
cookie_abtest = driver.get_cookie("abtestv2")
delete_cookies - удалить все куки
delete_cookie - удалить определенное куки, название которой передается в виде аргумента
driver.delete_cookie("abtestv2")
add_cookie - добавить куки, в качестве аргумента передается словарь
driver.add_cookie({"name": "Hi", "value": "123"})
Для изменения куки - ее нужно сохранить в переменную, удалить на сайте, внести изменения в сохраненную, а затем добавить ее на сайт
cookie_abtest = driver.get_cookie("abtestv2")
driver.delete_cookie("abtestv2")
cookie_abtest["value"] = "version"
driver.add_cookie(cookie_abtest)
cookie_abtest_after = driver.get_cookie("abtestv2")
print(cookie_abtest) # {'domain': '.motorsport.com', 'expiry': 1773866707, 'httpOnly': False, 'name': 'abtestv2', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'v8.3'}
driver.add_cookie(cookie_abtest) # {'domain': '.motorsport.com', 'expiry': 1773866707, 'httpOnly': False, 'name': 'abtestv2', 'path': '/', 'sameSite': 'Lax', 'secure': True, 'value': 'version'}
Ключи и значения в куках должны быть типом строка, иначе будет выброшено исключение
cookie['value'] = '9'

Куки, все или только нужные, можно сохранить в отдельный файл при помощи модуля pickle и его метода dump
В качестве аргументов, этот метод принимает: обьект который нужно скачать и путь к файлу, в который его нужно сохранить
import pickle
1. pickle.dump(driver.get_cookies(), open(os.getcwd()+"/cookies/all_cookies.pkl", "wb"))
2. pickle.dump(driver.get_cookies(), open(os.path.join(os.getcwd(), "cookies", "all_cookies.pkl"), "wb"))
3. with open(os.path.join(os.getcwd(), "cookies", "all_cookie.pkl"), "wb") as f:
       pickle.dump(driver.get_cookies(), f)
Метод open принимает путь к файлу и протокол сериализации (преобразования данных), в котором будет открыт этот файл для записи данных
wb - write binary - файл будет открыт для записи бинарных данных
Данные должны быть записаны именно в бинарном режиме потому, что pickle работает с данными этого типа, а не текстового или другого
Если открыть файл в обычном режиме w, то возможно проблемы с кодировкой или искажение данных
После этого, сохраненные куки можно загрузить на сайт при помощи метода pickle - load
В качестве аргументов он принимает: путь к файлу с куками и протокол
Протокол в этом случае будет rb - read binary
Метод load возвращает данные из прочитанного файла, поэтому результат его вызова нужно присвоить переменной
cookies = pickle.load(open(os.getcwd()+"/cookies/all_cookies.pkl", "rb"))
Куки были сохранены в файл при помощи метода get_cookies, который возвращает массив состоящий из кук
Поэтому, переменная cookies содержит этот массив и что б добавить их все на сайт - нужно использовать цикл для их перебора
for cookie in cookies:
    driver.add_cookie(cookie)
Перед добавлением куки, их нужно удалить, что б они не дублировались - driver.delete_all_cookies()


Checkbox - веб-элемент, взаимодействие с которым происходит через клик
CHECKBOX_1 = ('xpath', "//input[@type='checkbox'][1]")
checkbox1 = driver.find_element(*CHECKBOX_1)
checkbox1.click()
У отмеченного/активного чекбокса есть аттрибут checked, даже если его не видно в HTML, он есть, но скрыт в ДОМ - он нужен для проверки состояния чекбокса
Есть 2 способа проверить состояние чекбокса
Первый - при помощи метода get_attribute
print(checkbox1.get_attribute('checked')) # None - чекбокс не отмечен
print(checkbox1.get_attribute('checked')) # true - чекбокс активен
Метод возвращает строку true, а не булевое значение True, что нужно учитывать при проверке результата
assert checkbox1.get_attribute('checked') is not None
assert checkbox1.get_attribute('checked') == 'true'
Второй - при помощи метода is_selected
print(checkbox1.is_selected()) # True - чекбокс выбран
print(checkbox1.is_selected()) # False - чекбокс не активен
Element click intercepted - ошибка когда элемент в HTML разметке перекрыт другими эелементами (svg, картинками, блоками и тд) и нет возможности на него кликнуть
В таком случае нужно использовать один элемент для клика, а сам input с типом checkbox - для проверки на аттрибут checked
Веб-элемент для клика нужно брать тот, по которому возможен клик, он не перекрыт другими элементами и находится на самом верху
CHECKBOX_1 = ('xpath', "//label[@for='tree-node-home']") # Элемент для клика
CHECK_STATUS = ('xpath', "//input[@id='tree-node-home']") # Сам чекбокс для проверки его аттрибута checked после клика
checkbox1 = driver.find_element(*CHECKBOX_1)
checkbox1.click()
assert driver.find_element(*CHECK_STATUS).is_selected() is True

Если блоки, клик на которые меняет их поведение (цвет, размер и тд), не являются input-полями - метод is_selected для них не работает
В таком случае, у элемента после клика может менятся аттрибут в HTML (active, selected) - это будет точкой для проверки
CHECKBOX1 = ('xpath', "//li[@class='mt-2 list-group-item list-group-item-action'][2]")
checkbox1 = driver.find_element(*CHECKBOX1)
checkbox1_class = checkbox1.get_attribute('class')
print(checkbox1_class) # mt-2 list-group-item list-group-item-action - класс элемента до клика
checkbox1.click()
checkbox1_class_active = checkbox1.get_attribute('class')
print(checkbox1_class_active) # mt-2 list-group-item active list-group-item-action - class элемента изменился после клика на него
assert 'active' in checkbox1_class_active

Radio-button создается так же при помощи input-поля и поэтому, взаимодействие с ним происходит так же через клик
Отличием от чекбокса является то, что в одной форме можно выбрать только одну радио-кнопку, а чекбоксов можно выбрать несколько
Если радио-кнопка перекрыта другими элементами и клик на ее input не возможет, применяется тот же способ что и для чекбоксов - один элемент для клика, а сам input с типом radio, для проверки на то, отмечен ли он (is_selected)
YES_RADIO = ('xpath', "(//label[@class='custom-control-label'])[1]")
YES_RADIO_STATUS = ('xpath', "//input[@id='yesRadio']")
yes_radio = driver.find_element(*YES_RADIO)
yes_radio.click()
assert driver.find_element(*YES_RADIO_STATUS).is_selected() is True

is_enabled - проверить, не находится ли чекбокс, радио/обычная кнопка в статусе disabled
print(yes_radio.is_enabled())

Proxy-server - это посредник между ПК пользователя (или локальной сетью) и интернетом
Используя прокси, весь трафик проходит через этот сервер, прежде чем достигает назначения и обратно
Прокси может скрывать IP-адресс, обходить блокировки и другое
Прокси сервер добавляется в Селениум при помощи Опций браузера
from selenium.webdriver.chrome.options import Options
PROXY_SERVER = "172.104.209.44:1080"
options = Options()
options.add_argument(f"--proxy-server=http://{PROXY_SERVER}")
driver = webdriver.Chrome(service=service, options=options)
driver.get('https://whatismyipaddress.com/') # Проверить, изменился ли IP-address и мето нахождения
Если для Прокси сервера нужен логин и пароль - его нужно указать перед его адрессом PROXY_SERVER = "username:password@172.104.209.44:1080"

Если для тестов нужны несколько разных пользователей - можно создать несколько обьектов driver, все они будут независимыми и не будут влиять друг на друга
Обьект Service в данном случае, создается по усмотрению, что бы окно браузера не закрылось раньше нужного времени
from selenium import webdriver
driver1 = webdriver.Chrome()
driver1.get('https://www.motor1.com/')
driver2 = webdriver.Chrome()
driver2.get('https://www.motor1.com/')

Селениум держит фокус на первой открытой вкладке, поэтому, если открывается новая - ему нужно явно указать переключится на нее
Для Вебдрайвера нет разницы между вкладкой и отдельным окном браузера, для него это одно и тоже
Все вкладки и окна работают в рамках одной сессии. Тоесть, если вы авторизовались в одной вкладке и откроете новую или новое окно - в нем вы так же будете авторизованы
Дескриптор - уникальный идентификатор/айди окна или вкладки, который позволяет различать их между собой
current_window_handle - получить дескриптор текущей вкладки/окна
window_handles - получить дескрипторы всех открытых вкладок/окон
window_handles - возвращает список идентификаторов всех открытых вкладок
Для переключения между вкладками нужно обращатся к соответствующему дескриптору при помощи индекса списка
switch_to.window() - метод для переключения между вкладками. В качестве аргумента принимает идентификатор нужной вкладки
tabs = driver.window_handles # Список айди всех открытых вкладок
driver.switch_to.window(tabs[1]) # Переключение во вторую вкладку
switch_to.new_window('tab') - открывает новую вкладку и автоматически переключает фокус Селениум на нее
switch_to.new_window('window') - открывает новое окно и сразу переключет фокус Селениум на него
driver.switch_to.new_window("tab")
driver.get('https://www.autosport.com/') # Ссылка будет открыта в новой вкладке и фокус Селениум будет на ней, в ней сразу можно будет работать

Select - это поле, клик на которое открывает дроп-даун список, из которого можно выбрать айтем
Селекты могут быть реализованы двумя способами:
1. при помощи тега select, а айтемы в списке - при помощи тега option - старая реализация
2. через тег div и input внутри него - современная реализация

1. Для работы с Селектами такого типа, нужно импортировать класс Select и создать его обьект. Этот обьект и будет дроп-даун списком
Создание обьекта класса Select нужно для того, что б можно было работать с его айтемами - option
from selenium.webdriver.support.select import Select
https://the-internet.herokuapp.com/dropdown
SELECT_LOCATOR = ('xpath', "(//select[@class='ms-result-table-grouping-header__select text-body font-bold uppercase ms-native-select__select'])[2]")
DROP_DOWN = Select(driver.find_element(*SELECT_LOCATOR))
Обьекту класса Select доступны все методы веб-элемента Селект
Взаимодействовать с элементами Селекта можно тремя способами:
select_by_visible_text - через текст
select_by_value - значение (value)
select_by_index - индекс

options - возвращает список всех айтемов/опций в Селекте
Перебор всех опций Селекта можно осуществить при помощи цикла for
Перебор по тексту опций
drop_down_options = DROP_DOWN.options
for o in drop_down_options:
    # DROP_DOWN.select_by_visible_text(o.text.title()) # Если стиль текста преобразуется на фронте
    DROP_DOWN.select_by_visible_text(o.text) # Каждая опция Селекта будет выбрана в нем
По индексу
for o in range(len(drop_down_options)):
    DROP_DOWN.select_by_index(o)
По значению аттрибута value
for o in drop_down_options:
    DROP_DOWN.select_by_value(o.get_attribute("value"))

Модуль Keys используется для иммитации нажатия на кнопки клавиатуры
Ему доступны все кнопки на клавиатуре и их сочетания (ctrl + c, ctrl + v и тд)
https://the-internet.herokuapp.com/key_presses
from selenium.webdriver import Keys
driver.get("https://the-internet.herokuapp.com/key_presses")
input_field = driver.find_element('xpath', "//input[@id='target']")
input_field.send_keys(Keys.F2)
time.sleep(2)
input_field.send_keys(Keys.CONTROL + "V")
time.sleep(2)

Keys.TAB - так же используется для автоматического завершения части введенного слова
driver.get("https://demoqa.com/select-menu")
multi_select = driver.find_element('xpath', "//input[@id='react-select-4-input']")
multi_select.send_keys("Gre")
time.sleep(2)
multi_select.send_keys(Keys.TAB) # Из дроп-даун списка выберет айтем с текстом Green
time.sleep(2)

2. Современные Селекты реализованы при помощи div и input внутри него
Поэтому работать с ними можно двумя способами:
1. как с input и send_keys для него
2. как с div
В качестве аргумента в send_keys - передать айтем из дроп-даун списка и нажать Enter для его выбора
driver.get("https://demoqa.com/select-menu")
drop_down = driver.find_element('xpath', "//input[@id='react-select-3-input']")
drop_down.send_keys("Mr.")
time.sleep(4)
drop_down.send_keys(Keys.ENTER)
time.sleep(4)

Список дроп-даунов закрывается если с него убрать фокус курсора
Что бы исчезающие элементы не пропадали и были доступны для испектирования - можно использовать функцию setTimeout в Консоли - setTimeout(function() { debugger; }, 5000)
Этот код запускает режим Дебагера и останавливает выполнение JS кода на странице через 5 секунд
Если работать с дроп-даунами как с тегом div, тогда клик нужно делать на нужный div и в появившемся списке кликать на нужный элемент
driver.get("https://demoqa.com/select-menu")
drop_down_btn = driver.find_element('xpath', "(//div[@class='col-md-6 col-sm-12'])[4]")
drop_down_btn.click()
time.sleep(2)
item = driver.find_element('xpath', "//div[@class=' css-1s9izoc']/div/div[2]") # //div[text()='Mr.']
item.click()
time.sleep(2)

Тег iframe - позволяет встраивать HTML страницу в другую HTML страницу
На одной странице может быть несколько айфреймов, поэтому, для работы с элементами iframe - ВебДрайверу нужно явно указать, с какой именно страницей ему работать
Без явного указания ВебДрайвер не найдет элементы внутри айфреймов
switch_to.frame - метод для переключения в Айфрем
Переключится в Айфрейм можно при помощи:
1. самого веб-элемента Айфрейм
IFRAME = ('xpath', "//iframe[@id='sp_message_iframe_1274672']")
# iframe = wait.until(expected_conditions.visibility_of_element_located(IFRAME)) # Если Айфрейм появляется не сразу
iframe = driver.find_element(*IFRAME)
driver.switch_to.frame(iframe)
2. значения его тега id
driver.switch_to.frame('sp_message_iframe_1274672')
3. значения его тега name
4. индекса
driver.switch_to.frame(0) # Переключится в первый по очереди Айфрейм на странице
Что бы после переключения в Айфрейм дальше работать с элементами основной страницы - нужно явно переключится на нее
switch_to.default_content - переключение на основную страницу
Если нужный Айфрейм находится внутри других Айфреймов - нужно переключатся в них в порядке очереди, от внешнего к нужному внутреннему
driver.get('https://demoqa.com/nestedframes')
driver.switch_to.frame('frame1')
text1 = driver.find_element('xpath', "//body").text
print(text1) # Parent frame
driver.switch_to.frame(0)
text2 = driver.find_element('xpath', "//body").text
print(text2) # Child Iframe
Если после работы с Айфреймом, который находится внутри другого Айфрейма, нужно вернутся во внешний - это можно сделать при помощи switch_to.parent_frame
driver.switch_to.parent_frame()
print(driver.find_element('xpath', '//body').text) # Parent frame - ВебДрайвер вернулся во внешний Айфрейм

Такие действия как: двойной клик, клик правой кнопкой мыши, ховер, перетаскивание элементов и другие не входят в базовый набор функций Селениум
Для них существует отдельный API - action chains (цепочки действий)
Его нужно импортировать в модуль и создать его обьект. В качестве аргумента, при создании обьекта, нужно передать созданный ранее driver
from selenium.webdriver.common.action_chains import ActionChains
driver = webdriver.Chrome()
action = ActionChains(driver)
Обьекту action доступны такие методы как:
double_click - двойной клик
click - клик левой кнопкой мыши
context_click - клик правой кнопкой мыши (открывает контекстное меню)
move_to_element - ховер на элемент
pause - пауза на определенное количество секунд, которое передается как аргумент
Все эти методы, в качестве аргумента, принимают веб-элемент, над которым нужно совершить действие
Каждая цепочка действий имеет свое начало - первое действие и должна заканчиватся методом perform() - который обозначает ее завершение и запускает всю цепочку
driver.get('https://testkru.com/Elements/Buttons')
HOVER_BTN = ('xpath', "//button[@name='colorChangeOnHover']")
action.move_to_element(driver.find_element(*HOVER_BTN)).perform() # move_to_element - начало цепочки действий, а perform - ее завершение
Цепочка действий может содержать несколько действий
double_click_btn = driver.find_element(*DOUBLE_CLICK_BTN)
right_click_btn = driver.find_element(*RIGHT_CLICK_BTN)
left_click_btn = driver.find_element(*LEFT_CLICK_BTN)
hover_btn = driver.find_element(*HOVER_BTN)
action.double_click(double_click_btn).context_click(right_click_btn).click(left_click_btn).move_to_element(hover_btn).perform() # 4 действия в одной цепочке
Если цепочка действий получилась довольно длинной, для лучшей читаемости, ее можно разделить на несколько строк. Сделать это можно двумя способами:
1. обернуть ее всю в круглые скобки и разделить переносами на новую строку
(action.move_to_element(rally_category).
pause(2).
move_to_element(serie_in_rally).
perform())
2. при помощи обратного слеша и переноса
action.move_to_element(rally_category).\
 pause(2).\
 move_to_element(serie_in_rally).\
 perform()

Есть 2 способа работы с drag-and-drop
1. drag_and_drop метод цепочки действий
Он принимает 2 веб-элемента, в качестве аргументов: source - какой блок перетягивать, target - куда перетягивать
BLOCK_A = ('xpath', "//div[@id='column-a']")
BLOCK_B = ('xpath', "//div[@id='column-b']")
driver.get('https://the-internet.herokuapp.com/drag_and_drop')
action.drag_and_drop(driver.find_element(*BLOCK_A), driver.find_element(*BLOCK_B)).perform()
print(driver.find_element('xpath', "//div[@id='column-a']/header").text)
Но этот способ не всегда подходит. Например, когда блок, в который нужно перетянуть, отображается не сразу, а с небольшой задержкой
2. При помощи методов click_and_hold - который берет элемент который нужно перетащить, move_to_element - куда нужно перетащить и release
release - отпускает зажатую кнопку мыши
driver.get('https://tympanus.net/Development/DragDropInteractions/sidebar.html')
DRAG_BLOCK = ('xpath', "//div[@class='grid__item'][2]")
DROP_BLOCK = ('xpath', "//div[@class='drop-area__item'][2]")
action.click_and_hold(driver.find_element(*DRAG_BLOCK)).pause(1.5).move_to_element(driver.find_element(*DROP_BLOCK)).release().perform()
changes = driver.find_element('xpath', "//div[@id='drop-area']//div[2]").get_attribute('class')
time.sleep(2)
print(changes)
assert "drop-area__item drop-feedback" == changes

execute_script - позволяет выполнять JS код на странице
driver.execute_script("alert('Hi')")

Скрол на странице можно реализовать 2 способами:
1. scroll_to_element метод цепочки действий
driver.get('https://seiyria.com/bootstrap-slider/')
EXAMPLE2 = ('xpath', "//h3[text()='Example 2: ']")
action.scroll_to_element(driver.find_element(*EXAMPLE2)).perform()
2. при помощи Javascript (метода window.scrollTo), кастомного класса и методов которые его используют
class Scrolls:
    def __init__(self, driver, action):
        self.driver = driver
        self.action = action

    def scroll_by(self, x, y):
        self.driver.execute_script(f"window.scrollTo({x}, {y})")

    def scroll_to_bottom(self):
        self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight)")

    def scroll_to_top(self):
        self.driver.execute_script("window.scrollTo(0, 0)")

    def scroll_to_element(self, element):
        self.action.scroll_to_element(element).perform()
        self.driver.execute_script("""window.scrollTo({top: window.scrollY + 700,});""")
	# self.driver.execute_script("window.scrollTo(0, window.scrollY - 700)")

Плавный скролл вниз, вверх, к элементу
class Scrolls:
    def __init__(self, driver, action):
        self.driver = driver
        self.action = action

    def scroll_to_top(self):
        self.driver.execute_script("window.scrollTo({top: 0, behavior: 'smooth'});")
    
    def scroll_to_bottom(self):
        self.driver.execute_script("window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});")

    def scroll_to_elem_with_offset_down(self, elem):
        self.action.scroll_to_element(elem).perform()
        # time.sleep(4) # Just to check
        self.driver.execute_script("window.scrollTo({top: window.scrollY + 700, behavior: 'smooth'});")
	# self.driver.execute_script("window.scrollTo(0, window.scrollY - 700)")

# The x can always be 0, to scroll up and down
    def scroll_to_coord(self, x, y):
        self.driver.execute_script(f"window.scrollTo({x}, {y});")


Для установки расширения нужен его файл в формате .crx
После его скачивания в магазине расширений Хром, этот файл очень тяжело найти на ПК и легче его найти и скачать в интернете
Например .crx файл AdBlocker расширения можно скачать тут https://www.crx4chrome.com/crx/31927/
Затем этот файл нужно добавить в директорию с проектом
Добавляются и устанавливаются расширения при помощи options и метода add_extension, который в качестве аргумента принимает путь к .crx файлу расширения
options = webdriver.ChromeOptions()
options.add_extension("adblocker.crx")
driver = webdriver.Chrome(options=options)
driver.get('https://www.motorsport.com/')

Если после установки расширения оно открывает свою страницу и переключает фокус на нее, нужно переключится в новую вкладку, а затем переходить на нужную ссылку
wait = WebDriverWait(driver, 15, 1)
ec = expected_conditions
wait.until(ec.number_of_windows_to_be(2)) # 1-я вкладка data, 2-я - страница расширения
driver.switch_to.new_window('tab') # Третяя вкладка для перехода на нужную странцу
driver.get('https://www.motorsport.com/')

Пример работы без новой вкладки
wait.until(ec.number_of_windows_to_be(2))
driver.get('https://www.motorsport.com/')
driver.switch_to.window(driver.window_handles[0])


Для прохождения базовой авторизации на сайте имя и пароль указывается в ссылке, на которую нужно перейти - https://username:password@domain/path
driver.get('https://m:m@www.s.motorsport.com')


Эмулировать мобильное устройство можна используя Опции, add_experimental_option метод и "mobileEmulation" строку
Слово mobileEmulation, в add_experimental_option методе, является зарезервированным и отвечает за эмуляцию
В add_experimental_option нужно передать строку "mobileEmulation" и словарь с нужными параметрами
mobile_emulation = {"deviceName": "iPhone X"} # Эмулирует Айфон Х
options.add_experimental_option("mobileEmulation", mobile_emulation)
Эмулировать можно стандартные телефоны для браузера. Для Хром это: iPhone X, iPhone 6, Nexus 5, Nexus 6P, Samsung Galaxy S5, Galaxy Note 3
Если нужного телефона нет в списке стандартных для браузера или нужны кастомные настройки, можно использовать deviceMetrics в mobile_emulation словаре
mobile_emulation = {
    "deviceMetrics": {
        "width": 360,   # Ширина экрана
        "height": 640,  # Высота экрана
        "pixelRatio": 3.0  # Плотность пикселей
    },
    "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5 Build/MOB30V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36"
}


Елемент, внутри которого находится shadow-root - shadow-host
Поиск элементов в shadow dom
# Перший рівень
shadow1 = driver.find_element(By.CSS_SELECTOR, 'outer-element')
root1 = driver.execute_script('return arguments[0].shadowRoot', shadow1)

# Другий рівень
shadow2 = root1.find_element(By.CSS_SELECTOR, 'inner-element')
root2 = driver.execute_script('return arguments[0].shadowRoot', shadow2)

# Цільовий елемент
target = root2.find_element(By.CSS_SELECTOR, '.final-target')

find_element не работает напрямую внутри Shadow DOM, пока ты не получил shadow root через JavaScript и не присвоил его в переменную
Только тогда ты можешь вызывать find_element() на этом shadow root'е
root1 = driver.execute_script('return arguments[0].shadowRoot', shadow1)
В root1 озвращается shadowRoot — это JavaScript-объект
Selenium автоматически оборачивает его в WebElement
Благодаря этому с ним можно работать как с обычным веб-элементов и ему доступны все его методы. Можно использовать root1.find_element(), как будто это обычный DOM-элемент


То есть Selenium как бы говорит: 
"Окей, я не умею залезать в shadow DOM напрямую, но раз ты мне его через JS передал — я с ним поработаю как с WebElement"

При использовании XPath внутри shadow root, начинать путь поиска с точки .//, чтобы указать, что поиск идет относительно самого shadow root
shadow_element = shadow_root.find_element(By.XPATH, ".//tagname[@attribute='value']")

Но, стандартные expected_conditions НЕ УМЕЮТ работать с shadowRoot
Они всегда ожидают через стандартные find_element, а не через JavaScript в теневом дереве
С теневым DOM надо работать через кастомную функцию с execute_script и ожиданием, а не через стандартные EC
def wait_for_shadow_element(driver, host_locator, inner_selector, timeout=15): # Кастомная функция
    wait = WebDriverWait(driver, timeout)

    # Функция для поиска и получения элемента
    def get_element(_): # Этот не используемый параметр нужен, так как wait.until передает в эту функцию текущий driver, который используется
        try:
            host = driver.find_element(*host_locator) # Находит host-элемент, внутри у кого есть shadowRoot
            elem = driver.execute_script(
                "return arguments[0].shadowRoot.querySelector(arguments[1])",
                host, inner_selector
            ) # Заходит в shadowRoot и ищет там элемент по селектору
            return elem if elem else False # Если элемент найден — возвращает его, если нет — возвращает False
        except Exception:
            return False

    return wait.until(get_element) # Ожидание элемента

Как работает WebDriverWait.until() под капотом:


until() принимает на вход функцию (у тебя это get_element)
Эта функция (get_element) будет вызываться снова и снова каждые 500 мс (по умолчанию) до тех пор, пока:


1. она не вернет "что-то правдивое" (truthy value) — например,  найденный WebElement — считается истинным
2. или не истечет timeout времени ожидания
Если элемент не найден (element == None), то возвращается False
wait.until(get_element) видит, что результат — False, и понимает: "Нет, еще рано, элемент не найден"


Поэтому НЕ завершает ожидание и вызывает get_element снова через 0.5 секунды (по-умолчанию)


И так до тех пор, пока get_element не вернет настоящий WebElement и wait.until вернет его или пока не завершится timeout секунд и если элемент так и не вернулся - выбрасывается TimeoutException

sign_in_button = wait.until(shadow_root.find_element(*SIGN_IN_BUTTON))
Функция find_element(*SIGN_IN_BUTTON) вызывается СРАЗУ, прямо при передаче аргумента в wait.until, 
поэтому исключение NoSuchElementException выбрасывается ДО того, как wait.until начнёт работать
wait.until даже не успевает начать цикл проверок, потому что ты вызываешь функцию и передаёшь ее результат, а не передаешь саму функцию, как обьект
Нужно передать функцию, чтобы wait.until мог вызывать её многократно и сам обрабатывать исключения:
sign_in_button = wait.until(lambda driver: shadow_root.find_element(*SIGN_IN_BUTTON))
Тут wait.until будет вызывать эту лямбду снова и снова, ловить NoSuchElementException, и ждать, пока элемент появится
Или можно создать отдельную функцию
def get_elem(host_locator, elem_locator):
    def find_elem(_):
        host = wait.until(ec.visibility_of_element_located(host_locator))
        root = driver.execute_script("return arguments[0].shadowRoot", host)
        button_elem = root.find_element(*elem_locator)
        return button_elem

    return wait.until(find_elem)

Если обычный DOM - wait.until(EC...)


Если Shadow DOM - wait

При использовании querySelector через execute_script, если элемент не найден - исключения не выбрасываются
Вместо этого querySelector просто возвращает null
element = driver.execute_script("return arguments[0].shadowRoot.querySelector(arguments[1])", host, selector)
return element if element else False
При использовании find_element, если элемент не найден - выбрасывается исключение типа NoSuchElementException
И в таком случае его нужно обрабатывать при помощи try/except иначе дальнейшее выполнение кода остановится
try:
    elem = shadow_root.find_element(*SIGN_IN_BUTTON)
except NoSuchElementException as e:
    print(e)

shadow_root = driver.execute_script("return arguments[0].shadowRoot", shadow_host)
Объект shadowRoot, полученный через execute_script, не возвращается как WebElement
Selenium не может напрямую "удерживать" shadowRoot как DOM-объект
Поэтому, к сожалению, его нельзя использовать напрямую как аргумент в следующих вызовах
Нельзя вернуть shadowRoot напрямую как WebElement,
 потому что Selenium возвращает WebElements, соответствующие CSS-селекторам или XPath, а не DOM-объекты вроде shadowRoot
Это ограничение API Selenium, которое требует обхода через execute_script
querySelector через execute_script как основной способ поиска в Shadow DOM стабильнее, безопаснее и гибче

Selenium возвращает специальный объект WebElement (класс WebElement в Python), который в себе не хранит строку CSS-селектора или XPath, а является “обёрткой” вокруг указателя на DOM-элемент в браузере
Тоесть WebElement - это не строка селектора и не HTML-код самого элемента, а идентификатор, который позволяет Selenium посылать команды браузеру, чтобы взаимодействовать с этим элементом (клик, ввод текста, чтение атрибутов)
Проще говоря, WebElement — это ссылка на объект DOM в браузере, но не сам объект DOM, а именно ссылка, через которую WebDriver общается с браузером по протоколу WebDriver
Если вернуть что-то не являющееся HTML-элементом, Selenium не сможет с этим работать как с WebElement.
Поэтому shadowRoot нельзя вернуть напрямую — его нужно использовать внутри JavaScript-кода, а возвращать нужно конкретные HTML-элементы внутри shadowRoot
Когда ты возвращаешь shadowRoot через execute_script, Selenium не может его превратить в WebElement, потому что shadowRoot не является HTML-элементом (это объект JavaScript типа ShadowRoot)
А Selenium ожидает вернуть HTML-элемент (node), чтобы обернуть его как WebElement


selenium.common.exceptions.StaleElementReferenceException: Message: stale element reference: stale element not found
"Stale" — значит "устаревший"
Ты получил ссылку на элемент, а потом DOM изменился (страница обновилась, элемент перерисовался, исчез и появился заново и т.п.)
В итоге: Selenium говорит тебе — «элемент, который ты нашёл раньше, больше не существует в DOM»
Частые причины:
1. Перезагрузка или частичное обновление страницы (SPA, React, Angular и т.п.)
2. Элемент исчезает и появляется снова (например, анимации, попапы)
3. DOM меняется после клика или AJAX-запроса
4. Слишком рано обращаешься к элементу после загрузки
Как это исправить - всегда искать элемент "перед действием", а не заранее:
driver.find_element('xpath', "//input[@name='q']").clear()
driver.find_element('xpath', "//input[@name='q']").send_keys("test")


1. Создание нового проекта
2. Кнопки браузера (вперед, назад...)
3. Получение данных страницы (тайтл, урл, сорс код)
4. find_elements
5. Contains, and, get_attribute, для аттрибутов, аттрибут text
6. Опции, add_attribute: размер окна, инкогнито, хедлес мод, отключить кеш
7. Стратегия загрузки страниц
8. Загрузка, скачивание файлов, prefs
9. Явные ожидания, expected conditions
10. Send_keys for input fields
11. Alert
12. Screenshot
13. User Agent
14. Cookie, pickle module
15. Checkbox
16. Radio button
17. Proxy server
18. Для иммитации 2х пользователей - 2 разных драйвера
19. Переключение между вкладками, открытие новой вкладки, окна
20. Select 2х типов (drop-down)
21. Модуль Keys
22. iframe
23. Цепочка действий
24. Drag-and-drop
25. Execute JS script
26. Scroll
27. Установка расширений
28. Эмуляция мобилки